{"id":"CityFurnJulianDataLine_sum","input_data":"0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *","context":"","output":"These fixed form ILE RPG lines calculate the Julian date given a 6 digit calendar date.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDataLine/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"line","depth":"sum"}}
{"id":"CityFurnJulianDataLine_api","input_data":"0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *","context":"","output":"## Purpose\n\nThese fixed form ILE RPG lines calculate the Julian date given a calendar date.\n\n## Parameters\n\n- Given variable `DATE` with format 'MMDDYR'.\n- Output is a 6 byte field named `JDATE6` with\n  - byte 1   = century (1 for 1900s, 2 for 2000s)\n  - byte 2-3 = 2 digit year\n  - byte 4-6 = Julian number of days\n\n## Dependencies\n\nCompile time initialized arrays\n\n- MY = number of preceding days for each month\n- LY = same as MY but in case of a leap year\n\n## Impacts\n\n### Indicators\n\n- 80 - turned on if the given year is a leap year\n- 83 - turned off by `SRCen` subroutine\n\n### Global Variables\n\n- MODAY - has MMDD of DATE\n- YEAR1 - has YY of DATE\n- MO1 - has MM of DATE\n- DAY1 - has DD of DATE\n- X - has result of YY/4\n- DAYS1 - has number of days since beginning of year til DATE\n- JDATE - has YYnnn where nnn is number of days since beginning of year\n- JDATE6 - has CYYnnn\n  - byte 1   = century (1 for 1900s, 2 for 2000s)\n  - byte 2-3 = 2 digit year\n  - byte 4-6 = Julian number of days\n\n### Called Subroutines\n\n#### Subroutine `SRCen`\n\nCalculates the century for a given 2 digit year and\ncreates a 3 digit year with that prefix","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDataLine/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"line","depth":"api"}}
{"id":"CityFurnJulianDataLine_how","input_data":"0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *","context":"","output":"## Purpose\n\nThese fixed form lines calculate the Julian date given a calendar date.\n\n## Parameters\n\n- Given variable `DATE` is the input with format 'MMDDYY'.\n- The global `JDATE6` is computed. It is a 6 byte field with\n  - byte 1   = century (1 for 1900s, 2 for 2000s)\n  - byte 2-3 = 2 digit year\n  - byte 4-6 = Julian number of days\n\n## Implementation\n\nThe first thing it does is split the input `DATE` into the\ntwo digit year `YEAR1`, the month `MO1` and day of month `DAY1`.  Note that the `MOVEL`\nopcode moves the most signicant (leftmost) digits into the receiving variable for as many digits as\nreceiver can hold.\n\n```rpgle\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n```\n\nIndicator 80 is turned on if the 2 digit year is divisible by 4, signifying a leap year\n\n```rpgle\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n```\n\nBy conditioning with indicator 80 the appropriate array of leap year or normal year\nis used. The number of days up to this month stored in the array entry associated with the\nmonth is added to the number of days in the current month in `DAY1` and stored in the `DAYS1`\n5 digit number as the number of days since the beginning of the year.\n\n```rpgle\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n```\n\nNote this depends on the compile time initialized arrays\n\n- NY = number of preceding days for each month\n- LY = same as MY but in case of a leap year\n\nThe 5 digit `JDATE` has the first digits assigned from the year and the last three digits\nassigned from the number of days into that year.\n\n```rpgle\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n```\n\nThe `SRCEN` subroutine is executed which computes the single digit for the century in\nthe global `YEAR3`.\n\n```rpgle\n     C                   EXSR      SRCEN\n```\n\nFinally the century is put into the first digit and the year and days of the year are\nmoved into the right 5 digits of `JDATE6` which the final variable calculated.\n\n```rpgle\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *\n0069 C                   MOVEL     YEAR3         JDATE6                                   *\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDataLine/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"line","depth":"how"}}
{"id":"CityFurnJulianDatePgm_sum","input_data":"0005 D NY              S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     NORMAL YEARS\n0006 D LY              S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     LEAP YEARS\n     C* parameters to program\n     C     *ENTRY        PLIST\n     C                   PARM                    PDATE             6 0          input\n     C                   PARM                    PJDATE            6 0          output\n\n0033 C                   MOVE      PDATE         DATE              6 0\n0034 C                   EXSR      SRCJUL\n0035 C                   MOVE      JDATE6        PJDATE           \n0036 C                   MOVE      '1'           *INLR\n0041 C****************************************************************\n0042 C*                                                              *\n0043 C* Routine to calculate a Julian Date from a `MMDDYY` date      *\n0044 C*                                                              *\n     C*   JULIAN DATE FORMAT:                                        *\n     C*       POS 1 - century 1 = 1900s, 2 = 2000s                   *\n     C*       POS 2-3 - two digit year                               *\n0045 C*       POS 4-6 - number of days in the current year           *\n0044 C*                                                              *\n0046 C*   Uses compile time arrays 'LY' abd 'NY' for days of the     *\n0047 C*   year before the indexed month for leap years vs normal yrs *\n0048 C*                                                              *\n0049 C* DATE TO BE CALCULATED FROM MUST BE PASSED TO THIS            *\n0050 C*  ROUTINE VIA A 6 BYTE FIELD NAMED 'DATE' WITH FORMAT 'MMDDYR'*\n0051 C*     THIS ROUTINE WILL RETURN A 6 BYTE FIELD NAMED 'JDATE'    *\n0052 C*                                                              *\n0053 C* OTHER FIELDS USED BY THIS ROUTINE ARE.                       *\n0054 C*   - DAY1 - DAYS1 - MODAY - MO1 - YEAR1 - X -                 *\n0055 C*                                                              *\n0056 C* INDICATORS USED BY THIS ROUTINE ARE.                         *\n0057 C*    - 80 -                                                    *\n0058 C*                                                              *\n0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *\n0069 C                   MOVEL     YEAR3         JDATE6                                   *\n0070 C                   ENDSR                                                            *\n0071 C*                                                              *\n0072 C****************************************************************\n     C*-------------------------------------------------------------------\nGDG  C*--    CALCULATE CENTURY FROM FIELD YEAR1                        ---\n0059 C     SRCen         BEGSR                                                            *\nGDG  C     YEAR1         COMP      40                                   8383              *\nGDG  C   83              MOVE      2             YRCEN             1 0                    *\nGDG  C   83              MOVE      20            YRSTR             2 0                    *\nGDG  C  N83              MOVE      1             YRCEN             1 0                    *\nGDG  C  N83              MOVE      19            YRSTR             2 0                    *\nGDG  C                   MOVE      YEAR1         YEAR3             3 0\nGDG  C                   MOVEL     YRCEN         YEAR3\nGDG  C                   SETOFF                                       83\nGDG  C                   ENDSR                                                            *\n     C****************************************************************\n**  COMPILE TIME ARRAY WITH NORMAL YEAR DATA\n000031059090120151181212243273304334\n**  COMPILE TIME DATA FOR LEAP YEARS\n000031060091121152182213244274305335","context":"","output":"This fixed form ILE RPG program calculates the Julian date given a 6 digit calendar date.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDatePgm/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"file","depth":"sum"}}
{"id":"CityFurnJulianDatePgm_api","input_data":"0005 D NY              S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     NORMAL YEARS\n0006 D LY              S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     LEAP YEARS\n     C* parameters to program\n     C     *ENTRY        PLIST\n     C                   PARM                    PDATE             6 0          input\n     C                   PARM                    PJDATE            6 0          output\n\n0033 C                   MOVE      PDATE         DATE              6 0\n0034 C                   EXSR      SRCJUL\n0035 C                   MOVE      JDATE6        PJDATE           \n0036 C                   MOVE      '1'           *INLR\n0041 C****************************************************************\n0042 C*                                                              *\n0043 C* Routine to calculate a Julian Date from a `MMDDYY` date      *\n0044 C*                                                              *\n     C*   JULIAN DATE FORMAT:                                        *\n     C*       POS 1 - century 1 = 1900s, 2 = 2000s                   *\n     C*       POS 2-3 - two digit year                               *\n0045 C*       POS 4-6 - number of days in the current year           *\n0044 C*                                                              *\n0046 C*   Uses compile time arrays 'LY' abd 'NY' for days of the     *\n0047 C*   year before the indexed month for leap years vs normal yrs *\n0048 C*                                                              *\n0049 C* DATE TO BE CALCULATED FROM MUST BE PASSED TO THIS            *\n0050 C*  ROUTINE VIA A 6 BYTE FIELD NAMED 'DATE' WITH FORMAT 'MMDDYR'*\n0051 C*     THIS ROUTINE WILL RETURN A 6 BYTE FIELD NAMED 'JDATE'    *\n0052 C*                                                              *\n0053 C* OTHER FIELDS USED BY THIS ROUTINE ARE.                       *\n0054 C*   - DAY1 - DAYS1 - MODAY - MO1 - YEAR1 - X -                 *\n0055 C*                                                              *\n0056 C* INDICATORS USED BY THIS ROUTINE ARE.                         *\n0057 C*    - 80 -                                                    *\n0058 C*                                                              *\n0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *\n0069 C                   MOVEL     YEAR3         JDATE6                                   *\n0070 C                   ENDSR                                                            *\n0071 C*                                                              *\n0072 C****************************************************************\n     C*-------------------------------------------------------------------\nGDG  C*--    CALCULATE CENTURY FROM FIELD YEAR1                        ---\n0059 C     SRCen         BEGSR                                                            *\nGDG  C     YEAR1         COMP      40                                   8383              *\nGDG  C   83              MOVE      2             YRCEN             1 0                    *\nGDG  C   83              MOVE      20            YRSTR             2 0                    *\nGDG  C  N83              MOVE      1             YRCEN             1 0                    *\nGDG  C  N83              MOVE      19            YRSTR             2 0                    *\nGDG  C                   MOVE      YEAR1         YEAR3             3 0\nGDG  C                   MOVEL     YRCEN         YEAR3\nGDG  C                   SETOFF                                       83\nGDG  C                   ENDSR                                                            *\n     C****************************************************************\n**  COMPILE TIME ARRAY WITH NORMAL YEAR DATA\n000031059090120151181212243273304334\n**  COMPILE TIME DATA FOR LEAP YEARS\n000031060091121152182213244274305335","context":"","output":"## Purpose\n\nThis fixed form ILE RPG program calculates the Julian date given a calendar date.\n\n## Parameters\n\nThe first parameter `PDATE` is the input with format 'MMDDYY'.\nThe second parameter `PJDATE` is the output. It is a 6 byte field with\n\n* byte 1   = century (1 for 1900s, 2 for 2000s)\n* byte 2-3 = 2 digit year\n* byte 4-6 = Julian number of days\n\n## Usage\n\nGet Julian value for Dec 1, 2039\n\n```rpgle\n**free\ndcl-pr julian extpgm;\n    pdate packed(6:0);\n    pjdate packed(6:0);\nend-pr;\n\ndcl-s date packed(6:0) inz(120139);\ndcl-s jdate packed(6:0);\njulian(date: jdate);\ndsply jdate;  //  DSPLY  239335\nreturn;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDatePgm/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"file","depth":"api"}}
{"id":"CityFurnJulianDatePgm_how","input_data":"0005 D NY              S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     NORMAL YEARS\n0006 D LY              S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     LEAP YEARS\n     C* parameters to program\n     C     *ENTRY        PLIST\n     C                   PARM                    PDATE             6 0          input\n     C                   PARM                    PJDATE            6 0          output\n\n0033 C                   MOVE      PDATE         DATE              6 0\n0034 C                   EXSR      SRCJUL\n0035 C                   MOVE      JDATE6        PJDATE           \n0036 C                   MOVE      '1'           *INLR\n0041 C****************************************************************\n0042 C*                                                              *\n0043 C* Routine to calculate a Julian Date from a `MMDDYY` date      *\n0044 C*                                                              *\n     C*   JULIAN DATE FORMAT:                                        *\n     C*       POS 1 - century 1 = 1900s, 2 = 2000s                   *\n     C*       POS 2-3 - two digit year                               *\n0045 C*       POS 4-6 - number of days in the current year           *\n0044 C*                                                              *\n0046 C*   Uses compile time arrays 'LY' abd 'NY' for days of the     *\n0047 C*   year before the indexed month for leap years vs normal yrs *\n0048 C*                                                              *\n0049 C* DATE TO BE CALCULATED FROM MUST BE PASSED TO THIS            *\n0050 C*  ROUTINE VIA A 6 BYTE FIELD NAMED 'DATE' WITH FORMAT 'MMDDYR'*\n0051 C*     THIS ROUTINE WILL RETURN A 6 BYTE FIELD NAMED 'JDATE'    *\n0052 C*                                                              *\n0053 C* OTHER FIELDS USED BY THIS ROUTINE ARE.                       *\n0054 C*   - DAY1 - DAYS1 - MODAY - MO1 - YEAR1 - X -                 *\n0055 C*                                                              *\n0056 C* INDICATORS USED BY THIS ROUTINE ARE.                         *\n0057 C*    - 80 -                                                    *\n0058 C*                                                              *\n0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *\n0069 C                   MOVEL     YEAR3         JDATE6                                   *\n0070 C                   ENDSR                                                            *\n0071 C*                                                              *\n0072 C****************************************************************\n     C*-------------------------------------------------------------------\nGDG  C*--    CALCULATE CENTURY FROM FIELD YEAR1                        ---\n0059 C     SRCen         BEGSR                                                            *\nGDG  C     YEAR1         COMP      40                                   8383              *\nGDG  C   83              MOVE      2             YRCEN             1 0                    *\nGDG  C   83              MOVE      20            YRSTR             2 0                    *\nGDG  C  N83              MOVE      1             YRCEN             1 0                    *\nGDG  C  N83              MOVE      19            YRSTR             2 0                    *\nGDG  C                   MOVE      YEAR1         YEAR3             3 0\nGDG  C                   MOVEL     YRCEN         YEAR3\nGDG  C                   SETOFF                                       83\nGDG  C                   ENDSR                                                            *\n     C****************************************************************\n**  COMPILE TIME ARRAY WITH NORMAL YEAR DATA\n000031059090120151181212243273304334\n**  COMPILE TIME DATA FOR LEAP YEARS\n000031060091121152182213244274305335","context":"","output":"## Purpose\n\nThis fixed form ILE RPG program calculates the Julian date given a calendar date.  \n\n## Parameters\n\nThe first parameter `PDATE` is the input with format 'MMDDYY'.\nThe second parameter `PJDATE` is the output. It is a 6 byte field with\n\n- byte 1   = century (1 for 1900s, 2 for 2000s)\n- byte 2-3 = 2 digit year\n- byte 4-6 = Julian number of days\n\n## Implementation\n\nDepends on the compile time initialized arrays\n\n- NY = number of preceding days for each month\n- LY = same as MY but in case of a leap year\n\n```rpgle\n0005 D NY              S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     NORMAL YEARS\n0006 D LY              S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     LEAP YEARS\n```\n\nThe arrays are defined at the top of the file with\n\n- `DIM(12)` - 12 entries each  of 3 digit numbers \n- `CTDATA` - that are initialized from the compile time data section  \n- `PERRCD(12)` - with 12 numbers to be read in on each line\n- `ASCEND` - assumed to be in ASCENDing order and can be efficiently indexed.\n\nThe data to initialize the arrays is found at the end of the source file in the special `**` sections.\n\n```rpgle\n**  COMPILE TIME ARRAY WITH NORMAL YEAR DATA\n000031059090120151181212243273304334\n**  COMPILE TIME DATA FOR LEAP YEARS\n000031060091121152182213244274305335 \n```\n\n```rpgle\n     C     *ENTRY        PLIST\n     C                   PARM                    PDATE             6 0          input\n     C                   PARM                    PJDATE            6 0          output\n```\n\nThis program can be called with 2 parameter passed by reference,\nboth of which are 6 digit packed decimal numbers\nwith 0 decimal digits.\n\nThe program consists of 4 lines that call a subroutine\n\n```rpgle\n0033 C                   MOVE      PDATE         DATE              6 0\n0034 C                   EXSR      SRCJUL\n0035 C                   MOVE      JDATE6        PJDATE           \n0036 C                   MOVE      '1'           *INLR\n```\n\nFirst the input parameter into the `DATE` global, defined here as PACKED(6:0) \nwhich is the input to the SRCJUL subroutine called on line 34.\nThen on line 35 the 'JDATE6' global which was computed by SRCJUL is moved\nto `PJDATE` which is the  output parameter of the program. \nBy turning on the \"Last Record\" indicator on line 36, the program is terminated.\n\nThe `SRCJUL` subroutine has the same effect as the overall program.  It takes a date \nin 'MMDDYY' format in the global `DATE` and computes a Julian value in the global\n`JDATE6`.\n\n```rpgle\n0059 C     SRCJUL        BEGSR                                                        \n```\n\nThe first thing it does is split the input `DATE` into the\ntwo digit year `YEAR1`, the month `MO1` and day of month `DAY1`.  Note that the `MOVEL`\nopcode moves the most signicant (leftmost) digits into the receiving variable for as\nmany digits as the receiver can hold.\n\n```rpgle\n0060 C                   MOVEL     DATE          MODAY             4 0   \n0061 C                   MOVE      DATE          YEAR1             2 0    \n0062 C                   MOVEL     MODAY         MO1               2 0      \n0063 C                   MOVE      MODAY         DAY1              2 0\n```\n\nIndicator 80 is turned on if the 2 digit year is divisible by 4, signifying a leap year\n\n```rpgle\n0064 C     YEAR1         DIV       4             X                 2 0\n0065 C                   MVR                     X                        80     LEAP YEAR*\n```\n\nBy conditioning with indicator 80 the appropriate array of leap year or normal year\nis used. The number of days up to this month stored in the array entry associated with the\nmonth is added to the number of days in the current month in `DAY1` and stored in the\n`DAYS1` 5 digit number as the number of days since the beginning of the year.\n\n```rpgle\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0 \n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1 \n```\n\nThe 5 digit `JDATE` has the first digits assigned from the year and the last three digits\nassigned from the number of days into that year.\n\n```rpgle\n0068 C                   MOVE      DAYS1         JDATE             5 0\n0069 C                   MOVEL     YEAR1         JDATE \n```\n\nThe `SRCEN` subroutine is executed which computes the single digit for the century in \nthe global `YEAR3`.\n\n```rpgle\n     C                   EXSR      SRCEN\n```\n\nFinally the century is put into the first digit and the year and days of the year are\nmoved into the right 5 digits of `JDATE6` which the output of the subroutine.\n\n```rpgle\n0068 C                   MOVE      DAYS1         JDATE6            6 0                \n0069 C                   MOVEL     YEAR3         JDATE6                           \n0070 C                   ENDSR                                  \n```\n\nThe subroutine `SRCen` calculates the century for a given 2 digit year and creates a 3 digit year with that prefix\nInput is a 2 digit year named `YEAR1`\nOutput is a 3 byte field named `YEAR3` with\n\n- byte 1   = century (1 for 1900s, 2 for 2000s)\n- byte 2-3 = 2 digit year\n\n```rpgle\n0059 C     SRCen         BEGSR                                                   \n```\n\nThe indicator 83 is turned on if the input global 2 digit `YEAR1` is less than or equal to 40.\n\n```rpgle\nGDG  C     YEAR1         COMP      40                                   8383\n```\n\nIf the year is <= 40 then `YRCEN` is assigned '2' and `YRSTR` is assigned '20',\notherwise `YRCEN` is assigned '1' and `YRSTR` is assigned '19'.  \nFinally `YEAR3` is composed of the 1 digit century followed by the 2 digit year\nIndicator 83 is reset to off before returning from the subroutine.\n\n```rpgle\nGDG  C   83              MOVE      2             YRCEN             1 0\nGDG  C   83              MOVE      20            YRSTR             2 0\nGDG  C  N83              MOVE      1             YRCEN             1 0\nGDG  C  N83              MOVE      19            YRSTR             2 0   \nGDG  C                   MOVE      YEAR1         YEAR3             3 0\nGDG  C                   MOVEL     YRCEN         YEAR3\nGDG  C                   SETOFF                                       83\nGDG  C                   ENDSR                       \n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDatePgm/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"file","depth":"how"}}
{"id":"CityFurnJulianDateSubr_sum","input_data":"0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *\n0069 C                   MOVEL     YEAR3         JDATE6                                   *\n0070 C                   ENDSR                                                            *","context":"","output":"This fixed form ILE RPG subroutine calculates the Julian date given a 6 digit calendar date.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDateSubr/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"subr","depth":"sum"}}
{"id":"CityFurnJulianDateSubr_api","input_data":"0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *\n0069 C                   MOVEL     YEAR3         JDATE6                                   *\n0070 C                   ENDSR                                                            *","context":"","output":"## Purpose\n\nThis fixed form ILE RPG subroutine `SRCJUL` calculates the Julian date given a calendar date.\n\n## Parameters\n\n- Input is a global `DATE` with format 'MMDDYY'.\n- Output is a 6 byte field named `JDATE6` with\n  - byte 1   = century (1 for 1900s, 2 for 2000s)\n  - byte 2-3 = 2 digit year\n  - byte 4-6 = Julian number of days\n\n## Dependencies\n\nCompile time initialized arrays\n\n- MY = number of preceding days for each month\n- LY = same as MY but in case of a leap year\n\n## Impacts\n\n### Indicators\n\n- 80 - turned on if the given year is a leap year else it is turned off\n- 83 - turned off by `SRCen` subroutine\n\n### Global Variables\n\n- MODAY - has MMDD of DATE\n- YEAR1 - has YY of DATE\n- MO1 - has MM of DATE\n- DAY1 - has DD of DATE\n- X - has result of YY/4\n- DAYS1 - has number of days since beginning of year til DATE\n- JDATE - has YYnnn where nnn is number of days since beginning of year\n- JDATE6 - has CYYnnn where C is 1 for 20th century or 2 for 21st century\n\n### Called Subroutines\n\n#### Subroutine `SRCen`\n\nCalculates the century for a given 2 digit year and\ncreates a 3 digit year with that prefix\n\n## Usage\n\nConvert `TDATE` to Julian `TJDATE`\n\n```rpgle\n     C                   MOVE      TDATE         DATE              6 0 \n     C                   EXSR      SRCJUL\n     C                   MOVE      JDATE6        TJDATE            6 0\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDateSubr/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"subr","depth":"api"}}
{"id":"CityFurnJulianDateSubr_how","input_data":"0059 C     SRCJUL        BEGSR                                                            *\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n     C                   EXSR      SRCEN\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *\n0069 C                   MOVEL     YEAR3         JDATE6                                   *\n0070 C                   ENDSR                                                            *","context":"","output":"## Purpose\n\nThis fixed form subroutine calculates the Julian date given a calendar date.\n\n## Parameters\n\n- The first parameter `DATE` is the input with format 'MMDDYY'.\n- The second parameter `JDATE6` is the output. It is a 6 byte field with \n  - byte 1   = century (1 for 1900s, 2 for 2000s)\n  - byte 2-3 = 2 digit year\n  - byte 4-6 = Julian number of days\n\n## Implementation\n\nThe `SRCJUL` subroutine has the same effect as the overall program.  It takes a date \nin 'MMDDYY' format in the global `DATE` and computes a Julian value in the global\n`JDATE6`.\n\n```rpgle\n0059 C     SRCJUL        BEGSR                                                            *\n```\n\nThe first thing it does is split the input `DATE` into the\ntwo digit year `YEAR1`, the month `MO1` and day of month `DAY1`.  Note that the `MOVEL`\nopcode moves the most signicant (leftmost) digits into the receiving variable for as many digits as\nreceiver can hold.\n\n```rpgle\n0060 C                   MOVEL     DATE          MODAY             4 0                    *\n0061 C                   MOVE      DATE          YEAR1             2 0                    *\n0062 C                   MOVEL     MODAY         MO1               2 0                    *\n0063 C                   MOVE      MODAY         DAY1              2 0                    *\n```\n\nIndicator 80 is turned on if the 2 digit year is divisible by 4, signifying a leap year\n\n```rpgle\n0064 C     YEAR1         DIV       4             X                 2 0                    *\n0065 C                   MVR                     X                        80     LEAP YEAR*\n```\n\nBy conditioning with indicator 80 the appropriate array of leap year or normal year\nis used. The number of days up to this month stored in the array entry associated with the\nmonth is added to the number of days in the current month in `DAY1` and stored in the `DAYS1`\n5 digit number as the number of days since the beginning of the year.\n\n```rpgle\n0066 C   80LY(MO1)       ADD       DAY1          DAYS1             5 0                    *\n0067 C  N80NY(MO1)       ADD       DAY1          DAYS1                                    *\n```\n\nNote this depends on the compile time initialized arrays\n\n- NY = number of preceding days for each month\n- LY = same as MY but in case of a leap year\n\nThe 5 digit `JDATE` has the first digits assigned from the year and the last three digits\nassigned from the number of days into that year.\n\n```rpgle\n0068 C                   MOVE      DAYS1         JDATE             5 0                    *\n0069 C                   MOVEL     YEAR1         JDATE                                    *\n```\n\nThe `SRCEN` subroutine is executed which computes the single digit for the century in \nthe global `YEAR3`.\n\n```rpgle\n     C                   EXSR      SRCEN\n```\n\nFinally the century is put into the first digit and the year and days of the year are\nmoved into the right 5 digits of `JDATE6` which the output of the subroutine.\n\n```rpgle\n0068 C                   MOVE      DAYS1         JDATE6            6 0                    *\n0069 C                   MOVEL     YEAR3         JDATE6                                   *\n0070 C                   ENDSR                                                            *\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/City%20Furniture/CityFurnJulianDateSubr/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"subr","depth":"how"}}
{"id":"SCUIFM_sum","input_data":"     A                                      DSPSIZ(27 132 *DS4)\n     A          R WINSFL                    SFL\n     A            INFOLINE     110   O  2 11\n     A            TIME            T  O  2  1\n     A  50                                  DSPATR(ND)\n     A                                      TIMFMT(*HMS)\n     A          R WINCTL                    CF03(03) CF12(12) CF22(22)\n     A                                      SFLCTL(WINSFL)\n     A  46                                  SFLDSPCTL\n     A  45                                  SFLDSP\n     A  47                                  SFLCLR\n     A  48                                  SFLEND\n     A  49                                  INVITE\n     A                                      SFLPAG(15)\n     A                                      SFLSIZ(16)\n     A                                      WINDOW(6 4 17 121 *NORSTCSR)\n     A                                      WDWTITLE((*TEXT &WINTITLE) (*COLOR +\n     A                                      WHT) (*DSPATR HI) *TOP *CENTER)\n     A                                      WDWTITLE((*TEXT 'F3=Exit  F12=Back -\n     A                                       F22=Export report') (*COLOR BLU) +\n     A                                      *BOTTOM)\n     A            WINTITLE     100   P\n     A            TOPRRN         4S 0H      SFLRCDNBR(CURSOR)\n     A          R WININFO                   WINDOW(7 39 8 50)\n     A                                      CF03(03) CF12(12)\n     A                                      WDWTITLE((*TEXT 'Information') +\n     A                                      (*COLOR WHT) (*DSPATR HI) *TOP +\n     A                                      *CENTER)\n     A N29                                  WDWTITLE((*TEXT 'F3=Exit  F12=Back-\n     A                                      ') *BOTTOM)\n     A  29                                  INVITE\n     A            SHORTINFO    300   B  2  1CNTFLD(50)\n     A                                      DSPATR(PR)\n     A                                      CHGINPDFT\n     A                                      WRDWRAP\n     A          R SCFMTDUMMY                ASSUME\n     A                                  1  2'Dummyformat'","context":"","output":"This is a display file containing four formats.\n- WINSFL\n    A subfile format containing the fields `INFOLINE` and `TIME`.\n- WINCTL\n    A subfile control format, controlling the `WINSFL` format. Accepted input keys are `F3` (exit), `F12` (back) and `F22` (export report). It allows a maximum of 15 entries on one page.\n- WININFO\n    A small overlay window used to display information. The information is stored in the field `SHORTINFO`.\n- SCFMTDUMMY\n    A dummy format used to circumvent some specific behaviors of display files.\n\nSummary\nThe display file is used to show information in tabular form inside a window. There also is a window for short information.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/H.%20Gautzsch%20Zentrale%20Dienste%20GmbH/SCUIFM/output/sum_output.md","task":"explain","difficulty":1,"language":"dspf","scope":"file","depth":"sum"}}
{"id":"SCUIFM_api","input_data":"     A                                      DSPSIZ(27 132 *DS4)\n     A          R WINSFL                    SFL\n     A            INFOLINE     110   O  2 11\n     A            TIME            T  O  2  1\n     A  50                                  DSPATR(ND)\n     A                                      TIMFMT(*HMS)\n     A          R WINCTL                    CF03(03) CF12(12) CF22(22)\n     A                                      SFLCTL(WINSFL)\n     A  46                                  SFLDSPCTL\n     A  45                                  SFLDSP\n     A  47                                  SFLCLR\n     A  48                                  SFLEND\n     A  49                                  INVITE\n     A                                      SFLPAG(15)\n     A                                      SFLSIZ(16)\n     A                                      WINDOW(6 4 17 121 *NORSTCSR)\n     A                                      WDWTITLE((*TEXT &WINTITLE) (*COLOR +\n     A                                      WHT) (*DSPATR HI) *TOP *CENTER)\n     A                                      WDWTITLE((*TEXT 'F3=Exit  F12=Back -\n     A                                       F22=Export report') (*COLOR BLU) +\n     A                                      *BOTTOM)\n     A            WINTITLE     100   P\n     A            TOPRRN         4S 0H      SFLRCDNBR(CURSOR)\n     A          R WININFO                   WINDOW(7 39 8 50)\n     A                                      CF03(03) CF12(12)\n     A                                      WDWTITLE((*TEXT 'Information') +\n     A                                      (*COLOR WHT) (*DSPATR HI) *TOP +\n     A                                      *CENTER)\n     A N29                                  WDWTITLE((*TEXT 'F3=Exit  F12=Back-\n     A                                      ') *BOTTOM)\n     A  29                                  INVITE\n     A            SHORTINFO    300   B  2  1CNTFLD(50)\n     A                                      DSPATR(PR)\n     A                                      CHGINPDFT\n     A                                      WRDWRAP\n     A          R SCFMTDUMMY                ASSUME\n     A                                  1  2'Dummyformat'","context":"","output":"This display file is used to show information in tabular form inside a window.\n\nThis is a display file containing four formats.\n\n- *WINSFL*\n    A subfile format containing the fields `INFOLINE` and `TIME`.\n- *WINCTL*\n    A windowed  subfile control format, controlling the `WINSFL` format. Accepted input keys are `F3` (exit), `F12` (back) and `F22` (export report). It allows a maximum of 15 entries on one page.\n- *WININFO*\n    A small overlay window used to display information. The information is stored in the field `SHORTINFO`.\n- *SCFMTDUMMY*\n    A dummy format containing the ASSUME keyword.  This record is not intended to be written.  Simply having a record with ASSSUME in the file, prevents the DSPF from clearing the screen with it is opened.  Withouth this format, if you have a format from one display file and then write a format from another display file, it will clear the screen.\n\nThe typical usage pattern is to populate the subfile using `WINSFL` and using EXFMT on `WINCTL` to show that list in a window.\n\n```rple\n**free\nDOW...\n  infoline = ...\n  time = ...\n  WRITE winsfl;\nENDDO\nEXFMT winctl;\n```\n\nAlternatively by populating the `SHORTINFO` field and EXFMT the `WININFO` record to display a window with that information.\n\n```rpgle\n**free\nshortline = ...\nEXFMT wininfo;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/H.%20Gautzsch%20Zentrale%20Dienste%20GmbH/SCUIFM/output/api_output.md","task":"explain","difficulty":1,"language":"dspf","scope":"file","depth":"api"}}
{"id":"SCUIFM_how","input_data":"     A                                      DSPSIZ(27 132 *DS4)\n     A          R WINSFL                    SFL\n     A            INFOLINE     110   O  2 11\n     A            TIME            T  O  2  1\n     A  50                                  DSPATR(ND)\n     A                                      TIMFMT(*HMS)\n     A          R WINCTL                    CF03(03) CF12(12) CF22(22)\n     A                                      SFLCTL(WINSFL)\n     A  46                                  SFLDSPCTL\n     A  45                                  SFLDSP\n     A  47                                  SFLCLR\n     A  48                                  SFLEND\n     A  49                                  INVITE\n     A                                      SFLPAG(15)\n     A                                      SFLSIZ(16)\n     A                                      WINDOW(6 4 17 121 *NORSTCSR)\n     A                                      WDWTITLE((*TEXT &WINTITLE) (*COLOR +\n     A                                      WHT) (*DSPATR HI) *TOP *CENTER)\n     A                                      WDWTITLE((*TEXT 'F3=Exit  F12=Back -\n     A                                       F22=Export report') (*COLOR BLU) +\n     A                                      *BOTTOM)\n     A            WINTITLE     100   P\n     A            TOPRRN         4S 0H      SFLRCDNBR(CURSOR)\n     A          R WININFO                   WINDOW(7 39 8 50)\n     A                                      CF03(03) CF12(12)\n     A                                      WDWTITLE((*TEXT 'Information') +\n     A                                      (*COLOR WHT) (*DSPATR HI) *TOP +\n     A                                      *CENTER)\n     A N29                                  WDWTITLE((*TEXT 'F3=Exit  F12=Back-\n     A                                      ') *BOTTOM)\n     A  29                                  INVITE\n     A            SHORTINFO    300   B  2  1CNTFLD(50)\n     A                                      DSPATR(PR)\n     A                                      CHGINPDFT\n     A                                      WRDWRAP\n     A          R SCFMTDUMMY                ASSUME\n     A                                  1  2'Dummyformat'","context":"","output":"This display file is used to show information in tabular form inside a window.\n\nThis is a display file containing four formats.\n\n- `WINSFL`\n    A subfile format containing the fields `INFOLINE` and `TIME`.  The `TIME ` field is in HH:MM:SS format.  If *IN50 is on the `TIME` field will be idden.\n- `WINCTL`\n    A windowed  subfile control format, controlling the `WINSFL` format. Accepted input keys are `F3` (exit), `F12` (back) and `F22` (export report). It allows a maximum of 15 entries on one page and the calling porgram will hand the Page up and Page down keys. \n\n    When the record is written the following inputs will influence behaviour.\n    Indicator:\n\n  - `45` - whether the related subfile `WINSFL` is visible\n  - `46` - whether this record is visible on the screen\n  - `47` - whether to clear the subfile to be empty\n  - `48` - indicate to the screen that this is the end of the subfile list\n  - `49` - do not clear and rebuild the screen\n\n    The `WINTITLE` field is a 100 character field that will show up as the title in highlighted in white and centers in the top of the window's border.\n    The `TOPRRN` 4 digit signed numeric will indicate the relative record number that the subfile list should be positioned to.\n\n    When the `WINCTL` record is read, the following indicators will be set:\n\n  - `03` - the F3 key was pressed indicating the user wants to exit the program\n  - `12` - the F12 key was pressed indicating the user wants to cancel\n  - `22` - the F22 key was pressed indicating the user wants to export a report\n\n- `WININFO`\n    A small overlay window used to display information.\n    When `WININFO` is written, th e following inputs will influence the behaviour ofthe record\n  - `29` if this indicator is on the screen will not be cleared. If the indicator is on, the the bottow window title will contain the function keys for the window\n  - `SHORTINFO` this 300 character field will be displayed in the window, wrapped in 50 character lines\n\n  When the `WININFO` is read the following indicators are set\n\n  - `03` - F3 was pressed indicating 'EXIT'\n  - `12` - F12 was pressed indicating 'CANCEL'\n\n- `SCFMTDUMMY`\n    A dummy format containing the ASSUME keyword.  This record is not intended to be written.  Simply having a record with ASSSUME in the file, prevents the DSPF from clearing the screen with it is opened.  Withouth this format, if you have a format from one display file and then write a format from another display file, it will clear the screen.\n\nThe typical usage pattern is to populate the subfile using `WINSFL` and using EXFMT on `WINCTL` to show that list in a window.\n\n```rple\n**free\nDOW...\n  infoline = ...\n  time = ...\n  WRITE winsfl;\nENDDO\nEXFMT winctl;\n```\n\nAlternatively by populating the `SHORTINFO` field and EXFMT the `WININFO` record to display a window with that information.\n\n```rpgle\n**free\nshortline = ...\nEXFMT wininfo;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/H.%20Gautzsch%20Zentrale%20Dienste%20GmbH/SCUIFM/output/how_output.md","task":"explain","difficulty":1,"language":"dspf","scope":"file","depth":"how"}}
{"id":"ADDDIV_sum","input_data":"     FEqthist   IF   E           K Disk\n     FDividend  O    E             Disk\n     C                   Dou       %EOF(Eqthist)\n     C                   Read      Eqthist\n     C                   If        %EOF(Eqthist)\n     C                   Leave\n     C                   Endif\n\n     C                   Eval      Itcust = Ehcust\n     C                   Eval      Itamt = Ehchkamt\n     C                   Write     INTERST1\n     C                   Enddo\n     C                   Eval      *INlr = *on","context":"adddiv.rpgle:\n     FEqthist   IF   E           K Disk\n     FDividend  O    E             Disk","output":"### Summary \nThe RPG program is designed to process records from the `Eqthist` file and write to the `INTERST1` record format in the `Dividend` file. It reads through the records in the `Eqthist` file, assigns values to the `INTERST1` record format, and writes the record to the `Dividend` file.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ADDDIV/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"program-cycle","depth":"sum"}}
{"id":"ADDDIV_api","input_data":"     FEqthist   IF   E           K Disk\n     FDividend  O    E             Disk\n     C                   Dou       %EOF(Eqthist)\n     C                   Read      Eqthist\n     C                   If        %EOF(Eqthist)\n     C                   Leave\n     C                   Endif\n\n     C                   Eval      Itcust = Ehcust\n     C                   Eval      Itamt = Ehchkamt\n     C                   Write     INTERST1\n     C                   Enddo\n     C                   Eval      *INlr = *on","context":"adddiv.rpgle:\n     FEqthist   IF   E           K Disk\n     FDividend  O    E             Disk","output":"### Purpose\nThe `adddiv` program processes records from the `Eqthist` file and writes to the `INTERST1` record format in the `Dividend` file. It reads through the records in the `Eqthist` file, assigns values to the `INTERST1` record format, and writes the record to the `Dividend` file.\n\n### Inputs\n#### Parameters\n- None\n\n#### Input Files\n- `Eqthist`\n  - Type: Physical File (PF)\n  - Access: Input and Keyed access\n  - Purpose: Contains records with customer numbers and check amounts.\n\n### Outputs\n#### Output Files\n- `Dividend`\n  - Type: Physical File (PF)\n  - Access: Output\n  - Purpose: Stores records with customer numbers and check amounts.\n\n### Dependencies\n- Physical Files: `Eqthist` and `Dividend` are physical files accessed for reading and writing records.\n\n### Limitations & Assumptions\n- The program assumes that the `Eqthist` file is not empty and contains valid records.\n- The program does not handle any errors or exceptions that may occur during file operations.\n\n### Outcomes\n- Successful Processing: The program reads records from the `Eqthist` file, assigns values to the `INTERST1` record format, and writes the record to the `Dividend` file.\n- End of File: The program exits the loop when the end of the `Eqthist` file is reached.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ADDDIV/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"program-cycle","depth":"api"}}
{"id":"ADDDIV_how","input_data":"     FEqthist   IF   E           K Disk\n     FDividend  O    E             Disk\n     C                   Dou       %EOF(Eqthist)\n     C                   Read      Eqthist\n     C                   If        %EOF(Eqthist)\n     C                   Leave\n     C                   Endif\n\n     C                   Eval      Itcust = Ehcust\n     C                   Eval      Itamt = Ehchkamt\n     C                   Write     INTERST1\n     C                   Enddo\n     C                   Eval      *INlr = *on","context":"adddiv.rpgle:\n     FEqthist   IF   E           K Disk\n     FDividend  O    E             Disk","output":"### 1. High-Level Purpose of the Program\n- The RPG program is designed to process records from the `Eqthist` file and write to the `INTERST1` record format in the `Dividend` file. It reads through the records in the `Eqthist` file, assigns values to the `INTERST1` record format, and writes the record to the `Dividend` file.\n\n### 2. File Specifications\n\nThese file specifications define how each file will be accessed and used within the program, ensuring that the necessary operations (input, update, add) can be performed on the files as required\n\n- `FEqthist IF E K Disk`\n  - File Type: Physical file `Eqthist` declared.\n  - Attributes:\n    - `I`: Input file, meaning the file can be read.\n    - `F`: Fully procedural file, meaning all I/O operations are manually controlled in the program.\n    - `E`: Externally described file, meaning the file's structure is defined outside the program.\n    - `K`: Keyed access, meaning the file is accessed using a key field.\n    - `Disk`: Indicates that this is a disk file used for storing data on disk.\n\n- `FDividend O E Disk`\n  - File Type: Physical file `Dividend` declared.\n  - Attributes:\n    - `O`: Output file, meaning the file can be written to.\n    - `E`: Externally described file, meaning the file's structure is defined outside the program.\n    - `Disk`: Indicates that this is a disk file used for storing data on disk.\n\n### 3. Main Line Code\n\n- `C Dou %EOF(Eqthist)`: Starts a loop that continues until the end of the `Eqthist` file is reached.\n- `C Read Eqthist`: Reads the next record from the `Eqthist` file.\n- `C If %EOF(Eqthist)`: Checks if the end of the file is reached.\n- `C Leave`: Exits the loop if the end of the file is reached.\n- `C Endif`: Ends the `If` block.\n- `C Eval Itcust = Ehcust`: Assigns the customer number from the `Eqthist` file to the `Itcust` variable.\n- `C Eval Itamt = Ehchkamt`: Assigns the check amount from the `Eqthist` file to the `Itamt` variable.\n- `C Write INTERST1`: Writes the `INTERST1` record to the `Dividend` file.\n- `C Enddo`: Ends the loop.\n- `C Eval *INlr = *on`: Sets the last record indicator (`*INlr`) to `*on`.\n\n### 4. Possible Problems with this Code\n- The program does not handle any errors or exceptions that may occur during file operations.\n\n### 5. Possible Improvements to this Code\n\n- Implement error handling to manage cases where file operations fail.\n- Add validation to ensure that the `Eqthist` file contains valid records before processing.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ADDDIV/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"program-cycle","depth":"how"}}
{"id":"COU301_sum","input_data":"     h nomain\n\n     Fcountry   IF   E           K DISK\n     Fcountr1   IF   E           K DISK\n     F                                     RENAME(fcoun   :REC52)\n     Fcou301d   CF   E             WORKSTN\n     F                                     INFDS(INFO)\n     F                                     SFILE(SFL01:RRN01)\n     F                                     indds(indds)\n     D INFO            DS\n     D  LRRN                 378    379B 0\n\n     D SltCountry      PR             2a\n     D COID                           2A\n\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  cf08                   8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatrri              34     34n\n     D  InvalidOpt            35     35n\n     D  OneSelect             36     36n\n     D  bydesc                40     40n\n     D  InvalidOptC           41     41n\n     D  NotAvail              42     42n\n     D  sflend                80     80n\n\n     D rrn01           s              5i 0\n\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d chkctl          c                   'chc'\n     d actctl          c                   'acc'\n     d act             c                   'act'\n\n\n      *=============================================\n     P sltcountry      B                   export\n     D sltcountry      PI                  like(coid      )\n     d pcod                                like(coid      )\n     D dft             S                   like(coid      )\n     D step01          S              3    inz(prp)\n     d in08            s               n\n     d sts01           s               n\n     D rrs01           s              5i 0\n     D teller          s              5i 0\n     D err01           s               n\n     D slt01           s               n\n     d keycod          s                    like(coid       )\n     d savcod          s                    like(coid       )\n     d pdes            s                    like(countr     )\n     d keydes          s                    like(countr     )\n     d savdes          s                    like(countr     )\n      /free\n       if not %open(cou301d   );\n         open cou301d    ;\n       endif;\n       keycod = pcod;\n       dft = pcod;\n       bydesc = *off;\n       dow step01 <> ' ';\n         select ;\n         when step01 = prp ;\n           exsr s01prp;\n         when step01 = lod ;\n           exsr s01lod;\n         when step01 = dsp ;\n           exsr s01dsp;\n         when step01 = key ;\n           exsr s01key;\n         when step01 = chk ;\n           exsr s01chk;\n         when step01 = act ;\n           exsr s01act ;\n         endsl;\n       enddo;\n       return dft;\n       //--- Clear Subfile  -----------------------------------------------------\n\n       begsr s01prp;\n         RRS01 = 0;\n         clear CTL01;\n         sflclr = *on;\n         sfldsp = *off;\n         sfldspctl = *off;\n         write CTL01;\n         sflclr = *off;\n         if not bydesc;\n           setll KEYCOD country   ;\n           read country;\n           sflend = %EOF;\n         else;\n           setll KEYDES countr1   ;\n           read countr1    ;\n           SflEnd = %EOF;\n         endif;\n         SAVCOD = coid  ;\n         SAVDES = countr;\n         Step01 = lod;\n       endsr;\n       //--- Load Subfile  -----------------------------------------------------\n       begsr S01lod;\n         RRN01 = RRS01;\n         RRB01 = RRS01 + 1;\n         TELLER = 0;\n         OPT01 = 0;\n         SflNxtChg = *OFF;\n         coid   = SAVCOD;\n         countr = SAVDES;\n         dow not sflend\n               and TELLER < 20;\n           RRN01 = RRN01 + 1;\n           TELLER = TELLER + 1;\n           write SFL01;\n           if not bydesc;\n             read country   ;\n           else;\n             read countr1   ;\n           endif;\n           SflEnd = %EOF;\n         enddo;\n         SAVCOD = coid  ;\n         SAVDES = countr;\n         RRS01 = RRN01;\n         Step01 = dsp;\n       endsr;\n       //--- Display Subfile  --------------------------------------------------\n       begsr S01dsp;\n         sfldsp = rrs01 > 0;\n         sfldspctl = *on;\n         write KEY01;\n         exfmt CTL01;\n         IN08 = CF08;\n         RRB01 = LRRN;\n         Step01 = key;\n       endsr;\n       //--- Command Keys  -----------------------------------------------------\n       begsr S01key;\n         select;\n         when exit;\n           step01 = ' ';\n         when cancel ;\n           Step01 = ' ';\n         when PageDown;\n           Step01 = lod;\n         other;\n           Step01 = chk;\n         endsl;\n       endsr;\n       //--- Check Subfile  ----------------------------------------------------\n       begsr S01chk;\n         // SET FLAG SELECTION MADE OFF\n         SLT01 = *OFF;\n         // SET FLAG OPTION  MADE OFF\n         STS01 = *OFF;\n         // SET FLAG ERROR   MADE OFF\n         ERR01 = *OFF;\n         Step01 = act;\n         readc(E) SFL01;\n         SflNxtChg = *ON;\n         dow not %error and not %eof;\n           select;\n           when OPT01 = 0;\n             // NO ERROR\n           when OPT01 <>1;\n             STS01 = *ON;\n             Step01 = dsp;\n             dspatrRi = *on;\n             InvalidOpt= *on;\n             if ERR01 = *OFF;\n               RRB01 = RRN01;\n               ERR01 = *ON;\n             endif;\n             //OPTION = 1 BUT SELECTION ALREADY MADE\n           when SLT01 = *ON;\n             Step01 = dsp;\n             dspatrRi = *on;\n             OneSelect = *on;\n             if ERR01 = *OFF;\n               RRB01 = RRN01;\n               ERR01 = *ON;\n             endif;\n           other;\n             //OPTION = 1\n             SLT01 = *ON;\n             STS01 = *ON;\n           endsl;\n           update SFL01;\n           dspatrRi = *off;\n           readc SFL01;\n         enddo;\n         select;\n         when OPTC1 <>8\n               and OPTC1 <>0;\n           InvalidOptC = *ON;\n           Step01 = dsp;\n         when SLT01 = *ON\n               and OPTC1 <>0;\n           NotAvail = *ON;\n           Step01 = dsp;\n         when STS01 = *ON\n               and IN08 = *ON;\n           Step01 = dsp;\n         endsl;\n       endsr;\n       //--- Write Subfile  ----------------------------------------------------\n       begsr S01act;\n         Step01 = dsp;\n         select;\n         when IN08 ;\n           Step01 = prp;\n           bydesc = not bydesc;\n           if bydesc;\n             clear KEYdes;\n           else;\n             clear KEYcod;\n           endif;\n         when OPTC1 = 8;\n           Step01 = prp;\n           if not bydesc;\n             KEYCOD = POSCOD;\n           else;\n             KEYDES = POSDES;\n           endif;\n         other;\n           readc(E) SFL01;\n           dow not %error and not %eof;\n             if OPT01 = 1;\n               return coid      ;\n             endif;\n             readc SFL01;\n           enddo;\n         endsl;\n       endsr;\n      /end-free\n\n     p sltcountry      e","context":"     A*%%TS  SD  20161025  135749  VTAQUIN     REL-V7R1M0  5770-WDS\n     A*%%EC\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      PRINT\n     A                                      ERRSFL\n     A                                      CA03(03)\n     A                                      CA12(12)\n     A          R DUMMY\n     A                                      KEEP\n     A                                      ASSUME\n     A                                      OVERLAY\n     A                                      PUTOVR\n     A            FLD001         1   O 23 79\n     A          R SFL01                     SFL\nCou301.rpgle:\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d chkctl          c                   'chc'\n     d actctl          c                   'acc'\n     d act             c                   'act'\n     Fcountry   IF   E           K DISK\n     Fcountr1   IF   E           K DISK\n     Fcou301d   CF   E             WORKSTN\n     D INFO            DS\n     D  LRRN                 378    379B 0\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  cf08                   8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatrri              34     34n\n     D  InvalidOpt            35     35n\n     D  OneSelect             36     36n\n     D  bydesc                40     40n\n     D  InvalidOptC           41     41n\n     D  NotAvail              42     42n\n     D  sflend                80     80n\n     D rrn01           s              5i 0","output":"This free-format calculations RPGLE module `COU301` is a *display file based selection* routine.\nit allows users to select a country from a list displayed in a subfile.\nIt supports sorting, navigation (Pagedown), validation of input options, and capturing a selected country code. \nIt returns the selected country code `COID` back to the calling program.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/COU301/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"sum"}}
{"id":"COU301_api","input_data":"     h nomain\n\n     Fcountry   IF   E           K DISK\n     Fcountr1   IF   E           K DISK\n     F                                     RENAME(fcoun   :REC52)\n     Fcou301d   CF   E             WORKSTN\n     F                                     INFDS(INFO)\n     F                                     SFILE(SFL01:RRN01)\n     F                                     indds(indds)\n     D INFO            DS\n     D  LRRN                 378    379B 0\n\n     D SltCountry      PR             2a\n     D COID                           2A\n\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  cf08                   8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatrri              34     34n\n     D  InvalidOpt            35     35n\n     D  OneSelect             36     36n\n     D  bydesc                40     40n\n     D  InvalidOptC           41     41n\n     D  NotAvail              42     42n\n     D  sflend                80     80n\n\n     D rrn01           s              5i 0\n\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d chkctl          c                   'chc'\n     d actctl          c                   'acc'\n     d act             c                   'act'\n\n\n      *=============================================\n     P sltcountry      B                   export\n     D sltcountry      PI                  like(coid      )\n     d pcod                                like(coid      )\n     D dft             S                   like(coid      )\n     D step01          S              3    inz(prp)\n     d in08            s               n\n     d sts01           s               n\n     D rrs01           s              5i 0\n     D teller          s              5i 0\n     D err01           s               n\n     D slt01           s               n\n     d keycod          s                    like(coid       )\n     d savcod          s                    like(coid       )\n     d pdes            s                    like(countr     )\n     d keydes          s                    like(countr     )\n     d savdes          s                    like(countr     )\n      /free\n       if not %open(cou301d   );\n         open cou301d    ;\n       endif;\n       keycod = pcod;\n       dft = pcod;\n       bydesc = *off;\n       dow step01 <> ' ';\n         select ;\n         when step01 = prp ;\n           exsr s01prp;\n         when step01 = lod ;\n           exsr s01lod;\n         when step01 = dsp ;\n           exsr s01dsp;\n         when step01 = key ;\n           exsr s01key;\n         when step01 = chk ;\n           exsr s01chk;\n         when step01 = act ;\n           exsr s01act ;\n         endsl;\n       enddo;\n       return dft;\n       //--- Clear Subfile  -----------------------------------------------------\n\n       begsr s01prp;\n         RRS01 = 0;\n         clear CTL01;\n         sflclr = *on;\n         sfldsp = *off;\n         sfldspctl = *off;\n         write CTL01;\n         sflclr = *off;\n         if not bydesc;\n           setll KEYCOD country   ;\n           read country;\n           sflend = %EOF;\n         else;\n           setll KEYDES countr1   ;\n           read countr1    ;\n           SflEnd = %EOF;\n         endif;\n         SAVCOD = coid  ;\n         SAVDES = countr;\n         Step01 = lod;\n       endsr;\n       //--- Load Subfile  -----------------------------------------------------\n       begsr S01lod;\n         RRN01 = RRS01;\n         RRB01 = RRS01 + 1;\n         TELLER = 0;\n         OPT01 = 0;\n         SflNxtChg = *OFF;\n         coid   = SAVCOD;\n         countr = SAVDES;\n         dow not sflend\n               and TELLER < 20;\n           RRN01 = RRN01 + 1;\n           TELLER = TELLER + 1;\n           write SFL01;\n           if not bydesc;\n             read country   ;\n           else;\n             read countr1   ;\n           endif;\n           SflEnd = %EOF;\n         enddo;\n         SAVCOD = coid  ;\n         SAVDES = countr;\n         RRS01 = RRN01;\n         Step01 = dsp;\n       endsr;\n       //--- Display Subfile  --------------------------------------------------\n       begsr S01dsp;\n         sfldsp = rrs01 > 0;\n         sfldspctl = *on;\n         write KEY01;\n         exfmt CTL01;\n         IN08 = CF08;\n         RRB01 = LRRN;\n         Step01 = key;\n       endsr;\n       //--- Command Keys  -----------------------------------------------------\n       begsr S01key;\n         select;\n         when exit;\n           step01 = ' ';\n         when cancel ;\n           Step01 = ' ';\n         when PageDown;\n           Step01 = lod;\n         other;\n           Step01 = chk;\n         endsl;\n       endsr;\n       //--- Check Subfile  ----------------------------------------------------\n       begsr S01chk;\n         // SET FLAG SELECTION MADE OFF\n         SLT01 = *OFF;\n         // SET FLAG OPTION  MADE OFF\n         STS01 = *OFF;\n         // SET FLAG ERROR   MADE OFF\n         ERR01 = *OFF;\n         Step01 = act;\n         readc(E) SFL01;\n         SflNxtChg = *ON;\n         dow not %error and not %eof;\n           select;\n           when OPT01 = 0;\n             // NO ERROR\n           when OPT01 <>1;\n             STS01 = *ON;\n             Step01 = dsp;\n             dspatrRi = *on;\n             InvalidOpt= *on;\n             if ERR01 = *OFF;\n               RRB01 = RRN01;\n               ERR01 = *ON;\n             endif;\n             //OPTION = 1 BUT SELECTION ALREADY MADE\n           when SLT01 = *ON;\n             Step01 = dsp;\n             dspatrRi = *on;\n             OneSelect = *on;\n             if ERR01 = *OFF;\n               RRB01 = RRN01;\n               ERR01 = *ON;\n             endif;\n           other;\n             //OPTION = 1\n             SLT01 = *ON;\n             STS01 = *ON;\n           endsl;\n           update SFL01;\n           dspatrRi = *off;\n           readc SFL01;\n         enddo;\n         select;\n         when OPTC1 <>8\n               and OPTC1 <>0;\n           InvalidOptC = *ON;\n           Step01 = dsp;\n         when SLT01 = *ON\n               and OPTC1 <>0;\n           NotAvail = *ON;\n           Step01 = dsp;\n         when STS01 = *ON\n               and IN08 = *ON;\n           Step01 = dsp;\n         endsl;\n       endsr;\n       //--- Write Subfile  ----------------------------------------------------\n       begsr S01act;\n         Step01 = dsp;\n         select;\n         when IN08 ;\n           Step01 = prp;\n           bydesc = not bydesc;\n           if bydesc;\n             clear KEYdes;\n           else;\n             clear KEYcod;\n           endif;\n         when OPTC1 = 8;\n           Step01 = prp;\n           if not bydesc;\n             KEYCOD = POSCOD;\n           else;\n             KEYDES = POSDES;\n           endif;\n         other;\n           readc(E) SFL01;\n           dow not %error and not %eof;\n             if OPT01 = 1;\n               return coid      ;\n             endif;\n             readc SFL01;\n           enddo;\n         endsl;\n       endsr;\n      /end-free\n\n     p sltcountry      e","context":"     A*%%TS  SD  20161025  135749  VTAQUIN     REL-V7R1M0  5770-WDS\n     A*%%EC\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      PRINT\n     A                                      ERRSFL\n     A                                      CA03(03)\n     A                                      CA12(12)\n     A          R DUMMY\n     A                                      KEEP\n     A                                      ASSUME\n     A                                      OVERLAY\n     A                                      PUTOVR\n     A            FLD001         1   O 23 79\n     A          R SFL01                     SFL\nCou301.rpgle:\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d chkctl          c                   'chc'\n     d actctl          c                   'acc'\n     d act             c                   'act'\n     Fcountry   IF   E           K DISK\n     Fcountr1   IF   E           K DISK\n     Fcou301d   CF   E             WORKSTN\n     D INFO            DS\n     D  LRRN                 378    379B 0\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  cf08                   8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatrri              34     34n\n     D  InvalidOpt            35     35n\n     D  OneSelect             36     36n\n     D  bydesc                40     40n\n     D  InvalidOptC           41     41n\n     D  NotAvail              42     42n\n     D  sflend                80     80n\n     D rrn01           s              5i 0","output":"## purpose \nThis RPGLE module `COU301` is a *record selection utility* that displays a list of countries in a subfile *(interactive screen)* and allows the user to select one. It manages:\n- Loading data into the subfile (from database files `country` and `countr1`).\n- Displaying the data to the user.\n- Handling user actions like scrolling, sorting *(via F8)*, or selecting a record from subfile screen.\n- Validating the user's input *(only one selection allowed)*\n- Returning the selected country code `COID` to the calling program.\n\n# Parameters\n`pcod` - Input parameter *country code* passed to procedure `sltcountry` \n\n## Dependencies \nBelow mentioned objects needs to be in the library list. \n- `country` - Database physical file keyed by Country code `coid` \n- `countr1` - Database logical file keyed by country name `countr`\n- `cou301d` - Display file with subfile support (used to interact with the user).\n\n## Main features\n- *Interactive subfile screen* with function key support\n- *Sorting toggle* (code vs. name order) using F8 function key\n- *Scroll and load more records* with PageDown key\n- *Input validation* to ensure only one valid selection\n- *Returns selected country code* back to caller\n\n## User interaction \n- User sees a list of countries in subfile screen.\n- Can scroll (PageDown), sort (F8), or pick one (option 1).\n- System validates selection  only one valid option allowed.\n- Upon successful selection, returns the selected `COID` (country code).\n\n## Usage example \nBelow is a sample calling program to invoke this function `SltCountry`. \n```rpgle\n        h dftactgrp(*no)\n          dcl-pr SltCountry char(2); // Declare external procedure\n           coid char(2);\n          end-pr;\n\n          dcl-s selectedCountry char(2);\n\n         selectedCountry = SltCountry('US'); // Call with default country code (e.g., 'US')\n\n        if selectedCountry <> *blanks;\n           // Do something with the selected country\n         dsply ('Selected Country: ' + selectedCountry);\n        else;\n          dsply ('No country was selected.');\n        endif;\n```rpgle","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/COU301/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"api"}}
{"id":"COU301_how","input_data":"     h nomain\n\n     Fcountry   IF   E           K DISK\n     Fcountr1   IF   E           K DISK\n     F                                     RENAME(fcoun   :REC52)\n     Fcou301d   CF   E             WORKSTN\n     F                                     INFDS(INFO)\n     F                                     SFILE(SFL01:RRN01)\n     F                                     indds(indds)\n     D INFO            DS\n     D  LRRN                 378    379B 0\n\n     D SltCountry      PR             2a\n     D COID                           2A\n\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  cf08                   8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatrri              34     34n\n     D  InvalidOpt            35     35n\n     D  OneSelect             36     36n\n     D  bydesc                40     40n\n     D  InvalidOptC           41     41n\n     D  NotAvail              42     42n\n     D  sflend                80     80n\n\n     D rrn01           s              5i 0\n\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d chkctl          c                   'chc'\n     d actctl          c                   'acc'\n     d act             c                   'act'\n\n\n      *=============================================\n     P sltcountry      B                   export\n     D sltcountry      PI                  like(coid      )\n     d pcod                                like(coid      )\n     D dft             S                   like(coid      )\n     D step01          S              3    inz(prp)\n     d in08            s               n\n     d sts01           s               n\n     D rrs01           s              5i 0\n     D teller          s              5i 0\n     D err01           s               n\n     D slt01           s               n\n     d keycod          s                    like(coid       )\n     d savcod          s                    like(coid       )\n     d pdes            s                    like(countr     )\n     d keydes          s                    like(countr     )\n     d savdes          s                    like(countr     )\n      /free\n       if not %open(cou301d   );\n         open cou301d    ;\n       endif;\n       keycod = pcod;\n       dft = pcod;\n       bydesc = *off;\n       dow step01 <> ' ';\n         select ;\n         when step01 = prp ;\n           exsr s01prp;\n         when step01 = lod ;\n           exsr s01lod;\n         when step01 = dsp ;\n           exsr s01dsp;\n         when step01 = key ;\n           exsr s01key;\n         when step01 = chk ;\n           exsr s01chk;\n         when step01 = act ;\n           exsr s01act ;\n         endsl;\n       enddo;\n       return dft;\n       //--- Clear Subfile  -----------------------------------------------------\n\n       begsr s01prp;\n         RRS01 = 0;\n         clear CTL01;\n         sflclr = *on;\n         sfldsp = *off;\n         sfldspctl = *off;\n         write CTL01;\n         sflclr = *off;\n         if not bydesc;\n           setll KEYCOD country   ;\n           read country;\n           sflend = %EOF;\n         else;\n           setll KEYDES countr1   ;\n           read countr1    ;\n           SflEnd = %EOF;\n         endif;\n         SAVCOD = coid  ;\n         SAVDES = countr;\n         Step01 = lod;\n       endsr;\n       //--- Load Subfile  -----------------------------------------------------\n       begsr S01lod;\n         RRN01 = RRS01;\n         RRB01 = RRS01 + 1;\n         TELLER = 0;\n         OPT01 = 0;\n         SflNxtChg = *OFF;\n         coid   = SAVCOD;\n         countr = SAVDES;\n         dow not sflend\n               and TELLER < 20;\n           RRN01 = RRN01 + 1;\n           TELLER = TELLER + 1;\n           write SFL01;\n           if not bydesc;\n             read country   ;\n           else;\n             read countr1   ;\n           endif;\n           SflEnd = %EOF;\n         enddo;\n         SAVCOD = coid  ;\n         SAVDES = countr;\n         RRS01 = RRN01;\n         Step01 = dsp;\n       endsr;\n       //--- Display Subfile  --------------------------------------------------\n       begsr S01dsp;\n         sfldsp = rrs01 > 0;\n         sfldspctl = *on;\n         write KEY01;\n         exfmt CTL01;\n         IN08 = CF08;\n         RRB01 = LRRN;\n         Step01 = key;\n       endsr;\n       //--- Command Keys  -----------------------------------------------------\n       begsr S01key;\n         select;\n         when exit;\n           step01 = ' ';\n         when cancel ;\n           Step01 = ' ';\n         when PageDown;\n           Step01 = lod;\n         other;\n           Step01 = chk;\n         endsl;\n       endsr;\n       //--- Check Subfile  ----------------------------------------------------\n       begsr S01chk;\n         // SET FLAG SELECTION MADE OFF\n         SLT01 = *OFF;\n         // SET FLAG OPTION  MADE OFF\n         STS01 = *OFF;\n         // SET FLAG ERROR   MADE OFF\n         ERR01 = *OFF;\n         Step01 = act;\n         readc(E) SFL01;\n         SflNxtChg = *ON;\n         dow not %error and not %eof;\n           select;\n           when OPT01 = 0;\n             // NO ERROR\n           when OPT01 <>1;\n             STS01 = *ON;\n             Step01 = dsp;\n             dspatrRi = *on;\n             InvalidOpt= *on;\n             if ERR01 = *OFF;\n               RRB01 = RRN01;\n               ERR01 = *ON;\n             endif;\n             //OPTION = 1 BUT SELECTION ALREADY MADE\n           when SLT01 = *ON;\n             Step01 = dsp;\n             dspatrRi = *on;\n             OneSelect = *on;\n             if ERR01 = *OFF;\n               RRB01 = RRN01;\n               ERR01 = *ON;\n             endif;\n           other;\n             //OPTION = 1\n             SLT01 = *ON;\n             STS01 = *ON;\n           endsl;\n           update SFL01;\n           dspatrRi = *off;\n           readc SFL01;\n         enddo;\n         select;\n         when OPTC1 <>8\n               and OPTC1 <>0;\n           InvalidOptC = *ON;\n           Step01 = dsp;\n         when SLT01 = *ON\n               and OPTC1 <>0;\n           NotAvail = *ON;\n           Step01 = dsp;\n         when STS01 = *ON\n               and IN08 = *ON;\n           Step01 = dsp;\n         endsl;\n       endsr;\n       //--- Write Subfile  ----------------------------------------------------\n       begsr S01act;\n         Step01 = dsp;\n         select;\n         when IN08 ;\n           Step01 = prp;\n           bydesc = not bydesc;\n           if bydesc;\n             clear KEYdes;\n           else;\n             clear KEYcod;\n           endif;\n         when OPTC1 = 8;\n           Step01 = prp;\n           if not bydesc;\n             KEYCOD = POSCOD;\n           else;\n             KEYDES = POSDES;\n           endif;\n         other;\n           readc(E) SFL01;\n           dow not %error and not %eof;\n             if OPT01 = 1;\n               return coid      ;\n             endif;\n             readc SFL01;\n           enddo;\n         endsl;\n       endsr;\n      /end-free\n\n     p sltcountry      e","context":"     A*%%TS  SD  20161025  135749  VTAQUIN     REL-V7R1M0  5770-WDS\n     A*%%EC\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      PRINT\n     A                                      ERRSFL\n     A                                      CA03(03)\n     A                                      CA12(12)\n     A          R DUMMY\n     A                                      KEEP\n     A                                      ASSUME\n     A                                      OVERLAY\n     A                                      PUTOVR\n     A            FLD001         1   O 23 79\n     A          R SFL01                     SFL\nCou301.rpgle:\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d chkctl          c                   'chc'\n     d actctl          c                   'acc'\n     d act             c                   'act'\n     Fcountry   IF   E           K DISK\n     Fcountr1   IF   E           K DISK\n     Fcou301d   CF   E             WORKSTN\n     D INFO            DS\n     D  LRRN                 378    379B 0\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  cf08                   8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatrri              34     34n\n     D  InvalidOpt            35     35n\n     D  OneSelect             36     36n\n     D  bydesc                40     40n\n     D  InvalidOptC           41     41n\n     D  NotAvail              42     42n\n     D  sflend                80     80n\n     D rrn01           s              5i 0","output":"This free-format calculations RPGLE module `COU301` is a *display file based selection* routine.\nit allows users to select a country from a list displayed in a subfile.\nIt supports sorting, navigation (Pagedown), validation of input options, and capturing a selected country code. \nIt returns the selected country code `COID` back to the calling program.\n\n1. Files and structures \n\n   *Files*\n- `country` and `countr1` - Database files indexed by country code and country name respectively.\nrenames the external record format `fcoun` to internal name `REC52`. Helps avoid conflicts or clarify code when two files share a record format.\n- `cou301d` - Display file with subfile support *(used to interact with the user)*.\n   Declares subfile `SFL01` with relative record number stored in variable `RRN01`.\n\n  *Data Structures*\n- `INFO` - Used to get the holds the last relative record number selected in the subfile  (`LRRN`) from the display file.\n    This is critical for knowing which line the user interacted with when pressing Enter or function keys.\n- `indds` - Contains indicators for function keys and control logic (like F3, F8, PageDown).\n\n    *Subfile*\n- Controlled using `SFL01`, `CTL01` record formats.\n\n2. It follows a *step-driven logic*, meaning the program runs in a loop and switches behavior based on the value of `step01`.\n- `step01` determines which phase of the logic to run.\n    It's a 3-character string that can have values like:\n- `prp` - Prepare the subfile\n- `lod` - Load records into subfile\n- `dsp` - Display subfile and wait for user input\n- `key` - Process function key or command\n- `chk` - Check the options entered in subfile\n- `act` - Act on user input (return selected value)\n\n3. `rrn01`, `rrs01`, and `teller`  *Record Handling*\n- `rrn01` is used with SFILE(SFL01:rrn01) to write to the correct line.\n- `rrs01` stores the last loaded RRN so you can page down.\n- `teller` is used to load up to 20 records per page.\n```rpgle\n        d rrn01       s   5i 0  // Current subfile record number (used to write to subfile)\n        d rrs01       s   5i 0  // Saved position after last subfile load\n        d teller      s   5i 0  // Counter to limit number of records loaded per page\n```\n4. Procedure `Sltcountry` \n- It Opens the display file if needed\n- Sets default values and sorting flag\n- Runs a loop `dow step01 <> ' '` to control the flow\n- Calls different subroutines based on `step01`\n\n5. Subroutine flow \n- `step01` = `prp`: Clear subfile and get ready to read\n- `step01` = `lod`: Load 20 records into subfile using rrn01, teller, and sflend\n- `step01` = `dsp`: Show the subfile and wait for input (exfmt)\n- `step01` = `key`: Process function keys like F3, F8, or Enter\n- `step01` = `chk`: Check subfile input  only allow 1 line with *Option = 1*\n- `step01` = `act`: If user selected valid line, return `coid`; otherwise, continue\n\n6. When the user selects a record:\nThe program exits and returns the selected country code to the calling program.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/COU301/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"how"}}
{"id":"LOG100_sum","input_data":"     h dftactgrp(*no)\n     fparameter if   e           k disk\n     f                                     infds(info)\n\n      /copy apicall\n\n     d info            ds\n     D  lib                   93    102\n\n     d                 ds                  based(p1)\n     d  pos                          10i 0\n     d  data                          3\n\n     d usrspc          s             20\n      /free\n        usrspc = 'SAMLOG    ' + Lib;\n        crtusrspc(usrspc:'LOG':5000:X'00':'*ALL':'Sample Application Log'\n                  :'*YES':errcod);\n        rtvusrspcptr(usrspc:p1);\n        pos = 7;\n        data = '***';\n        *inlr = *on;\n      /end-free","context":"log100.pgm.rpgle:\n     fparameter if   e           k disk\n     d info            ds\n     D  lib                   93    102\n     d                 ds                  based(p1)\n     d  pos                          10i 0\n     d  data                          3\n     d usrspc          s             20","output":"This ILE RPG program creates and manipulates a user space `SAMLOG` in the IBM i system. It uses the `crtusrspc` and `rtvusrspcptr` APIs to create the user space, retrieve a pointer to it, and write a predefined value `***` at a specific position (7).","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/LOG100/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"file","depth":"sum"}}
{"id":"LOG100_api","input_data":"     h dftactgrp(*no)\n     fparameter if   e           k disk\n     f                                     infds(info)\n\n      /copy apicall\n\n     d info            ds\n     D  lib                   93    102\n\n     d                 ds                  based(p1)\n     d  pos                          10i 0\n     d  data                          3\n\n     d usrspc          s             20\n      /free\n        usrspc = 'SAMLOG    ' + Lib;\n        crtusrspc(usrspc:'LOG':5000:X'00':'*ALL':'Sample Application Log'\n                  :'*YES':errcod);\n        rtvusrspcptr(usrspc:p1);\n        pos = 7;\n        data = '***';\n        *inlr = *on;\n      /end-free","context":"log100.pgm.rpgle:\n     fparameter if   e           k disk\n     d info            ds\n     D  lib                   93    102\n     d                 ds                  based(p1)\n     d  pos                          10i 0\n     d  data                          3\n     d usrspc          s             20","output":"#### 1. Purpose  \n  This ILE RPG program interacts with a user space `SAMLOG` in the IBM i system. It retrieves the library name from the file information data structure `info`, creates a user space if it does not exist, retrieves a pointer to the user space, and writes a predefined value `***` at a specific position (7). The program ensures proper error handling using an error code structure `errcod`.\n\n#### 2. Parameters\n  - None\n\n#### 3. Global Variables \n  Below mentioned global variables are used.  \n\n  | Variable Name | Data Type       | Length | Description                                                |\n  |---------------|------------------|--------|------------------------------------------------------------|\n  | `usrspc`      | Alphanumeric     | 20     | Stores the user space name in format `'SAMLOG   <LIB>'`    |\n  | `info`        | Data Structure   |        | File Information Data Structure (INFDS) used to get library name |\n  | `lib`         | Alphanumeric     | 10     | Extracted from `info`, holds the current library name      |\n  | `p1`          | Pointer          |        | Points to the memory location of the user space            |\n  | `pos`         | Integer (10,0)   | 10     | Target position in the user space to write data (e.g., 7)  |\n  | `data`        | Alphanumeric     | 3      | Holds the value `'***'` to be written into the user space  |\n  | `errcod`      | Data Structure   | 256    | Standard API error code structure for capturing errors     |\n\n#### 4. Dependencies\n  Below mentioned objects need to be in the library list:\n  - `apicall` \n    A copy member that contains the prototype definitions for the IBM i APIs used in this program, specifically `crtusrspc` (Create User Space) and `rtvusrspcptr` (Retrieve User Space Pointer).\n  - `parameter` \n    A physical file declared in the program. Although the file itself is not read directly, it is used to populate the file information data structure (`INFDS`) named `info`. This structure is used to retrieve the library name dynamically, which is then used when constructing the fully qualified user space name.\n\n#### 5. Database Interactions\n  - File used: `PARAMETER`\n  - Used only to retrieve the library name via the info structure (INFDS).\n  - No reads/writes performed on the file.\n\n#### 6. Explanation of APIs Used\n\n  #### 6.1 `crtusrspc`  Create User Space API  \n  - Purpose:  \n    Allocates and creates a user space object in the specified library. User spaces are used to store and share data across programs or sessions.\n\n  - Parameters:\n    | Parameter      | Description                                                                 |\n    |----------------|-----------------------------------------------------------------------------|\n    | `usrspc`       | Fully qualified user space name (`10-char name + 10-char library`).         |\n    | `spc_attr`     | Space attribute; typically `'LOG'` for logging or `'GENERIC'` for general use. |\n    | `spc_size`     | Size of the user space in bytes (e.g., `5000`).                             |\n    | `spc_init`     | Initial value to fill the space (`X'00'` for binary zeroes).                |\n    | `spc_aut`      | Public authority (e.g., `'*ALL'`).                                           |\n    | `spc_text`     | Descriptive text for the user space (e.g., `'Sample Application Log'`).     |\n    | `spc_replace`  | Replace user space if it exists (`'*YES'` or `'*NO'`).                       |\n    | `errcod`       | Error code data structure to capture API errors (structure must be passed). |\n\n  #### 6.2 `rtvusrspcptr`  Retrieve User Space Pointer API  \n  - Purpose:  \n    Retrieves a pointer to the memory location of a specified user space so it can be accessed or modified directly within the program.\n\n  - Parameters:\n    | Parameter  | Description                                                           |\n    |------------|-----------------------------------------------------------------------|\n    | `usrspc`   | Fully qualified user space name (same format as used in `crtusrspc`). |\n    | `ptr`      | Output parameter: returns the pointer to the user space memory.       |\n\n#### 7.  Impacts\n  \n  - Overwrites or creates the user space `SAMLOG` in the specified library.\n  - May impact other applications or users that rely on the same user space if it is overwritten.\n\n#### 8.  Error Handling\n  - The program handles API errors using the standard `errcod` data structure:\n  - Captures errors returned by system APIs (`crtusrspc`, `rtvusrspcptr`) using the `errcod` structure.\n  - Key fields include:\n    - `byte_provided`  size of the error structure.\n    - `byte_available`  actual size of the error information.\n    - `error_msgid`  error message ID returned by the API.\n    - `message_data`  additional details about the error.\n  - No retry or recovery mechanism is implemented; the program assumes successful execution of API calls.\n\n#### 9.  Limitations\n  The program has the following limitations:\n\n  - Assumes that the user space does not exist or that it can be safely replaced (`*YES` is hardcoded).\n  - No validation is performed to ensure that writing to position 7 is appropriate or safe in the context of the user space.\n\n#### 10. Usage Example\n  This program can be used in application logging or auditing to dynamically create a user space and mark a checkpoint.\n\n  #### Example Usage Scenario  \n    When a program step needs to mark a specific status or event (e.g., successful batch completion), this utility can be invoked to:\n    - Create or replace a user space named `SAMLOG`\n    - Write `***` at position 7\n    - Make the space ready for later retrieval or validation","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/LOG100/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"file","depth":"api"}}
{"id":"LOG100_how","input_data":"     h dftactgrp(*no)\n     fparameter if   e           k disk\n     f                                     infds(info)\n\n      /copy apicall\n\n     d info            ds\n     D  lib                   93    102\n\n     d                 ds                  based(p1)\n     d  pos                          10i 0\n     d  data                          3\n\n     d usrspc          s             20\n      /free\n        usrspc = 'SAMLOG    ' + Lib;\n        crtusrspc(usrspc:'LOG':5000:X'00':'*ALL':'Sample Application Log'\n                  :'*YES':errcod);\n        rtvusrspcptr(usrspc:p1);\n        pos = 7;\n        data = '***';\n        *inlr = *on;\n      /end-free","context":"log100.pgm.rpgle:\n     fparameter if   e           k disk\n     d info            ds\n     D  lib                   93    102\n     d                 ds                  based(p1)\n     d  pos                          10i 0\n     d  data                          3\n     d usrspc          s             20","output":"This ILE RPG program dynamically creates a user space `SAMLOG` in the IBM i system, writes a specific value `***` at a designated position within the space, and uses IBM APIs for user space manipulation. The program also retrieves the library name from a file INFDS and supports basic error tracking via a defined structure.\n\n#### 1. File Declarations\n\n   ```rpgle\n   fparameter if   e           k disk\n   f                                     infds(info)\n   ```\n   - Declares the file `parameter`, which is keyed and used only to access the file information data structure (`info`).\n   - The `infds(info)` keyword links the `info` data structure to extract metadata about the file (like the library name).\n\n#### 2. Include API Copybook\n\n   ```rpgle\n   /copy apicall\n   ```\n   - Includes the copy member `apicall`, which contains API prototypes for `crtusrspc` (Create User Space) and `rtvusrspcptr` (Retrieve User Space Pointer).\n   - Ensures external procedure declarations are recognized during compilation.\n\n#### 3. Define Data Structures\n\n   ```rpgle\n   d info            ds\n   D  lib                   93    102\n\n   d                 ds                  based(p1)\n   d  pos                          10i 0\n   d  data                          3\n   ```\n   - `info`: Used to retrieve the library name from the file's INFDS (positions 93102).\n   - A pointer-based data structure (based on `p1`) allows writing directly to the user space memory.\n   - `pos`: Holds the position within the user space to write data.\n   - `data`: Holds the string to be written to the space (`***`).\n\n#### 4. Define Variables\n\n   ```rpgle\n   d usrspc          s             20\n   ```\n   - `usrspc`: Holds the fully qualified user space name in the format `'SAMLOG   MYLIB'`.\n\n#### 5. Build User Space Name\n\n   ```rpgle\n   usrspc = 'SAMLOG    ' + Lib;\n   ```\n   - Concatenates `'SAMLOG    '` with the library name fetched from `info.lib`.\n   - Result: a fully qualified user space name, e.g., `SAMLOG   MYLIB`.\n\n#### 6. Create User Space\n\n   ```rpgle\n   crtusrspc(usrspc:'LOG':5000:X'00':'*ALL':'Sample Application Log': '*YES':errcod);\n   ```\n   - Calls the `crtusrspc` API to create a user space with:\n   - Size: 5000 bytes\n   - Initial Value: `X'00'`\n   - Authority: `*ALL`\n   - Description: `'Sample Application Log'`\n   - Replace Existing Space: `*YES`\n   - `errcod`: Error data structure used to capture any API call issues.\n\n#### 7. Retrieve User Space Pointer\n\n   ```rpgle\n   rtvusrspcptr(usrspc:p1);\n   ```\n   - Retrieves a memory pointer to the user space (`p1`) using the `rtvusrspcptr` API.\n   - This pointer allows direct memory manipulation of the user space.\n\n#### 8. Write Data to User Space\n\n   ```rpgle\n   pos = 7;\n   data = '***';\n   ```\n   - Sets the position to 7.\n   - Writes the value `'***'` at that memory position within the user space using the pointer-based structure.\n\n#### 9. End Program\n\n   ```rpgle\n   *inlr = *on;\n   ```\n   - Sets the LR (Last Record) indicator to `*ON`, signaling program termination and cleanup.\n\n#### 10. Program Execution Flow with Example\n\n#### 10.1 Example Code Snippet\n\n   ```rpgle for ILE RPG\n   // Assume that the 'parameter' file is in the library 'MYLIB'\n   // The file information data structure (info) will have the library name as 'MYLIB'\n\n   // Construct the user space name\n   usrspcName = 'SAMLOG   ' + 'MYLIB';\n\n   // Call the procedure to create and manipulate the user space\n   crtusrspc(usrspcName: 'LOG': 5000: X'00': '*ALL': 'Sample Application Log': '*YES': errcod);\n   rtvusrspcptr(usrspcName: p1);\n   ```\n#### 10.2 Execution Flow\n\n   - The program extracts the current library name `MYLIB` from the file information data structure `info.lib`.\n   - A user space name is constructed by appending the library to a base name `SAMLOG   MYLIB`\n   - The `crtusrspc` API is called to:\n   - Create a user space of size `5000` bytes\n   - Initialize the entire space with `X'00'`\n   - Grant `*ALL` authority**\n   - Replace existing user space if present `*YES`\n   - Add a description: `'Sample Application Log'`\n   - The `rtvusrspcptr` API retrieves a memory pointer `p1` to the user space for direct data manipulation.\n   - The program sets position to **7** and writes the string `'***'` to that position using the pointer-based data structure.\n\n#### 10.3  Expected Output\n\n   - A user space named `SAMLOG   MYLIB` is created (or replaced) in library `MYLIB`\n   - All 5000 bytes are initialized to `X'00'`\n   - The value `'***'` is written at position `7`\n   - The user space is now available for further logging, reading, or processing by other programs or tools","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/LOG100/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"file","depth":"how"}}
{"id":"ORD101_sum","input_data":"     h dftactgrp(*no) bnddir('SAMPLE')\n\n     forder1    uf   e           k disk\n     fdetord1   uf   e           k disk\n     ford101d   cf   e             workstn\n     F                                     indds(indds)\n     F                                     sfile(sfl01:rrn01)\n     F                                     Infds(Info)\n\n      /copy customer\n      /copy article\n      /copy vat\n\n     d  ord101         pr\n     d   id\n     d                                     like(orid)\n\n     d  ord101         pi\n     d   id\n     d                                     like(orid)\n\n     d Prtord          pr                  extpgm('ORD500')\n     d  x                                  like(orid)\n\n     D info            ds\n     D  lrrn                 378    379i 0\n\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  confirm                8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  change                27     27n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatr_ri             34     34n\n     D  sflmsg                35     35n\n     D  sflmsg2               36     36n\n     D  ErrQtyLiv             37     37n\n     D  ErrQty                38     38n\n     D  sflend                80     80n\n\n     D panel           S              3  0 INZ(1)\n     D step01          S              3    inz(prp)\n     D step02          S              3    inz(prp)\n     D rrn01           s              5i 0\n     D count           s              3  0\n     D err01           s               n\n\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d act             c                   'act'\n      /free\n        select;\n        when panel = 1;\n          exsr pnl01;\n        when panel = 2;\n          exsr pnl02;\n        other;\n          exsr pnl00;\n        endsl;\n        //- Subfiles  01 Subroutines --------------------------------------  ---\n        begsr pnl01;\n          select ;\n          when step01 = prp ;\n            exsr s01prp;\n          when step01 = lod ;\n            exsr s01lod;\n          when step01 = dsp ;\n            exsr s01dsp;\n          when step01 = key ;\n            exsr s01key;\n          when step01 = chk ;\n            exsr s01chk;\n          when step01 = act ;\n            exsr s01act ;\n          endsl;\n        endsr;\n        //--- Clear Subfile  ----------------------------------------------------\n        begsr s01prp;\n          RRn01 = 0;\n          sflclr = *on;\n          write ctl01;\n          sflclr = *off;\n          step01 = lod;\n          tot = 0;\n          totvat = 0;\n        endsr;\n        //--- Load Subfile  -----------------------------------------------------\n        begsr s01lod;\n          RRb01 = RRn01 + 1;\n          opt01 = 0;\n          setll id    detord1;\n          reade(n)  id detord1;\n          dow not %eof;\n            tot += odtot;\n            totvat += odtotvat;\n            RRN01 = RRN01 + 1;\n            artdesc = GetArtDesc(odarid);\n            write sfl01;\n            reade(n)  id detord1;\n          enddo;\n          sflend = *on;\n          step01 = dsp;\n        endsr;\n        //--- Display Subfile  --------------------------------------------------\n        begsr s01dsp;\n          sfldspctl = *on;\n          sfldsp = RRn01 > 0;\n\n          write key01;\n          exfmt ctl01;\n          if LRRN <>0;\n            RRb01 = LRRN;\n          endif;\n          step01 = key;\n        endsr;\n        //--- Command Keys  -----------------------------------------------------\n        begsr s01key;\n          select;\n          when exit;\n            panel  = 0;\n            step01 = prp;\n          when cancel;\n            step01 = prp;\n            panel  = panel  - 1;\n          when refresh;\n            step01 = prp;\n          other;\n            step01 = chk;\n          endsl;\n        endsr;\n        //--- Check Subfile  ----------------------------------------------------\n        begsr s01chk;\n          step01 = act;\n          err01 = *off;\n          sflnxtchg = *on;\n          readc(e) sfl01;\n          dow not %error and not %eof;\n            if opt01 <> 0 and opt01 <> 2 and opt01 <> 4 and opt01 <> 6;\n              step01 = dsp;\n              dspatr_ri = *on;\n              sflmsg = *on;\n              if not err01;\n                rrb01 = rrn01;\n                err01 = *on;\n              endif;\n            endif;\n            if opt01 =  4 and odqtyliv > 0 ;\n              step01 = dsp;\n              dspatr_ri = *on;\n              sflmsg2 = *on;\n              if not err01;\n                rrb01 = rrn01;\n                err01 = *on;\n              endif;\n            endif;\n            update sfl01;\n            dspatr_ri = *off;\n            readc(e) sfl01;\n          enddo;\n          sflnxtchg = *off;\n        endsr;\n        //--- action Subfile  ---------------------------------------------------\n        begsr s01act;\n          readc(e) sfl01;\n          select;\n          when %error or %eof;\n            step01 = dsp;\n          when opt01 = 2;\n             panel = 2;\n             step02 = prp;\n          when opt01 = 4;\n            tot -= odtot;\n            totvat -= odtotvat;\n            delete (id:odline) detord1;\n            opt01 = 0;\n            odarid = ' ';\n            odqty = 0;\n            odprice = 0;\n            odtot = 0;\n            artdesc = '**** Delete ***';\n            update sfl01;\n          endsl;\n        endsr;\n        //--- Format 02 Subroutines ------------------------------------     ---\n        begsr pnl02;\n          select ;\n          when step02 = prp ;\n            exsr s02prp;\n          when step02 = dsp ;\n            exsr s02dsp;\n          when step02 = key ;\n            exsr s02key;\n          when step02 = chk ;\n            exsr s02chk;\n          when step02 = act ;\n            exsr s02act ;\n          endsl;\n\n        endsr;\n        //--- clear & Load ------------------------------------------------------\n        begsr S02prp;\n          chain (id:odline) detord1;\n          dsqty = odqty;\n          dsqtyliv = odqtyliv;\n          dsprice = odprice;\n          artdesc = GetArtDesc(odarid);\n          vat = CLCVat(GetArtVatCode(odarid):odtot);\n          odtotvat = odtot + vat;\n          vatRate = GetVatRate(GetArtVatCode(odarid));\n          step02 = dsp;\n        endsr;\n        //--- Display  ----------------------------------------------------------\n        begsr S02dsp;\n          exfmt fmt02;\n          step02 = key;\n        endsr;\n        //--- command Keys  -----------------------------------------------------\n        begsr S02key;\n          select;\n          when exit;\n            panel  = 1;\n            step02 = prp;\n          when cancel;\n            step02 = prp;\n            panel  = panel  - 1;\n          other;\n            step02 = chk;\n          endsl;\n        endsr;\n        //--- check -------------------------------------------------------------\n        begsr S02chk;\n          step02 = act;\n          if dsqtyliv > odqty;\n            errqtyliv = *on;\n            step02 = dsp;\n          endif;\n          if dsqty < odqtyliv;\n            errqty = *on;\n            step02 = dsp;\n          endif;\n          odtot =  dsqty * dsprice;\n          vat = CLCVat(GetArtVatCode(odarid):odtot);\n          odtotvat = odtot + vat;\n        endsr;\n        //--- Action ------------------------------------------------------------\n        begsr S02act;\n          if change;\n            step02 = dsp;\n          else;\n            odqty = dsqty;\n            odqtyliv = dsqtyliv;\n            odprice = dsprice;\n            update fdeto;\n            opt01 = 0;\n            update sfl01;\n            step01 = dsp;\n            panel = 1;\n          endif;\n        endsr;\n        //--------INITIALIZATION ----------------------------------\n        begsr *inzsr;\n          chain id order1;\n          CUSTNAME = GetCusName(orcuid);\n\n        endsr;\n        //--------END SUBROUTINE ----------------------------------\n        begsr pnl00;\n          *inlr = *on;\n        endsr;\n      /end-free","context":"     A*%%TS  SD  20161201  111152  VTAQUIN     REL-V7R1M0  5770-WDS\n     A*%%EC\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      PRINT\n     A                                      INDARA\n     A                                      ERRSFL\n     A                                      CA03(03)\n     A                                      CA12(12)\n     A          R SFL01                     SFL\n     A*%%TS  SD  20161201  104932  VTAQUIN     REL-V7R1M0  5770-WDS\n     A  33                                  SFLNXTCHG\n     A            OPT01          2Y 0B  7  3\n     A  34                                  DSPATR(RI)\n     A  34                                  DSPATR(PC)\n     A                                      EDTCDE(Z)\n     A            ODLINE    R        O  7  6REFFLD(FDETO/ODLINE *LIBL/DETORD)\n     A            ODARID    R        O  7 12REFFLD(FDETO/ODARID *LIBL/DETORD)\n     A            ARTDESC       30A  O  7 19\n     A            ODQTY     R        O  7 50REFFLD(FDETO/ODQTY *LIBL/DETORD)\n     A                                      EDTCDE(Z)\n     A            ODTOT     R        O  7 66REFFLD(FDETO/ODTOT *LIBL/DETORD)\n     A            ODPRICE   R        O  7 56REFFLD(FDETO/ODPRICE *LIBL/DETORD)\n     A            ODQTYLIV  R        H      REFFLD(FDETO/ODQTYLIV *LIBL/DETORD)\n     A            ODTOTVAT  R        H      REFFLD(FDETO/ODTOTVAT *LIBL/DETORD)\n     A          R CTL01                     SFLCTL(SFL01)\nord101.pgm.rpgle:\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d act             c                   'act'\n     forder1    uf   e           k disk\n     fdetord1   uf   e           k disk\n     ford101d   cf   e             workstn\n     D info            ds\n     D  lrrn                 378    379i 0\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  confirm                8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  change                27     27n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatr_ri             34     34n\n     D  sflmsg                35     35n\n     D  sflmsg2               36     36n\n     D  ErrQtyLiv             37     37n\n     D  ErrQty                38     38n\n     D  sflend                80     80n\n     D panel           S              3  0 INZ(1)\n     D step01          S              3    inz(prp)\n     D step02          S              3    inz(prp)\n     D rrn01           s              5i 0\n     D count           s              3  0\n     D err01           s               n","output":"#### Summary\nThis ILE RPG program `ord101` manages customer orders through a subfile screen. It takes an order ID as an input parameter to retrieve and display related order details. The program interacts with multiple files including `order1` and `detord1`, and integrates with external procedures to fetch customer, article, and VAT-related information. It allows users to view, edit, delete, and refresh order details interactively using subfile screen operations.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ORD101/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"sum"}}
{"id":"ORD101_api","input_data":"     h dftactgrp(*no) bnddir('SAMPLE')\n\n     forder1    uf   e           k disk\n     fdetord1   uf   e           k disk\n     ford101d   cf   e             workstn\n     F                                     indds(indds)\n     F                                     sfile(sfl01:rrn01)\n     F                                     Infds(Info)\n\n      /copy customer\n      /copy article\n      /copy vat\n\n     d  ord101         pr\n     d   id\n     d                                     like(orid)\n\n     d  ord101         pi\n     d   id\n     d                                     like(orid)\n\n     d Prtord          pr                  extpgm('ORD500')\n     d  x                                  like(orid)\n\n     D info            ds\n     D  lrrn                 378    379i 0\n\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  confirm                8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  change                27     27n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatr_ri             34     34n\n     D  sflmsg                35     35n\n     D  sflmsg2               36     36n\n     D  ErrQtyLiv             37     37n\n     D  ErrQty                38     38n\n     D  sflend                80     80n\n\n     D panel           S              3  0 INZ(1)\n     D step01          S              3    inz(prp)\n     D step02          S              3    inz(prp)\n     D rrn01           s              5i 0\n     D count           s              3  0\n     D err01           s               n\n\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d act             c                   'act'\n      /free\n        select;\n        when panel = 1;\n          exsr pnl01;\n        when panel = 2;\n          exsr pnl02;\n        other;\n          exsr pnl00;\n        endsl;\n        //- Subfiles  01 Subroutines --------------------------------------  ---\n        begsr pnl01;\n          select ;\n          when step01 = prp ;\n            exsr s01prp;\n          when step01 = lod ;\n            exsr s01lod;\n          when step01 = dsp ;\n            exsr s01dsp;\n          when step01 = key ;\n            exsr s01key;\n          when step01 = chk ;\n            exsr s01chk;\n          when step01 = act ;\n            exsr s01act ;\n          endsl;\n        endsr;\n        //--- Clear Subfile  ----------------------------------------------------\n        begsr s01prp;\n          RRn01 = 0;\n          sflclr = *on;\n          write ctl01;\n          sflclr = *off;\n          step01 = lod;\n          tot = 0;\n          totvat = 0;\n        endsr;\n        //--- Load Subfile  -----------------------------------------------------\n        begsr s01lod;\n          RRb01 = RRn01 + 1;\n          opt01 = 0;\n          setll id    detord1;\n          reade(n)  id detord1;\n          dow not %eof;\n            tot += odtot;\n            totvat += odtotvat;\n            RRN01 = RRN01 + 1;\n            artdesc = GetArtDesc(odarid);\n            write sfl01;\n            reade(n)  id detord1;\n          enddo;\n          sflend = *on;\n          step01 = dsp;\n        endsr;\n        //--- Display Subfile  --------------------------------------------------\n        begsr s01dsp;\n          sfldspctl = *on;\n          sfldsp = RRn01 > 0;\n\n          write key01;\n          exfmt ctl01;\n          if LRRN <>0;\n            RRb01 = LRRN;\n          endif;\n          step01 = key;\n        endsr;\n        //--- Command Keys  -----------------------------------------------------\n        begsr s01key;\n          select;\n          when exit;\n            panel  = 0;\n            step01 = prp;\n          when cancel;\n            step01 = prp;\n            panel  = panel  - 1;\n          when refresh;\n            step01 = prp;\n          other;\n            step01 = chk;\n          endsl;\n        endsr;\n        //--- Check Subfile  ----------------------------------------------------\n        begsr s01chk;\n          step01 = act;\n          err01 = *off;\n          sflnxtchg = *on;\n          readc(e) sfl01;\n          dow not %error and not %eof;\n            if opt01 <> 0 and opt01 <> 2 and opt01 <> 4 and opt01 <> 6;\n              step01 = dsp;\n              dspatr_ri = *on;\n              sflmsg = *on;\n              if not err01;\n                rrb01 = rrn01;\n                err01 = *on;\n              endif;\n            endif;\n            if opt01 =  4 and odqtyliv > 0 ;\n              step01 = dsp;\n              dspatr_ri = *on;\n              sflmsg2 = *on;\n              if not err01;\n                rrb01 = rrn01;\n                err01 = *on;\n              endif;\n            endif;\n            update sfl01;\n            dspatr_ri = *off;\n            readc(e) sfl01;\n          enddo;\n          sflnxtchg = *off;\n        endsr;\n        //--- action Subfile  ---------------------------------------------------\n        begsr s01act;\n          readc(e) sfl01;\n          select;\n          when %error or %eof;\n            step01 = dsp;\n          when opt01 = 2;\n             panel = 2;\n             step02 = prp;\n          when opt01 = 4;\n            tot -= odtot;\n            totvat -= odtotvat;\n            delete (id:odline) detord1;\n            opt01 = 0;\n            odarid = ' ';\n            odqty = 0;\n            odprice = 0;\n            odtot = 0;\n            artdesc = '**** Delete ***';\n            update sfl01;\n          endsl;\n        endsr;\n        //--- Format 02 Subroutines ------------------------------------     ---\n        begsr pnl02;\n          select ;\n          when step02 = prp ;\n            exsr s02prp;\n          when step02 = dsp ;\n            exsr s02dsp;\n          when step02 = key ;\n            exsr s02key;\n          when step02 = chk ;\n            exsr s02chk;\n          when step02 = act ;\n            exsr s02act ;\n          endsl;\n\n        endsr;\n        //--- clear & Load ------------------------------------------------------\n        begsr S02prp;\n          chain (id:odline) detord1;\n          dsqty = odqty;\n          dsqtyliv = odqtyliv;\n          dsprice = odprice;\n          artdesc = GetArtDesc(odarid);\n          vat = CLCVat(GetArtVatCode(odarid):odtot);\n          odtotvat = odtot + vat;\n          vatRate = GetVatRate(GetArtVatCode(odarid));\n          step02 = dsp;\n        endsr;\n        //--- Display  ----------------------------------------------------------\n        begsr S02dsp;\n          exfmt fmt02;\n          step02 = key;\n        endsr;\n        //--- command Keys  -----------------------------------------------------\n        begsr S02key;\n          select;\n          when exit;\n            panel  = 1;\n            step02 = prp;\n          when cancel;\n            step02 = prp;\n            panel  = panel  - 1;\n          other;\n            step02 = chk;\n          endsl;\n        endsr;\n        //--- check -------------------------------------------------------------\n        begsr S02chk;\n          step02 = act;\n          if dsqtyliv > odqty;\n            errqtyliv = *on;\n            step02 = dsp;\n          endif;\n          if dsqty < odqtyliv;\n            errqty = *on;\n            step02 = dsp;\n          endif;\n          odtot =  dsqty * dsprice;\n          vat = CLCVat(GetArtVatCode(odarid):odtot);\n          odtotvat = odtot + vat;\n        endsr;\n        //--- Action ------------------------------------------------------------\n        begsr S02act;\n          if change;\n            step02 = dsp;\n          else;\n            odqty = dsqty;\n            odqtyliv = dsqtyliv;\n            odprice = dsprice;\n            update fdeto;\n            opt01 = 0;\n            update sfl01;\n            step01 = dsp;\n            panel = 1;\n          endif;\n        endsr;\n        //--------INITIALIZATION ----------------------------------\n        begsr *inzsr;\n          chain id order1;\n          CUSTNAME = GetCusName(orcuid);\n\n        endsr;\n        //--------END SUBROUTINE ----------------------------------\n        begsr pnl00;\n          *inlr = *on;\n        endsr;\n      /end-free","context":"     A*%%TS  SD  20161201  111152  VTAQUIN     REL-V7R1M0  5770-WDS\n     A*%%EC\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      PRINT\n     A                                      INDARA\n     A                                      ERRSFL\n     A                                      CA03(03)\n     A                                      CA12(12)\n     A          R SFL01                     SFL\n     A*%%TS  SD  20161201  104932  VTAQUIN     REL-V7R1M0  5770-WDS\n     A  33                                  SFLNXTCHG\n     A            OPT01          2Y 0B  7  3\n     A  34                                  DSPATR(RI)\n     A  34                                  DSPATR(PC)\n     A                                      EDTCDE(Z)\n     A            ODLINE    R        O  7  6REFFLD(FDETO/ODLINE *LIBL/DETORD)\n     A            ODARID    R        O  7 12REFFLD(FDETO/ODARID *LIBL/DETORD)\n     A            ARTDESC       30A  O  7 19\n     A            ODQTY     R        O  7 50REFFLD(FDETO/ODQTY *LIBL/DETORD)\n     A                                      EDTCDE(Z)\n     A            ODTOT     R        O  7 66REFFLD(FDETO/ODTOT *LIBL/DETORD)\n     A            ODPRICE   R        O  7 56REFFLD(FDETO/ODPRICE *LIBL/DETORD)\n     A            ODQTYLIV  R        H      REFFLD(FDETO/ODQTYLIV *LIBL/DETORD)\n     A            ODTOTVAT  R        H      REFFLD(FDETO/ODTOTVAT *LIBL/DETORD)\n     A          R CTL01                     SFLCTL(SFL01)\nord101.pgm.rpgle:\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d act             c                   'act'\n     forder1    uf   e           k disk\n     fdetord1   uf   e           k disk\n     ford101d   cf   e             workstn\n     D info            ds\n     D  lrrn                 378    379i 0\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  confirm                8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  change                27     27n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatr_ri             34     34n\n     D  sflmsg                35     35n\n     D  sflmsg2               36     36n\n     D  ErrQtyLiv             37     37n\n     D  ErrQty                38     38n\n     D  sflend                80     80n\n     D panel           S              3  0 INZ(1)\n     D step01          S              3    inz(prp)\n     D step02          S              3    inz(prp)\n     D rrn01           s              5i 0\n     D count           s              3  0\n     D err01           s               n","output":"#### 1. Purpose  \n   This ILE RPG program `ord101` is designed to manage customer orders using subfile screens. It interacts with multiple files such as `order1`, `detord1`, and `ord101d` and uses various subroutines to handle operations such as preparing, loading, displaying, and processing subfiles. The program integrates with external procedures to retrieve customer, article, and VAT-related information. It provides an interactive interface for users to view, edit, delete, and refresh order details.\n\n#### 2. Parameters\n   1. `id`: Passed to the program as a input parameter to identify the specific order being processed.\n\n#### 3. Subfile Screen Inputs\n\n   1. Options `opt01`:  \n      User-entered options on the subfile screen to perform actions such as Edit (2), Delete (4), or Refresh (5) on individual order lines.\n\n#### 4. Subfile Screen Outputs\n\n   1. Subfile Screen `ord101d`:  \n      Displays a list of order line items including item number, description, order quantity, delivery quantity, price, line total, and VAT.\n\n   2. Computed Totals `tot`, `totvat`:  \n      - `tot`: Total order amount (sum of line totals).  \n      - `totvat`: Total VAT amount for the order.\n\n   3. Updated Physical Files:  \n      - `detord1`: Updated with changes to individual order lines (e.g., edited quantities or deleted lines).  \n      - `order1`: Updated with new totals `tot`, `totvat` after subfile actions are completed.\n\n#### 5. Dependencies  \n\n   1. `order1` - Logical file for the `ORDER` physical file.\n   2. `detord1` - Logical file for the `DETORD` physical file.\n   3. `ord101d` - Display file for managing subfiles.\n   4. `samref` - Field reference file used by order.pf and detord.pf.\n   5. `sammsgf` - Message file used for error messages in the display file.\n   6. `vatdef` - File used for VAT rate and related information.\n\n#### 6. Side Effects and Limitations\n\n#### 7.1. Side Effects: \n   - If multiple users access the same order simultaneously, data inconsistencies may occur due to the lack of record locking.\n   - Errors in external procedures like `GetArtDesc`, `CLCVat`, or `GetCusName` may propagate to the program without proper handling, leading to incorrect or incomplete data.\n\n#### 7.2. Limitations:\n   - The program validates some inputs (e.g., delivered quantity vs. ordered quantity) but does not handle all edge cases, such as negative quantities or invalid VAT codes.\n   - The program does not log user actions or errors, making it difficult to trace issues or audit changes.\n\n#### 8. Expected Output\n\n   #### 8.1. Screen Displayed:\n   - The program displays a **subfile screen** `ord101d` that shows order line details retrieved from the `detord1` file based on the input order ID.\n   - Two main formats (panels) are used:\n   - Panel 1 (Subfile screen): Lists all order lines with options to delete or update.\n   - Panel 2 (Line update screen): Allows editing of a specific order line.\n\n   #### 8.2. Example Subfile Screen Content:\n   When an order is selected:\n   - The screen shows a list of articles ordered:\n   - Article description (`artdesc`)\n   - Ordered quantity (`odqty`)\n   - Delivered quantity (`odqtyliv`)\n   - Unit price (`odprice`)\n   - Line total (`odtot`)\n   - VAT amount (`vat`)\n   - Total with VAT (`odtotvat`)\n   - Totals (`tot`, `totvat`) are calculated and displayed at the bottom.\n   - Users can perform actions by entering options:\n   - 2 = Update line\n   - 4 = Delete line\n\n   #### 8.3. Screen Behavior:\n   - F5 (Refresh): Clears and reloads the subfile.\n   - F12 (Cancel): Exits the screen or returns to the previous panel.\n   - F3 (Exit): Ends the program.\n   - Option Validation:\n   - Invalid options trigger reverse image and error messages (`sflmsg`, `sflmsg2`).\n   - Validations check that delivered quantity does not exceed ordered quantity.\n\n   #### 8.4. Final Output Summary:\n   - The subfile screen*is updated in real time:\n   - If a line is deleted, it's removed and totals are adjusted.\n   - If a line is updated, changes are validated and saved.\n   - Upon completion, the screen reflects the latest state of the order, with:\n   - Updated quantities and prices\n   - Accurate totals and VAT\n   - Clean layout with messages shown only when needed","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ORD101/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"api"}}
{"id":"ORD101_how","input_data":"     h dftactgrp(*no) bnddir('SAMPLE')\n\n     forder1    uf   e           k disk\n     fdetord1   uf   e           k disk\n     ford101d   cf   e             workstn\n     F                                     indds(indds)\n     F                                     sfile(sfl01:rrn01)\n     F                                     Infds(Info)\n\n      /copy customer\n      /copy article\n      /copy vat\n\n     d  ord101         pr\n     d   id\n     d                                     like(orid)\n\n     d  ord101         pi\n     d   id\n     d                                     like(orid)\n\n     d Prtord          pr                  extpgm('ORD500')\n     d  x                                  like(orid)\n\n     D info            ds\n     D  lrrn                 378    379i 0\n\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  confirm                8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  change                27     27n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatr_ri             34     34n\n     D  sflmsg                35     35n\n     D  sflmsg2               36     36n\n     D  ErrQtyLiv             37     37n\n     D  ErrQty                38     38n\n     D  sflend                80     80n\n\n     D panel           S              3  0 INZ(1)\n     D step01          S              3    inz(prp)\n     D step02          S              3    inz(prp)\n     D rrn01           s              5i 0\n     D count           s              3  0\n     D err01           s               n\n\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d act             c                   'act'\n      /free\n        select;\n        when panel = 1;\n          exsr pnl01;\n        when panel = 2;\n          exsr pnl02;\n        other;\n          exsr pnl00;\n        endsl;\n        //- Subfiles  01 Subroutines --------------------------------------  ---\n        begsr pnl01;\n          select ;\n          when step01 = prp ;\n            exsr s01prp;\n          when step01 = lod ;\n            exsr s01lod;\n          when step01 = dsp ;\n            exsr s01dsp;\n          when step01 = key ;\n            exsr s01key;\n          when step01 = chk ;\n            exsr s01chk;\n          when step01 = act ;\n            exsr s01act ;\n          endsl;\n        endsr;\n        //--- Clear Subfile  ----------------------------------------------------\n        begsr s01prp;\n          RRn01 = 0;\n          sflclr = *on;\n          write ctl01;\n          sflclr = *off;\n          step01 = lod;\n          tot = 0;\n          totvat = 0;\n        endsr;\n        //--- Load Subfile  -----------------------------------------------------\n        begsr s01lod;\n          RRb01 = RRn01 + 1;\n          opt01 = 0;\n          setll id    detord1;\n          reade(n)  id detord1;\n          dow not %eof;\n            tot += odtot;\n            totvat += odtotvat;\n            RRN01 = RRN01 + 1;\n            artdesc = GetArtDesc(odarid);\n            write sfl01;\n            reade(n)  id detord1;\n          enddo;\n          sflend = *on;\n          step01 = dsp;\n        endsr;\n        //--- Display Subfile  --------------------------------------------------\n        begsr s01dsp;\n          sfldspctl = *on;\n          sfldsp = RRn01 > 0;\n\n          write key01;\n          exfmt ctl01;\n          if LRRN <>0;\n            RRb01 = LRRN;\n          endif;\n          step01 = key;\n        endsr;\n        //--- Command Keys  -----------------------------------------------------\n        begsr s01key;\n          select;\n          when exit;\n            panel  = 0;\n            step01 = prp;\n          when cancel;\n            step01 = prp;\n            panel  = panel  - 1;\n          when refresh;\n            step01 = prp;\n          other;\n            step01 = chk;\n          endsl;\n        endsr;\n        //--- Check Subfile  ----------------------------------------------------\n        begsr s01chk;\n          step01 = act;\n          err01 = *off;\n          sflnxtchg = *on;\n          readc(e) sfl01;\n          dow not %error and not %eof;\n            if opt01 <> 0 and opt01 <> 2 and opt01 <> 4 and opt01 <> 6;\n              step01 = dsp;\n              dspatr_ri = *on;\n              sflmsg = *on;\n              if not err01;\n                rrb01 = rrn01;\n                err01 = *on;\n              endif;\n            endif;\n            if opt01 =  4 and odqtyliv > 0 ;\n              step01 = dsp;\n              dspatr_ri = *on;\n              sflmsg2 = *on;\n              if not err01;\n                rrb01 = rrn01;\n                err01 = *on;\n              endif;\n            endif;\n            update sfl01;\n            dspatr_ri = *off;\n            readc(e) sfl01;\n          enddo;\n          sflnxtchg = *off;\n        endsr;\n        //--- action Subfile  ---------------------------------------------------\n        begsr s01act;\n          readc(e) sfl01;\n          select;\n          when %error or %eof;\n            step01 = dsp;\n          when opt01 = 2;\n             panel = 2;\n             step02 = prp;\n          when opt01 = 4;\n            tot -= odtot;\n            totvat -= odtotvat;\n            delete (id:odline) detord1;\n            opt01 = 0;\n            odarid = ' ';\n            odqty = 0;\n            odprice = 0;\n            odtot = 0;\n            artdesc = '**** Delete ***';\n            update sfl01;\n          endsl;\n        endsr;\n        //--- Format 02 Subroutines ------------------------------------     ---\n        begsr pnl02;\n          select ;\n          when step02 = prp ;\n            exsr s02prp;\n          when step02 = dsp ;\n            exsr s02dsp;\n          when step02 = key ;\n            exsr s02key;\n          when step02 = chk ;\n            exsr s02chk;\n          when step02 = act ;\n            exsr s02act ;\n          endsl;\n\n        endsr;\n        //--- clear & Load ------------------------------------------------------\n        begsr S02prp;\n          chain (id:odline) detord1;\n          dsqty = odqty;\n          dsqtyliv = odqtyliv;\n          dsprice = odprice;\n          artdesc = GetArtDesc(odarid);\n          vat = CLCVat(GetArtVatCode(odarid):odtot);\n          odtotvat = odtot + vat;\n          vatRate = GetVatRate(GetArtVatCode(odarid));\n          step02 = dsp;\n        endsr;\n        //--- Display  ----------------------------------------------------------\n        begsr S02dsp;\n          exfmt fmt02;\n          step02 = key;\n        endsr;\n        //--- command Keys  -----------------------------------------------------\n        begsr S02key;\n          select;\n          when exit;\n            panel  = 1;\n            step02 = prp;\n          when cancel;\n            step02 = prp;\n            panel  = panel  - 1;\n          other;\n            step02 = chk;\n          endsl;\n        endsr;\n        //--- check -------------------------------------------------------------\n        begsr S02chk;\n          step02 = act;\n          if dsqtyliv > odqty;\n            errqtyliv = *on;\n            step02 = dsp;\n          endif;\n          if dsqty < odqtyliv;\n            errqty = *on;\n            step02 = dsp;\n          endif;\n          odtot =  dsqty * dsprice;\n          vat = CLCVat(GetArtVatCode(odarid):odtot);\n          odtotvat = odtot + vat;\n        endsr;\n        //--- Action ------------------------------------------------------------\n        begsr S02act;\n          if change;\n            step02 = dsp;\n          else;\n            odqty = dsqty;\n            odqtyliv = dsqtyliv;\n            odprice = dsprice;\n            update fdeto;\n            opt01 = 0;\n            update sfl01;\n            step01 = dsp;\n            panel = 1;\n          endif;\n        endsr;\n        //--------INITIALIZATION ----------------------------------\n        begsr *inzsr;\n          chain id order1;\n          CUSTNAME = GetCusName(orcuid);\n\n        endsr;\n        //--------END SUBROUTINE ----------------------------------\n        begsr pnl00;\n          *inlr = *on;\n        endsr;\n      /end-free","context":"     A*%%TS  SD  20161201  111152  VTAQUIN     REL-V7R1M0  5770-WDS\n     A*%%EC\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      PRINT\n     A                                      INDARA\n     A                                      ERRSFL\n     A                                      CA03(03)\n     A                                      CA12(12)\n     A          R SFL01                     SFL\n     A*%%TS  SD  20161201  104932  VTAQUIN     REL-V7R1M0  5770-WDS\n     A  33                                  SFLNXTCHG\n     A            OPT01          2Y 0B  7  3\n     A  34                                  DSPATR(RI)\n     A  34                                  DSPATR(PC)\n     A                                      EDTCDE(Z)\n     A            ODLINE    R        O  7  6REFFLD(FDETO/ODLINE *LIBL/DETORD)\n     A            ODARID    R        O  7 12REFFLD(FDETO/ODARID *LIBL/DETORD)\n     A            ARTDESC       30A  O  7 19\n     A            ODQTY     R        O  7 50REFFLD(FDETO/ODQTY *LIBL/DETORD)\n     A                                      EDTCDE(Z)\n     A            ODTOT     R        O  7 66REFFLD(FDETO/ODTOT *LIBL/DETORD)\n     A            ODPRICE   R        O  7 56REFFLD(FDETO/ODPRICE *LIBL/DETORD)\n     A            ODQTYLIV  R        H      REFFLD(FDETO/ODQTYLIV *LIBL/DETORD)\n     A            ODTOTVAT  R        H      REFFLD(FDETO/ODTOTVAT *LIBL/DETORD)\n     A          R CTL01                     SFLCTL(SFL01)\nord101.pgm.rpgle:\n     d prp             c                   'prp'\n     d lod             c                   'lod'\n     d dsp             c                   'dsp'\n     d key             c                   'key'\n     d chk             c                   'chk'\n     d act             c                   'act'\n     forder1    uf   e           k disk\n     fdetord1   uf   e           k disk\n     ford101d   cf   e             workstn\n     D info            ds\n     D  lrrn                 378    379i 0\n     D indds           ds\n     D  help                   1      1n\n     D  exit                   3      3n\n     D  prompt                 4      4n\n     D  refresh                5      5n\n     D  create                 6      6n\n     D  confirm                8      8n\n     D  cancel                12     12n\n     D  morekeys              24     24n\n     D  pagedown              25     25n\n     D  change                27     27n\n     D  sflclr                30     30n\n     D  sfldsp                31     31n\n     D  sfldspctl             32     32n\n     D  sflnxtchg             33     33n\n     D  dspatr_ri             34     34n\n     D  sflmsg                35     35n\n     D  sflmsg2               36     36n\n     D  ErrQtyLiv             37     37n\n     D  ErrQty                38     38n\n     D  sflend                80     80n\n     D panel           S              3  0 INZ(1)\n     D step01          S              3    inz(prp)\n     D step02          S              3    inz(prp)\n     D rrn01           s              5i 0\n     D count           s              3  0\n     D err01           s               n","output":"This ILE RPG program `ord101` is designed to manage customer orders using subfiles. It interacts with multiple files `order1`, `detord1` and uses various subroutines to handle operations such as preparing, loading, displaying, and processing subfiles. The program also integrates with external procedures to retrieve customer, article, and VAT-related information. It provides a dynamic interface for users to view, edit, delete, and refresh order details.\n\n#### 1. Control Specifications\n\n```rpg\nh dftactgrp(*no) bnddir('SAMPLE')\n```\n- `h dftactgrp(*no)`  This means the program does **not use the default activation group** which is important when using ILE features like service programs or binding directories.\n- `bnddir('SAMPLE')`  Specifies the **binding directory** named `SAMPLE` where external procedures (like `GetCusName`, `GetArtDesc`, etc.) are probably stored.\n\n#### 2. File Declarations\n\n```rpg\nfOrder1    uf   e           k disk\nfDetord1   uf   e           k disk\nfOrd101d   cf   e             workstn\nF                                     indds(indds)\nF                                     sfile(sfl01:rrn01)\nF                                     Infds(Info)\n```\n\n#### 2.1 `Order1` and `Detord1` (Database Files)\n\n- `Order1`, `Detord1`  Declaring two physical files (or logical views).\n- `u`  User controlled I/O, so the program must explicitly perform I/O operations.\n- `f`  Fully procedure file.\n- `e`  File is externally described (DDS defined).\n- `k`  Indicates that the file is keyed (for use with `CHAIN`, `SETLL`, `READE`).\n- `disk`  Denotes a database file.\n\n#### 2.2 `Ord101d` (Display File)\n\n- `c`  Combined input/output operations.\n- `f`  Fully procedure file.\n- `e`  Externally described display file.\n- `workstn`  Indicates this is a workstation (display) file.\n- `INDDS(indds)`  Associates an **indicator data structur** named `indds` to capture function keys like F3, F5, etc.\n- `SFILE(sfl01:rrn01)`  Indicates that the display file contains a subfile named `sfl01` and RRN (relative record number) will be controlled using variable `rrn01`.\n- `INFDS(info)`  Associates a file information data structure `info` with the display file (used to get metadata like the last record number displayed).\n\n#### 3. Prototype & Interface Definition\n\n```rpg\nd  ord101         pr\nd   id                             like(orid)\n\nd  ord101         pi\nd   id                             like(orid)\n```\n\n- `ord101`: This is the name of the **main procedur** in the program.\n- `pr` (Prototype): Declares the interface of the procedure so it can be called from other modules or within the same program.\n- `pi` (Procedure Interface): This defines the actual parameters used in the implementation of the procedure.\n#### Parameter: `id`\n- Defined using `LIKE(ORID)`  which means it takes its data type and attributes from the field `ORID` in the file `SAMREF`.\n- `ORID` is defined as `6P 0`:\n  - `P` = Packed decimal\n  - `6` = Total number of digits\n  - `0` = No decimal positions\n- So, `id` is a **6-digit packed decimal numeric field**, typically used to represent an **order number**.\n\n\n#### 4. Prototype for External Program Call\n\n```rpg\nd Prtord          pr                  extpgm('ORD500')\nd  x                                  like(orid)\n```\n\n- Defines a **prototype to call an external program** `ORD500`, passing parameter `x` of the same type as `orid`.\n\n#### 5. File Information Data Structure\n\n```rpg\nD info            ds\nD  lrrn                 378    379i 0\n```\n\n- Captures the **last relative record number** of the subfile that was shown on screen.\n- Positions 378379 are **fixed offsets** defined by IBM for RRN.\n\n#### 6. Indicator Data Structure\n\n  | Indicator Number | Indicator Name | Description                                  | Use                                           |\n  |------------------|----------------|----------------------------------------------|-----------------------------------------------|\n  | 1                | `help`         | Help indicator                              | Used to display help information (F1).       |\n  | 3                | `exit`         | Exit indicator                              | Used to exit the program (F3).               |\n  | 4                | `prompt`       | Prompt indicator                            | Used to show prompt values (F4).             |\n  | 5                | `refresh`      | Refresh indicator                           | Used to refresh the subfile or screen (F5).  |\n  | 6                | `create`       | Create indicator                            | Used to create new records (F6).             |\n  | 8                | `confirm`      | Confirm indicator                           | Used to confirm or accept data (F8).         |\n  | 12               | `cancel`       | Cancel indicator                            | Used to cancel the current operation (F12).  |\n  | 24               | `morekeys`     | More keys indicator                         | Indicates more function keys available.      |\n  | 25               | `pagedown`     | Page down indicator                         | Used to page down through subfile data.      |\n  | 26               | `pageup`       | Page up indicator                           | Used to page up through subfile data.        |\n  | 27               | `change`       | Change mode indicator                       | Toggles to change/edit mode.                 |\n  | 30               | `sflclr`       | Clear subfile indicator                     | Clears subfile before loading new data.      |\n  | 31               | `sfldsp`       | Display subfile indicator                   | Displays the subfile.                        |\n  | 32               | `sfldspctl`    | Display subfile control indicator           | Controls display of subfile control format.  |\n  | 33               | `sflnxtchg`    | Subfile next change indicator               | Tracks changes to subfile records.           |\n  | 34               | `dspatr_ri`    | Reverse image indicator                     | Highlights errors with reverse image.        |\n  | 35               | `sflmsg`       | Subfile message indicator                   | Displays error or info messages.             |\n  | 36               | `sflmsg2`      | Subfile message 2 indicator                 | Shows delivery-related or custom messages.   |\n  | 37               | `ErrQtyLiv`    | Error quantity delivered indicator          | Flags invalid delivered quantity.            |\n  | 38               | `ErrQty`       | Error quantity indicator                    | Flags invalid ordered quantity.              |\n  | 80               | `sflend`       | Subfile end indicator                       | Indicates end of the subfile list.           |\n\n#### 7. Global Variables \n\n  | Variable Name | Datatype     | Length | Decimal Position | Description                                  |\n  |---------------|--------------|--------|------------------|----------------------------------------------|\n  | `panel`       | Numeric      | 3      | 0                | Tracks the current panel number.             |\n  | `step01`      | Alphanumeric | 3      |                  | Tracks the current step for panel 1.         |\n  | `step02`      | Alphanumeric | 3      |                  | Tracks the current step for panel 2.         |\n  | `rrn01`       | Numeric      | 5      | 0                | Relative record number for subfile 1.        |\n  | `count`       | Numeric      | 3      | 0                | Counter for subfile operations.              |\n  | `err01`       | Indicator    |        |                  | Error indicator for subfile operations.      |\n\n#### 8. Named Constants\n\n  | Constant Name | Value | Description                                      |\n  |---------------|-------|--------------------------------------------------|\n  | `prp`         | 'prp' | Represents the \"prepare\" subroutine.             |\n  | `lod`         | 'lod' | Represents the \"load\" subroutine.                |\n  | `dsp`         | 'dsp' | Represents the \"display\" subroutine.             |\n  | `key`         | 'key' | Represents the \"key processing\" subroutine.      |\n  | `chk`         | 'chk' | Represents the \"validation\" subroutine.          |\n  | `act`         | 'act' | Represents the \"action execution\" subroutine.    |\n\n#### 9. Field Mapping: Database to Display File\n  The following table outlines the mapping of fields from the database files to the display file used in the program. This mapping is essential for displaying the correct information on the subfile screen.\n\n  | `Display Field (DSPF)` | `Assigned From / Variable`         |    `Database Field / Function Call`     | `Description`                       |\n  |------------------------|------------------------------------|------------------------------------------|------------------------------------|\n  | dsqty                  | odqty                              | DETORD1.ODQTY                            | Ordered quantity                   |\n  | dsqtyliv               | odqtyliv                           | DETORD1.ODQTYLIV                         | Delivered quantity                 |\n  | dsprice                | odprice                            | DETORD1.ODPRICE                          | Unit price                         |\n  | artdesc                | GetArtDesc(odarid)                 | Derived from Article Master              | Article description                |\n  | vat                    | CLCVat(GetArtVatCode(odarid), odtot) | Calculated via function                | VAT amount                         |\n  | odtotvat               | odtot + vat                        | Calculated                               | Order total including VAT          |\n  | vatRate                | GetVatRate(GetArtVatCode(odarid)) | Derived via function                      | VAT percentage                     |\n  | tot                    | += odtot                          | DETORD1.ODTOT                             | Running total of order values      |\n  | totvat                 | += odtotvat                       | Calculated                                | Running total with VAT             |\n\n#### 10. Main Exeuction Flow \n\n#### 10.1 Subroutine: `*inzsr`  Program Initialization\n\n- Purpose: \n  - This subroutine is **automatically called at the very beginning** of the program, before any panel or subfile logic starts.  \n  - It initializes the program by loading essential data like the customer name tied to the order. This setup ensures that the screen can display accurate customer information from the start.\n- Key Steps:\n  - Uses `CHAIN` operation to retrieve the order header record from the `ORDER1` file using the key field `ID`.\n  - Extracts the customer ID (`ORCUID`) from the fetched order record.\n  - Calls the external procedure `GetCusName(ORCUID)` to fetch the full customer name.\n  - Stores the result into the variable `CUSTNAME` to be displayed on the panel.\n\n#### 10.2 Main Program Entry  Panel Flow Control\n\n- Purpose:  \n  - This is the **main entry point** of the program after initialization. It determines the flow of the screen based on the value of the `PANEL` variable.\n- Key Steps:\n  - Checks the value of the `panel` variable using a `select; when... endsl;` control block.\n  - If `panel = 1`:  Calls `pnl01`  the main subfile panel where order lines are displayed and edited.\n  - If `panel = 2`:  Calls `pnl02`  the detail panel used to edit individual order line items.\n  - If panel has any other value:  Calls `pnl00`  the program exit subroutine that sets `*INLR = *ON` to end the program.\n\n#### 10.3 SUBROUTINE: pnl01\n\n- Purpose: Manages subfile screen operations for Panel 1 by determining the current step (`step01`) and invoking the corresponding subroutine\n- Key Steps:\n  - `prp`: Calls `s01prp` to prepare the subfile screen.\n  - `lod`: Calls `s01lod` to load order details into the subfile.\n  - `dsp`: Calls `s01dsp` to display the subfile screen.\n  - `key`: Calls `s01key` to process user input.\n  - `chk`: Calls `s01chk` to validate user actions.\n  - `act`: Calls `s01act` to execute user actions.\n\n#### 10.4 Subroutine: `s01prp`  Prepare Subfile\n\n- Purpose: Prepares the subfile screen by clearing it and initializing totals.\n- Key Steps:\n    - Initializes the relative record number (`rrn01`) to 0.\n    - Sets the `sflclr` indicator to *ON to clear the subfile.\n    - Writes the control format (`ctl01`).\n    - Sets the `sflclr` indicator to *OFF.\n    - Sets `step01` to `lod` to proceed to loading data.\n    - Initializes totals (`tot` and `totvat`) to zero.\n\n#### 10.5 Subroutine: `s01lod`  Load Subfile\n\n- Purpose: Reads order detail records from the `detord1` file and loads them into the subfile screen.\n- Key Steps:\n    - Sets the lower limit for reading records using `setll` with the order ID (`id`).\n    - Reads records matching the order ID using `reade`.\n    - For each record read:\n        - Increments the relative record number (`rrn01`).\n        - Updates running totals (`tot` and `totvat`).\n        - Retrieves the article description by calling the `GetArtDesc` procedure with the article ID (`odarid`).\n        - Writes the record to the subfile (`sfl01`).\n        - Sets the `sflend` indicator to *ON.\n        - Sets `step01` to `dsp` to proceed to displaying the subfile.\n\n#### 10.6  Subroutine: `s01dsp`  Display Subfile\n\n- Purpose: Displays the subfile screen to the user.\n- Key Steps:\n    - Sets the `sfldspctl` indicator to *ON to display the subfile control.\n    - Sets the `sfldsp` indicator based on whether there are records to display (`rrn01 > 0`).\n    - Writes the key format (`key01`).\n    - Executes the format (`ctl01`) to display the subfile screen.\n    - If `LRRN` is not zero, updates `rrb01` with `LRRN`.\n    - Sets `step01` to `key` to proceed to processing user input.\n\n#### 10.7 Subroutine: `s01key`  Handle Function Keys\n\n- Purpose: Processes user input from the subfile screen.\n- Key Steps:\n    - Uses a `select` statement to handle different user actions:\n    - `exit`: Sets `panel` to 0 and `step01` to `prp`.\n    - `cancel`: Decrements `panel` by 1 and sets `step01` to `prp`.\n    - `refresh`: Sets `step01` to `prp`.\n    - Other: Sets `step01` to `chk` to proceed to validation.\n\n#### 10.8 Subroutine: `s01chk` - Validate User Actions\n\n- Purpose: Validates user actions and checks for errors.\n- Key Steps:\n    - Sets `step01` to `act` to proceed to action execution.\n    - Initializes `err01` to *OFF.\n    - Sets `sflnxtchg` to *ON.\n    - Reads changed records in the subfile using `readc`.\n    - For each changed record:\n    - Validates the option (`opt01`) selected by the user.\n    - If the option is invalid, sets `step01` to `dsp`, turns on `dspatr_ri` to highlight the error, and sets `sflmsg` to *ON.\n    - If `opt01` is 4 (delete) and `odqtyliv` is greater than 0, sets `step01` to `dsp`, turns on `dsp \n    - Updates each subfile record to reflect highlights or changes.\n    - Disables subfile change tracking after processing.\n\n#### 10.9 Subroutine: `s01act`  Perform Actions for Subfile Options  \n\n- Purpose: Executes the user-selected option for each subfile line (such as edit or delete).\n- Key Steps:\n    - Reads the first changed record from the subfile.\n    - Uses a `SELECT` block to handle:\n    - No selection or read error: Redisplay the screen (`step01 = dsp`)\n    - Option 2 (Edit): Navigates to **Panel 2** and sets step to `prp`\n    - Option 4 (Delete):\n        - Updates totals by subtracting current line's total and VAT.\n        - Deletes the line from physical file `detord1`.\n        - Clears subfile fields to reflect the deletion.\n        - Updates the subfile line to show deletion on screen.\n\n#### 10.10 Subroutine: `pnl02`  Format 02 Controller  \n\n- Purpose: This is the main controller subroutine for panel 02. It determines what action to perform next based on the value of `step02`.\n- Key Steps:\n    - Uses a `SELECT` block to dispatch control to appropriate subroutines:\n    - `prp`: Prepares and loads data.\n    - `dsp`: Displays the panel.\n    - `key`: Processes user input.\n    - `chk`: Validates input.\n    - `act`: Applies changes.\n\n#### 10.11 Subroutine: `s02prp`  Load Data for Format 02  \n\n- Purpose: Prepares the fields needed for editing a selected order detail by loading values from the database and computing VAT.\n- Key Steps:\n    - Fetches the selected record from `detord1` using `CHAIN`.\n    - Copies existing values (`qty`, `price`, `desc`) into screen fields.\n    - Calls external procedures to get article description, VAT code, and VAT rate.\n    - Calculates VAT and total including VAT.\n    - Sets the next step as `dsp` (Display).\n\n#### 10.12 Subroutine: `s02dsp`  Display Format 02 Screen \n\n- Purpose: Displays the format 02 screen for editing quantity and price.\n- Key Steps:\n    - Executes the display format using `EXFMT`.\n    - After user interaction, sets next step to `key`.\n\n#### 10.13 Subroutine: `s02key`  Handle User Key Input  \n- Purpose: Handles function keys like Exit or Cancel, or moves to validation if user confirms.\n- Key Steps:\n    - `exit`: Returns to panel 1 and sets step to `prp`.\n    - `cancel`: Goes back one panel and resets the step.\n    - Any other action leads to validation (`chk`).\n\n#### 10.14 Subroutine: `s02chk`  Validate User Input  \n\n- Purpose: Validates user input related to ordered and delivered quantities and recalculates totals including VAT if inputs are valid.\n    - Key Steps:\n        - If delivered quantity `dsqtyliv` is greater than ordered quantity `odqty`, set `errqtyliv = *on` and `step02 = dsp`.\n        - If entered quantity `dsqty` is less than already delivered quantity `odqtyliv`, set `errqty = *on` and `step02 = dsp`.\n        - If both checks pass:\n        - Calculate line total: `odtot = dsqty * dsprice`.\n        - Determine VAT rate using article ID: `GetArtVatCode(odarid)`.\n        - Calculate VAT: `CLCVat(GetArtVatCode(odarid):odtot)`.\n        - Compute final total including VAT: `odtotvat = odtot + vat`.\n        - If any validation fails, the user remains on the display screen for corrections.\n\n#### 10.15 Subroutine: `s02act`  Save Changes and Return  \n\n- Purpose: Applies the changes to the database and returns to the subfile screen.\n- Key Steps:\n    - If the screen is marked `change` (unsaved edits), redisplay the screen.\n    - Else:\n    - Save updated values (`qty`, `price`) to `detord1`.\n    - Reset option field in subfile.\n    - Update subfile to reflect changes.\n    - Go back to `panel 1` and redisplay subfile (`step01 = dsp`).\n\n#### 10.16 Subroutine: `pnl00`  End Program  \n\n  - Purpose: Terminates the program by setting *INLR (last record indicator).\n  - Key Steps:\n    - Sets `*INLR = *ON` to end the program.\n    - Cleans up any resources or open files.\n\n#### 11. Error Handling\n\n  | Error Flag     | Where Used                | Triggers                                            | User Impact                              |\n  |----------------|---------------------------|-----------------------------------------------------|-------------------------------------------|\n  | `err01`        | Subfile screen (`s01chk`) | Invalid option or delete with delivery              | Prevents next step, highlights subfile row |\n  | `errqtyliv`    | Edit screen (`s02chk`)    | Delivered quantity > Ordered quantity               | Stops update, highlights delivery field   |\n  | `errqty`       | Edit screen (`s02chk`)    | Ordered quantity < Delivered quantity               | Prevents reduction of quantity            |\n  | `errprice`     | Edit screen (`s02chk`)    | Price entered is zero or negative                   | (Optional) Flags pricing mistakes         |\n  | `errvat`       | Edit screen (`s02chk`)    | VAT code missing or invalid                         | (Optional) Ensures correct tax handling   |\n  | `errdesc`      | Edit screen (`s02chk`)    | Article ID doesn't return a description             | (Optional) Prevents invalid products      |","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ORD101/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"how"}}
{"id":"ORD900_sum","input_data":"     forder1    if   e           k disk\n     d next            s              6s 0 DTAARA('LASTORDNO')\n     c     *hival        setgt     order1\n     c                   readp     order1\n     c     *lock         in        next\n     c                   z-add     orid          next\n     c                   out       next\n     c                   seton                                        lr","context":"ORD900.pgm.rpgle:\n     forder1    if   e           k disk\n     d next            s              6s 0 DTAARA('LASTORDNO')","output":"The ILE RPG program retrieves the last order number from the `ORDER1` file and updates it in the `LASTORDNO` data area. It ensures that the latest order number is stored for future reference.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ORD900/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"program-cycle","depth":"sum"}}
{"id":"ORD900_api","input_data":"     forder1    if   e           k disk\n     d next            s              6s 0 DTAARA('LASTORDNO')\n     c     *hival        setgt     order1\n     c                   readp     order1\n     c     *lock         in        next\n     c                   z-add     orid          next\n     c                   out       next\n     c                   seton                                        lr","context":"ORD900.pgm.rpgle:\n     forder1    if   e           k disk\n     d next            s              6s 0 DTAARA('LASTORDNO')","output":"## Purpose\nThe fixed-form ILE RPG program retrieves the last order number from the indexed file (`ORDER1`), updates the value in a data area (`LASTORDNO`), and terminates. It ensures that the latest order number is stored persistently for future reference.  \n\n## Dependencies  \n\n### Database & Data Areas  \n\n| File Name | Type | Usage |  \n|--------------|---------|----------|  \n| `ORDER1` | Logical File | \tLogical view over a physical file (most likely ORDERP). It allows keyed access to order records. |  \n| `LASTORDNO` | Data Area (`DTAARA`) | Stores the last recorded order number for consistency across the system. |  \n\n## Process Flow  \n\n### 1. File and Data Area Setup\n- The program opens the indexed file (`ORDER1`).  \n- It declares a data area (`LASTORDNO`), linking it to the `next` variable.  \n\n### 2. Retrieving the Last Order\n- The program sets the file pointer (`SETGT *HIVAL ORDER1`) to position past the highest key.  \n- It reads the last record (`READP ORDER1`) to fetch the most recent order number.  \n\n### 3. Updating the Order Number\n- The program retrieves the last stored order number (`IN NEXT`) from `LASTORDNO`.  \n- It updates `next` with `orid` (`Z-ADD ORID NEXT`).  \n- The updated value is written back (`OUT NEXT`) to `LASTORDNO`.  \n\n### 4. Program Termination\n- The program sets on the last record (`SETON LR`), signaling termination and releasing resources.  \n\n## Usage Example\n- The program can be executed manually or scheduled in batch jobs.  \n- If compiled as a program object, it can be executed using:  \n\n```rpgle\n    CALL PGM(ORD900)\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ORD900/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"program-cycle","depth":"api"}}
{"id":"ORD900_how","input_data":"     forder1    if   e           k disk\n     d next            s              6s 0 DTAARA('LASTORDNO')\n     c     *hival        setgt     order1\n     c                   readp     order1\n     c     *lock         in        next\n     c                   z-add     orid          next\n     c                   out       next\n     c                   seton                                        lr","context":"ORD900.pgm.rpgle:\n     forder1    if   e           k disk\n     d next            s              6s 0 DTAARA('LASTORDNO')","output":"- The free-form ILE RPG program retrieves the last order number from the `ORDER1` file, updates it in a data area (`LASTORDNO`), and terminates. The program ensures that the latest order number is stored persistently.\n\n## 1. Declare File and Data Area  \n\n- The program defines the `ORDER1` file as a disk-based indexed file.  \n- It declares the variable `next`, which is linked to the `LASTORDNO` data area to store the last recorded order number.  \n\n```rpgle\n     forder1    if   e           k disk\n     d next            s              6s 0 DTAARA('LASTORDNO')\n```\n\n## 2. Position the File to Retrieve the Last Order  \n\n```rpgle\n     c     *hival        setgt     order1\n```\n\n- The program sets the file pointer to the highest possible key value in `ORDER1`.  \n- This ensures that the next `READP` operation will fetch the last record in the file.  \n\n## 3. Retrieve the Last Order Record  \n\n```rpgle\n     c                   readp     order1\n```\n\n- The `readp` (Read Previous) operation retrieves the last record from `ORDER1`.  \n- The order number from the last record is stored in `orid`.   \n\n## 4. Retrieve the Previously Stored Last Order Number  \n\n```rpgle\n     c     *lock         in        next\n```\n\n- The program reads the `LASTORDNO` data area to get the previously stored last order number.  \n- The `*lock` keyword indicates that the program intends to update this value.   \n\n## 5. Update the Last Order Number  \n\n```rpgle\n     c                   z-add     orid          next\n```\n\n- The program updates `next` with `orid`, ensuring that the last recorded order number is now stored in the variable.  \n\n## 6. Store the Updated Order Number in the Data Area  \n\n```rpgle\n     c                   out       next\n```\n\n- The program writes the updated value of `next` back to LASTORDNO, ensuring that future programs can retrieve the latest order number.  \n\n## 7. Terminate the Program  \n\n```rpgle\n     c                   seton      lr\n```\n\n- The program sets `lr` (Last Record) on, signaling that execution is complete.  \n- All resources are released and the program terminates.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/ORD900/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"program-cycle","depth":"how"}}
{"id":"PAR300_sum","input_data":"     h nomain\n\n     FPARAMETER if   e           k disk    usropn\n\n      /copy PARAMETER\n\n     d chainPARAMETER  pr\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n\n     D K_PACODE        S                   LIKE(PACODE)\n     D K_PASUBCODE     S                   LIKE(PASUBCODE)\n\n     C     kf            klist\n     C                   KFLD                    K_PACODE\n     C                   KFLD                    K_PASUBCODE\n\n      *=============================================\n     PGetPARM1         B                     export\n     DGetPARM1         PI            10A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM1;\n      /end-free\n     pGetPARM1         e\n      *=============================================\n     PGetPARM2         B                     export\n     DGetPARM2         PI           100A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM2;\n      /end-free\n     pGetPARM2         e\n      *=============================================\n     PGetPARM3         B                     export\n     DGetPARM3         PI             2A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM3;\n      /end-free\n     pGetPARM3         e\n      *=============================================\n     PGetPARM4         B                     export\n     DGetPARM4         PI             1P 0\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM4;\n      /end-free\n     pGetPARM4         e\n      *=============================================\n     PGetPARM5         B                     export\n     DGetPARM5         PI             3P 0\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM5;\n      /end-free\n     pGetPARM5         e\n\n     p chainPARAMETER  b\n     d chainPARAMETER  pi\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n        if not %open(PARAMETER);\n          open PARAMETER;\n        endif;\n         if P_PACODE <> PACODE\n           or P_PASUBCODE <> PASUBCODE;\n           K_PACODE =  P_PACODE;\n           K_PASUBCODE =  P_PASUBCODE;\n           clear *all FPARAM;\n           chain kf PARAMETER;\n         endif;\n      /end-free\n     p chainPARAMETER  e\n\n     p closePARAMETER  b\n     d closePARAMETER  pi\n      /free\n        if %open(PARAMETER);\n          close PARAMETER;\n        endif;\n      /end-free\n     p closePARAMETER  e","context":"par300.pgm.rpgle:\n     FPARAMETER if   e           k disk    usropn\n     D K_PACODE        S                   LIKE(PACODE)\n     D K_PASUBCODE     S                   LIKE(PASUBCODE)","output":"This RPGLE `Par300`  module for processing parameters stored in a file, where it reads specific records based on a key (`PACODE` and `PASUBCODE`), performs actions to retrieve certain parameter values, and ensures proper handling of file opening and closing.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PAR300/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"module","depth":"sum"}}
{"id":"PAR300_api","input_data":"     h nomain\n\n     FPARAMETER if   e           k disk    usropn\n\n      /copy PARAMETER\n\n     d chainPARAMETER  pr\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n\n     D K_PACODE        S                   LIKE(PACODE)\n     D K_PASUBCODE     S                   LIKE(PASUBCODE)\n\n     C     kf            klist\n     C                   KFLD                    K_PACODE\n     C                   KFLD                    K_PASUBCODE\n\n      *=============================================\n     PGetPARM1         B                     export\n     DGetPARM1         PI            10A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM1;\n      /end-free\n     pGetPARM1         e\n      *=============================================\n     PGetPARM2         B                     export\n     DGetPARM2         PI           100A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM2;\n      /end-free\n     pGetPARM2         e\n      *=============================================\n     PGetPARM3         B                     export\n     DGetPARM3         PI             2A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM3;\n      /end-free\n     pGetPARM3         e\n      *=============================================\n     PGetPARM4         B                     export\n     DGetPARM4         PI             1P 0\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM4;\n      /end-free\n     pGetPARM4         e\n      *=============================================\n     PGetPARM5         B                     export\n     DGetPARM5         PI             3P 0\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM5;\n      /end-free\n     pGetPARM5         e\n\n     p chainPARAMETER  b\n     d chainPARAMETER  pi\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n        if not %open(PARAMETER);\n          open PARAMETER;\n        endif;\n         if P_PACODE <> PACODE\n           or P_PASUBCODE <> PASUBCODE;\n           K_PACODE =  P_PACODE;\n           K_PASUBCODE =  P_PASUBCODE;\n           clear *all FPARAM;\n           chain kf PARAMETER;\n         endif;\n      /end-free\n     p chainPARAMETER  e\n\n     p closePARAMETER  b\n     d closePARAMETER  pi\n      /free\n        if %open(PARAMETER);\n          close PARAMETER;\n        endif;\n      /end-free\n     p closePARAMETER  e","context":"par300.pgm.rpgle:\n     FPARAMETER if   e           k disk    usropn\n     D K_PACODE        S                   LIKE(PACODE)\n     D K_PASUBCODE     S                   LIKE(PASUBCODE)","output":"\n## 1. Purpose\nThis RPGLE `PAR300` module interacts with a physical file named `PARAMETER`. It provides a set of functions to retrieve specific parameter values (`PARM1` to `PARM5`) based on a combination of two keys are `PACODE` and `PASUBCODE`. It provides a set of exported procedures (`GetPARM1` to` GetPARM5`) that returns one of the fields from the required record.\n\n## 2. Exported Procedures\n\n### 2.1 Procedure: GetPARM1\n-  Purpose\n   - Procedure `GetPARM1` returns the value for the `PARM1` field in the required record of the `PARAMETER` file.\n\n-  Parameters and return value\n   - Input Parameters:  \n     - `P_PACODE`: 10-character alphanumeric, represents the primary code.\n     - `P_PASUBCOD`E: 10-character alphanumeric, represents the sub-code. \n   - Return value:  \n     - It returns the 10-character value of the PARM1 field in the record.\n\n- Dependencies\n  - File: `PARAMETER` (keyed physical file, opened dynamically)\n  - Copybook: `/copy PARAMETER`  \n\n- Outcomes\n  - Returns a 10-character value from the PARM1 field. Used typically to fetch configuration values.\n\n- - Usage\n  ``rpgle\n    dcl-s parm1_value char(10);  \n    parm1_value = GetParm1 (code : subcode);\n  ``\n\n### 2.2 Procedure: GetPARM2\n- Purpose\n  - Procedure `GetPARM2` Retrieves the `PARM2` value, a longer alphanumeric field, from the `PARAMETER` file for the given keys.\n\n-  Parameters and return value\n   - Input Parameters:\n     - `P_PACODE`: 10-character alphanumeric. Represents the primary code.\n     - `P_PASUBCODE`: 10-character alphanumeric. Represents the sub-code.\n   - Return Value:\n     - 100-character alphanumeric. The value of the PARM2 field from the record.  \n\n- Dependencies\n  - Physical file: `PARAMETER`\n  - Copybook: `/copy PARAMETER`\n\n- Outcomes\n  - Returns a 100-character value from `PARM2`.\n\n- - Usage\n  ``rpgle\n    dcl-s parm2_value char(100);\n    parm2_value = GetPARM2(code : subcode);\n ``\n\n### 2.3 Procedure: GetPARM3\n- Purpose\n  - Procedure `GetPARM3` retrieves the `PARM3` field value from the desired record in the `PARAMETER` file.\n\n- Parameters and return value\n  - Input Parameters:\n    - `P_PACODE`: 10-character alphanumeric. Represents the primary code.\n    - `P_PASUBCOD`E: 10-character alphanumeric. Represents the sub-code.\n  - Return Value:\n    - 2-character alphanumeric. The value of the `PARM3` field from the record.\n\n- Dependencies\n  - Physical file: `PARAMETER`\n  - Copybook: `/copy PARAMETER`\n\n- Outcomes\n  - Returns a 2-character alphanumeric value.\n\n- Usage\n  ``rpgle \n    dcl-s parm3_value char(2);\n    parm3_value = GetPARM3(code : subcode);\n  ``\n\n### 2.4 Procedure: GetPARM4\n- Purpose\n  - Procedure `GetPARM4` returns the numeric `PARM4` field from a specific record in the `PARAMETER` file. \n\n- Parameters and return value\n  - Input Parameters:\n    - `P_PACODE`: 10-character alphanumeric. Represents the primary code.\n    - `P_PASUBCODE`: 10-character alphanumeric. Represents the sub-code.\n  - Return Value:\n    - Packed decimal (3,0). The value of the `PARM4` field from the record.   \n\n- Outcomes\n  - Returns a 1-digit packed decimal value from `PARM4`.\n\n-  Usage\n  ``rpgle\n    dcl-s parm4_value packed(1:0);\n    parm4_value = GetPARM4(code : subcode);\n  ``\n\n### 2.5 Procedure: GetPARM5\n- Purpose\n  - Procedure `GetPARM5` retrieves the `PARM5` field, which is a small numeric value, from the appropriate record in the `PARAMETER` file.  \n\n- Parameters and return value\n  - Input Parameters:\n    - `P_PACODE`: 10-character alphanumeric. Represents the primary code.\n    - `P_PASUBCODE`: 10-character alphanumeric. Represents the sub-code. \n  - Return Value:\n    - Packed decimal (3,0). The value of the `PARM5` field from the record.\n\n- Dependencies\n  - Physical file: PARAMETER\n  - Copybook: /copy PARAMETER  \n\n- Outcomes\n  - Returns a packed decimal (3,0) value from PARM5.    \n\n- - Usage\n  ``rpgle\n    dcl-s parm5_value packed(3:0);\n    parm5_value = GetPARM5(code : subcode);\n  ``","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PAR300/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"module","depth":"api"}}
{"id":"PAR300_how","input_data":"     h nomain\n\n     FPARAMETER if   e           k disk    usropn\n\n      /copy PARAMETER\n\n     d chainPARAMETER  pr\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n\n     D K_PACODE        S                   LIKE(PACODE)\n     D K_PASUBCODE     S                   LIKE(PASUBCODE)\n\n     C     kf            klist\n     C                   KFLD                    K_PACODE\n     C                   KFLD                    K_PASUBCODE\n\n      *=============================================\n     PGetPARM1         B                     export\n     DGetPARM1         PI            10A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM1;\n      /end-free\n     pGetPARM1         e\n      *=============================================\n     PGetPARM2         B                     export\n     DGetPARM2         PI           100A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM2;\n      /end-free\n     pGetPARM2         e\n      *=============================================\n     PGetPARM3         B                     export\n     DGetPARM3         PI             2A\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM3;\n      /end-free\n     pGetPARM3         e\n      *=============================================\n     PGetPARM4         B                     export\n     DGetPARM4         PI             1P 0\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM4;\n      /end-free\n     pGetPARM4         e\n      *=============================================\n     PGetPARM5         B                     export\n     DGetPARM5         PI             3P 0\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n         chainPARAMETER(P_PACODE\n               :P_PASUBCODE);\n\n         return PARM5;\n      /end-free\n     pGetPARM5         e\n\n     p chainPARAMETER  b\n     d chainPARAMETER  pi\n     D P_PACODE                      10A    value\n     D P_PASUBCODE                   10A    value\n      /free\n        if not %open(PARAMETER);\n          open PARAMETER;\n        endif;\n         if P_PACODE <> PACODE\n           or P_PASUBCODE <> PASUBCODE;\n           K_PACODE =  P_PACODE;\n           K_PASUBCODE =  P_PASUBCODE;\n           clear *all FPARAM;\n           chain kf PARAMETER;\n         endif;\n      /end-free\n     p chainPARAMETER  e\n\n     p closePARAMETER  b\n     d closePARAMETER  pi\n      /free\n        if %open(PARAMETER);\n          close PARAMETER;\n        endif;\n      /end-free\n     p closePARAMETER  e","context":"par300.pgm.rpgle:\n     FPARAMETER if   e           k disk    usropn\n     D K_PACODE        S                   LIKE(PACODE)\n     D K_PASUBCODE     S                   LIKE(PASUBCODE)","output":"\nThis RPGLE `Par300` module is designed to manage a process related to parameter data retrieval from a file, specifically returning the value of various fields from the record associated with the specific codes `P_PACODE` and `P_PASUBCODE` in the `PARAMETER` file.\n\n### Explanation of the RPG Code\n\n#### 1. Control Specifications\nThe control specification section contains the following:\n```rpgle\nh nomain\n```\n- `nomain`: This keyword indicates that the program does not have a main procedure. Instead, the module consists only of subprocedures that can be called externally. This is common in service programs or utility modules.\n\n#### 2. File Declarations\n```rpgle\nFPARAMETER if   e           k disk    usropn\n```\n- `PARAMETER`: This is the file name assigned for use in this program. It is likely a keyed physical file.\n- `if`: Declares the file as an input file.\n- `e`: Specifies that the file has externally described fields.\n- `k`: Indicates that the file is keyed, and key fields will be used for record access.\n- `usropn`: Specifies that the program will explicitly open and close the file using `open` and `close` operations.\n\n#### 3. Global Components\n##### Global Variables\n```rpgle\nD K_PACODE        S                   LIKE(PACODE)\nD K_PASUBCODE     S                   LIKE(PASUBCODE)\n```\n- `K_PACODE` and `K_PASUBCODE`: These are global variables used as key fields for the `PARAMETER` file. Their data types and lengths are defined to match the fields `PACODE` and `PASUBCODE` in the file.\n\n##### Key List\n```rpgle\nC     kf            klist\nC                   KFLD                    K_PACODE\nC                   KFLD                    K_PASUBCODE\n```\n- `kf`: This key list defines the composite key for accessing the `PARAMETER` file. It consists of two fields: `K_PACODE` and `K_PASUBCODE`.\n\n#### 4. Procedures\nThe module consists of several procedures, each serving a specific purpose. All procedures are marked with the `export` keyword, meaning they can be invoked by external programs.\n\n##### Procedure `GetPARM1 Procedure`\n  - The `GetPARM1` procedure retrieves a specific field (`PARM1`) from the `PARAMETER` file.\n\n  - Definitions:\n    - The procedure returns a value of type `10A` (alphanumeric, 10 characters).\n    - It accepts two input parameters:\n      - `P_PACODE`: a 10-character alphanumeric value.\n      - `P_PASUBCODE`: another 10-character alphanumeric value.\n    - Both parameters are passed by value.\n\n  - Main Logic:\n    - The `CHAIN` operation is used to retrieve a record from the `PARAMETER` file using the composite key made up of `P_PACODE` and `P_PASUBCODE`.\n    - If a matching record is found, the fields from that record are loaded into the programs memory.\n    - The procedure then returns the value of the field `PARM1`, which is assumed to be a field from the `PARAMETER` file that was loaded by the `CHAIN`.\n    - The procedure ends with `pGetPARM1 e`.\n\n##### Procedure `GetPARM2 Procedure`\n  - The `GetPARM2` procedure retrieves a different field (`PARM2`) from the `PARAMETER` file.\n\n  - Definitions:\n    - The procedure returns a value of type `100A` (alphanumeric, 10 characters).\n    - It accepts two input parameters:\n      - `P_PACODE`: A 10-character alphanumeric value passed by value.\n      - `P_PASUBCODE`: Another 10-character alphanumeric value passed by value.\n\n  - Main Logic:\n    - The `CHAIN` operation is used to retrieve a record from the `PARAMETER `file using the composite key made up of `P_PACODE` and `P_PASUBCODE`.\n    - If a matching record is found, the fields from that record are loaded into the programs memory.\n    - The procedure then returns the value of the field `PARM2`, which is assumed to be a field from the `PARAMETER` file that was loaded by the `CHAIN`.\n    - The procedure ends with `pGetPARM2 e`.\n\n##### Procedure `GetPARM3 Procedure`\n  - The `GetPARM3` procedure retrieves a smaller field (`PARM3`) from the `PARAMETER` file.\n\n  - Definitions:\n    - The procedure returns a value of type `2A` (2-character alphanumeric).\n    - It accepts two input parameters:\n      - `P_PACODE`: A 10-character alphanumeric value passed by value.\n      - `P_PASUBCODE`: Another 10-character alphanumeric value passed by value.\n\n  - Main Logic:\n    - The `CHAIN` operation is used to retrieve a record from the `PARAMETER` file using the composite key made up of `P_PACODE` and `P_PASUBCODE`.\n    - If a matching record is found, the fields from that record are loaded into the programs memory.\n    - The procedure then returns the value of the field `PARM3`, which is assumed to be a field from the `PARAMETER` file that was loaded by the `CHAIN`.\n    - The procedure ends with `pGetPARM3 e`.\n\n##### Procedure `GetPARM4 Procedure`\n  - The `GetPARM4` procedure retrieves a numeric field (`PARM4`) from the `PARAMETER` file.\n\n  -  Definitions:\n    - The procedure returns a value of type `1P` (Packed decimal, 1 digit, no decimals).\n    - It accepts two input parameters:\n      - `P_PACODE`: A 10-character alphanumeric value passed by value.\n      - `P_PASUBCODE`: Another 10-character alphanumeric value passed by value.\n\n  - Main Logic:\n    - The `CHAIN` operation is used to retrieve a record from the `PARAMETER` file using the composite key made up of `P_PACODE` and `P_PASUBCODE`.\n    - If a matching record is found, the fields from that record are loaded into the programs memory.\n    - The procedure then returns the value of the field `PARM4`, which is assumed to be a field from the `PARAMETER` file that was loaded by the `CHAIN`.\n    - The procedure ends with `pGetPARM4 e`.\n\n##### Procedure `GetPARM5 Procedure`\n  - The procedure is defined with the name `GetPARM5` and is marked as `export`, meaning it can be called from outside the module where it is defined.\n\n  - Definitions:\n    - The procedure returns a value of type `3P` (Packed decimal, 3 digit, no decimals).\n    - It accepts two input parameters:\n    - `P_PACODE` (10A): A 10-character alphanumeric value passed by value.\n    - `P_PASUBCODE` (10A): Another 10-character alphanumeric value passed by value.\n\n  - Main Logic:\n    - The `CHAIN` operation is used to retrieve a record from the `PARAMETER` file using the composite key made up of `P_PACODE` and `P_PASUBCODE`.\n    - If a matching record is found, the fields from that record are loaded into the programs memory.\n    - The procedure then returns the value of the field `PARM5`, which is assumed to be a field from the `PARAMETER` file that was loaded by the `CHAIN`.\n    - The procedure ends with `pGetPARM5 e`.\n    - This procedure returns the value of the field `PARM5`.\n\n##### Procedure `chainPARAMETER Procedure`\n  - The procedure is defined with the name `chainPARAMETER`. It is designed to handle the logic for opening the `PARAMETER` file if it is not already open, and to retrieve a record from the file based on a composite key made up of `P_PACODE` and `P_PASUBCODE`.\n\n  - Definitions:\n    - Return Type: This procedure does not return a value (`PI` without a return type).\n    - It accepts two input parameters:\n      - `P_PACODE` (10A): A 10-character alphanumeric value passed by value.\n      - `P_PASUBCODE` (10A): Another 10-character alphanumeric value passed by value.\n\n  - Main Logic:\n    - File Open Check:\n    - The `%open` built-in function checks if the `PARAMETER` file is already open.\n    - If the file is not open, the `open` operation is used to open it.\n\n  - Key Validation:\n    - The procedure compares the input parameters `P_PACODE` and `P_PASUBCODE` with the current values of `PACODE` and `PASUBCODE` (likely fields in the `PARAMETER` file).\n    - If the input values are different from the current values in memory:\n      - `K_PACODE` and `K_PASUBCODE` (key fields) are updated with the input values.\n      - The `clear *all FPARAM` operation clears all fields in the file buffer for `PARAMETER`.\n\n  - CHAIN Operation:\n    - The `CHAIN` operation is used with the composite key (`kf`) to retrieve the corresponding record from the `PARAMETER` file.\n\n  - End of Procedure:\n    - The procedure completes its execution with `p chainPARAMETER e`.\n\nThis procedure centralizes the logic for opening the file, validating the key, and performing the `CHAIN` operation, ensuring consistency and reusability across the module.\n\n##### Procedure `closePARAMETER Procedure`\n  - The procedure is defined with the name `closePARAMETER`. It is designed to ensure the `PARAMETER` file is closed if it is currently open.\n\n  - Definitions:\n    - This procedure does not return a value (`PI` without a return type).\n    - Input Parameters: None.\n\n  - Main Logic:\n    - The `%open` built-in function is used to check if the `PARAMETER` file is currently open.\n    - If the file is open, the `close` operation is executed to close the file.\n    - This ensures proper resource management by explicitly closing the file when it is no longer needed.\n    - The procedure ends with `p closePARAMETER e`.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PAR300/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"module","depth":"how"}}
{"id":"PRO300_sum","input_data":"     h nomain\n\n     FPROVIDE1  if   e           k disk    usropn\n\n      /copy PROVIDER\n\n     d chainPROVIDE1   pr\n     D P_PRID                         5P 0  value\n\n     D K_PRID          S                   LIKE(PRID)\n\n     C     kf            klist\n     C                   KFLD                    K_PRID\n\n      *=============================================\n     PGetProName       B                     export\n     DGetProName       PI                  like(provnm)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PROVNM;\n      /end-free\n     pGetProName       e\n      *=============================================\n     PGetProCONT       B                     export\n     DGetProCONT       PI                  like(prcont)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCONT;\n      /end-free\n     pGetProCONT       e\n      *=============================================\n     PGetProPHONE      B                     export\n     DGetProPHONE      PI                  like(prphone)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRPHONE;\n      /end-free\n     pGetProPHONE      e\n      *=============================================\n     PGetProVAT        B                     export\n     DGetProVAT        PI                  like(prvat)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRVAT;\n      /end-free\n     pGetProVAT        e\n      *=============================================\n     PGetProMAIL       B                     export\n     DGetProMAIL       PI                  like(prmail)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRMAIL;\n      /end-free\n     pGetProMAIL       e\n      *=============================================\n     PGetProAdr1       B                     export\n     DGetProAdr1       PI                  like(prline1)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE1;\n      /end-free\n     pGetProAdr1       e\n      *=============================================\n     PGetProAdr2       B                     export\n     DGetProAdr2       PI                  like(prline2)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE2;\n      /end-free\n     pGetProAdr2       e\n      *=============================================\n     PGetProAdr3       B                     export\n     DGetProAdr3       PI                  like(prline3)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE3;\n      /end-free\n     pGetProAdr3       e\n      *=============================================\n     PGetProZip        B                     export\n     DGetProZip        PI                  like(przip)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRZIP;\n      /end-free\n     pGetProZip        e\n      *=============================================\n     PGetProCity       B                     export\n     DGetProCity       PI                  like(prcity)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCITY;\n      /end-free\n     pGetProCity       e\n      *=============================================\n     PGetProCountry    B                     export\n     DGetProCountry    PI                  like(prcoun)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCOUN;\n      /end-free\n     pGetProCountry    e\n      *=============================================\n     P ExistProvider   B                     export\n     D ExistProvider   PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return %found(provide1) and prdel <> 'X';\n      /end-free\n     p ExistProvider   e\n\n      *=============================================\n     PIsProDeleted     B                     export\n     DIsProDeleted     PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRDEL = 'X';\n      /end-free\n     pIsProDeleted     e\n\n     p chainPROVIDE1   b\n     d chainPROVIDE1   pi\n     D P_PRID                         5P 0  value\n      /free\n        if not %open(PROVIDE1);\n          open PROVIDE1;\n        endif;\n         if P_PRID <> PRID;\n           K_PRID =  P_PRID;\n           clear *all FPROV;\n           chain kf PROVIDE1;\n         endif;\n      /end-free\n     p chainPROVIDE1   e\n\n     p closePROVIDE1   b\n     d closePROVIDE1   pi\n      /free\n        if %open(PROVIDE1);\n          close PROVIDE1;\n        endif;\n      /end-free\n     p closePROVIDE1   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn\n     D K_PRID          S                   LIKE(PRID)","output":"This ILE RPG module `PRO300` provides a list of reusable functions to retrieve individual database fields or status from `PROVIDE1` database file for a passed in parameter provider_Id `PRID` for each procedure.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"sum"}}
{"id":"PRO300_api","input_data":"     h nomain\n\n     FPROVIDE1  if   e           k disk    usropn\n\n      /copy PROVIDER\n\n     d chainPROVIDE1   pr\n     D P_PRID                         5P 0  value\n\n     D K_PRID          S                   LIKE(PRID)\n\n     C     kf            klist\n     C                   KFLD                    K_PRID\n\n      *=============================================\n     PGetProName       B                     export\n     DGetProName       PI                  like(provnm)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PROVNM;\n      /end-free\n     pGetProName       e\n      *=============================================\n     PGetProCONT       B                     export\n     DGetProCONT       PI                  like(prcont)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCONT;\n      /end-free\n     pGetProCONT       e\n      *=============================================\n     PGetProPHONE      B                     export\n     DGetProPHONE      PI                  like(prphone)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRPHONE;\n      /end-free\n     pGetProPHONE      e\n      *=============================================\n     PGetProVAT        B                     export\n     DGetProVAT        PI                  like(prvat)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRVAT;\n      /end-free\n     pGetProVAT        e\n      *=============================================\n     PGetProMAIL       B                     export\n     DGetProMAIL       PI                  like(prmail)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRMAIL;\n      /end-free\n     pGetProMAIL       e\n      *=============================================\n     PGetProAdr1       B                     export\n     DGetProAdr1       PI                  like(prline1)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE1;\n      /end-free\n     pGetProAdr1       e\n      *=============================================\n     PGetProAdr2       B                     export\n     DGetProAdr2       PI                  like(prline2)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE2;\n      /end-free\n     pGetProAdr2       e\n      *=============================================\n     PGetProAdr3       B                     export\n     DGetProAdr3       PI                  like(prline3)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE3;\n      /end-free\n     pGetProAdr3       e\n      *=============================================\n     PGetProZip        B                     export\n     DGetProZip        PI                  like(przip)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRZIP;\n      /end-free\n     pGetProZip        e\n      *=============================================\n     PGetProCity       B                     export\n     DGetProCity       PI                  like(prcity)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCITY;\n      /end-free\n     pGetProCity       e\n      *=============================================\n     PGetProCountry    B                     export\n     DGetProCountry    PI                  like(prcoun)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCOUN;\n      /end-free\n     pGetProCountry    e\n      *=============================================\n     P ExistProvider   B                     export\n     D ExistProvider   PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return %found(provide1) and prdel <> 'X';\n      /end-free\n     p ExistProvider   e\n\n      *=============================================\n     PIsProDeleted     B                     export\n     DIsProDeleted     PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRDEL = 'X';\n      /end-free\n     pIsProDeleted     e\n\n     p chainPROVIDE1   b\n     d chainPROVIDE1   pi\n     D P_PRID                         5P 0  value\n      /free\n        if not %open(PROVIDE1);\n          open PROVIDE1;\n        endif;\n         if P_PRID <> PRID;\n           K_PRID =  P_PRID;\n           clear *all FPROV;\n           chain kf PROVIDE1;\n         endif;\n      /end-free\n     p chainPROVIDE1   e\n\n     p closePROVIDE1   b\n     d closePROVIDE1   pi\n      /free\n        if %open(PROVIDE1);\n          close PROVIDE1;\n        endif;\n      /end-free\n     p closePROVIDE1   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn\n     D K_PRID          S                   LIKE(PRID)","output":"## Purpose \nThis ILE RPG module `PRO300` provides a list of reusable functions to retrieve individual database fields or status from `PROVIDE1` database file for a passed in parameter provider_Id `PRID` for each procedure.\n\n- Accesses provider data from a database file (`PROVIDE1`)\n- Provides getter procedures for each of required database file field (name, phone, email, etc.)\n- Uses a central routine `chainPROVIDE1` for reading records\n- Its designed for reusability, modularity, and easy integration\n\n\n## Parameters  \nBelow mentioned input parameter is accepted by all exported procedures referred in this module.\n| Parameter Name | Data Type | Length | Usage  | Description                              |\n|----------------|-----------|--------|--------|------------------------------------------|\n| `P_PRID`       | Packed    | 5,0    | Input  | Provider ID used to fetch  details.      |\n\n### API features in this module \n- Input parameter - `P_PRID` - Provider ID passed to exported procedures\n- Procedure call - e.g. `GetProName(10001)`\n- Data access - `Chain` reads database record from database file `PROVIDE1`\n- Modular result - Each exported procedure returns only one piece of information (name, phone, status etc.)\n- Error handling - If provider Id is not found or deleted, returns default\n- Exportable - All procedures marked with `export`\n\n### Database Interactions  \nThis module reads database record from the following database file.\n\n| File Name  | Type | Description                                                                                                         |\n|------------|------|---------------------------------------------------------------------------------------------------------------------|\n| `PROVIDE1` | LF   | Logical view over `provider` physical file, used to retrieve provider details based on key field Provider Id.       |\n\n## Error Handling  \n\n- If the `P_PRID` is not found in `PROVIDE1`, exported procedures will return a blank or **OFF* in case return data type is boolean indicator.  \n\n## Usage Example  \nWhen another program needs a providers email.\n- It calls: GetProMAIL(10001)\n- This internally calls: chainPROVIDE1(10001)\n- That loads the provider record from PROVIDE1\n- Returns the value of PRMAIL (email)\n```rpgle\n        GetProMAIL(10001) \n```\nEach of the exported procedure is:\n- Modular\n- Reusable\n- Lightweight","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"api"}}
{"id":"PRO300_how","input_data":"     h nomain\n\n     FPROVIDE1  if   e           k disk    usropn\n\n      /copy PROVIDER\n\n     d chainPROVIDE1   pr\n     D P_PRID                         5P 0  value\n\n     D K_PRID          S                   LIKE(PRID)\n\n     C     kf            klist\n     C                   KFLD                    K_PRID\n\n      *=============================================\n     PGetProName       B                     export\n     DGetProName       PI                  like(provnm)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PROVNM;\n      /end-free\n     pGetProName       e\n      *=============================================\n     PGetProCONT       B                     export\n     DGetProCONT       PI                  like(prcont)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCONT;\n      /end-free\n     pGetProCONT       e\n      *=============================================\n     PGetProPHONE      B                     export\n     DGetProPHONE      PI                  like(prphone)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRPHONE;\n      /end-free\n     pGetProPHONE      e\n      *=============================================\n     PGetProVAT        B                     export\n     DGetProVAT        PI                  like(prvat)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRVAT;\n      /end-free\n     pGetProVAT        e\n      *=============================================\n     PGetProMAIL       B                     export\n     DGetProMAIL       PI                  like(prmail)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRMAIL;\n      /end-free\n     pGetProMAIL       e\n      *=============================================\n     PGetProAdr1       B                     export\n     DGetProAdr1       PI                  like(prline1)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE1;\n      /end-free\n     pGetProAdr1       e\n      *=============================================\n     PGetProAdr2       B                     export\n     DGetProAdr2       PI                  like(prline2)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE2;\n      /end-free\n     pGetProAdr2       e\n      *=============================================\n     PGetProAdr3       B                     export\n     DGetProAdr3       PI                  like(prline3)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRLINE3;\n      /end-free\n     pGetProAdr3       e\n      *=============================================\n     PGetProZip        B                     export\n     DGetProZip        PI                  like(przip)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRZIP;\n      /end-free\n     pGetProZip        e\n      *=============================================\n     PGetProCity       B                     export\n     DGetProCity       PI                  like(prcity)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCITY;\n      /end-free\n     pGetProCity       e\n      *=============================================\n     PGetProCountry    B                     export\n     DGetProCountry    PI                  like(prcoun)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCOUN;\n      /end-free\n     pGetProCountry    e\n      *=============================================\n     P ExistProvider   B                     export\n     D ExistProvider   PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return %found(provide1) and prdel <> 'X';\n      /end-free\n     p ExistProvider   e\n\n      *=============================================\n     PIsProDeleted     B                     export\n     DIsProDeleted     PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRDEL = 'X';\n      /end-free\n     pIsProDeleted     e\n\n     p chainPROVIDE1   b\n     d chainPROVIDE1   pi\n     D P_PRID                         5P 0  value\n      /free\n        if not %open(PROVIDE1);\n          open PROVIDE1;\n        endif;\n         if P_PRID <> PRID;\n           K_PRID =  P_PRID;\n           clear *all FPROV;\n           chain kf PROVIDE1;\n         endif;\n      /end-free\n     p chainPROVIDE1   e\n\n     p closePROVIDE1   b\n     d closePROVIDE1   pi\n      /free\n        if %open(PROVIDE1);\n          close PROVIDE1;\n        endif;\n      /end-free\n     p closePROVIDE1   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn\n     D K_PRID          S                   LIKE(PRID)","output":"This ILE RPG module `PRO300` provides reusable functions to retrieve individual database fields or status from the `PROVIDE1` database file for a passed in input parameter provide_Id `PRID` for each procedure.\n\n## List of Procedures/functions used in this module \n\nBelow is the summary of procedures involved in this module `PRO300`.\n |Procedure name   | category        | Return value    | input parameter/Description     |\n |-----------------|-----------------|-----------------|---------------------------------|\n | `GetProName`    | `export`        | Provider_Name   |\tBy `PRID`                    |\n | `GetProCONT`    | `export`        | Contact_Person  |\tBy `PRID`                    |\n | `GetProPHONE`   | `export`        | Phone Number    | \tBy `PRID`                    |\n | `GetProVAT`\t   | `export`        | VAT Number\t   |    By `PRID`                    |\n | `GetProMAIL`\t   | `export`        | Email Address   |\tBy `PRID`                    | \n | `GetProAdr1`    | `export`        | Address Line 1  |    By `PRID`                    |\n | `GetProAdr2`    | `export`        | Address Line 2  |    By `PRID`                    |\n | `GetProAdr3`    | `export`        | Address Line 3  |    By `PRID`                    |\n | `GetProZip`\t   | `export`        | Zip Code\t       |    By `PRID`                    |\n | `GetProCity`\t   | `export`        | City\t           |    By `PRID`                    |\n | `GetProCountry` | `export`\t     | Country\t       |    By `PRID`                    |\n | `ExistProvider` | `export`        | Boolean (1/0)   | exists and not deleted          |\n | `IsProDeleted`  | `export`        | Boolean (1/0)   | checks deletion flag            |\n | `chainPROVIDE1` | *Internal use*  | None            | Centralizes file access logic   |\n | `closePROVIDE1` | *Internal use*  | None            | Database file explicit close    | \n\n -  `export` - It can be used outside this module `PRO300`. \n\n## How Explanation \n\n - It does not have a main() procedure it only defines callable procedures (meant to be used as a service program).\n - Database file `Provide1` is an input full procedural control externally described key file. It must be opened and closed manually. \n\n ```Rpgle \n        h nomain\n        FPROVIDE1  if   e           k disk    usropn\n ```\n\n 1. `chainPROVIDE1` - Data retrieval procedure\n\n - This procedure accepts one input parameter `P_PRID` a 5-digit packed number (the provider ID) passed by value. \n - If the file is not open, it opens the file using the `open` opcode (manual open is needed because the file was declared with `usropn`).\n- `PRID` is likely a global variable holding the key of the last successfully loaded record.\n- This line checks if the requested ID (`P_PRID`) is different from the current one.\n- If theyre the same, we skip the read, assuming the record is already in memory. \nThis is a *performance optimization*.\n-Assigns the input parameter field to the key field used in the key list (`kf`).\n- Clears all fields in the `FPROV` record format, the one loaded from the file. This avoids leftover data from previous reads.\n- Performs a *keyed read* of the `PROVIDE1` database file using the `kf` key list.\n- and provides the default values should no matching record be found.\n- End of free-format code and end of procedure\n ```rpgle\n        p chainPROVIDE1   b\n        d chainPROVIDE1   pi\n        D P_PRID                         5P 0  value\n         /free\n           if not %open(PROVIDE1);\n             open PROVIDE1;\n           endif;\n             if P_PRID <> PRID;\n              K_PRID =  P_PRID;\n               clear *all FPROV;\n               chain kf PROVIDE1;\n             endif;\n         /end-free\n        p chainPROVIDE1   e\n``` \n\n## Benefits of above code:\n- Avoid redundant file reads (performance gain).\n- Safely manage file access when usropn is used.\n- Ensure clean data by clearing structure before reading.\n\n2. `closePROVIDE1` - Procedure to close `PROVIDE1` database file\n- This procedure does not accept any input parameters and return nothing.\n- It checks whether the database file `PROVIDE1` is currently open.\n- If the file is open, proceed to close the file. Its important to do this especially when working with `usropn` to release resources or reset the state between processes.\n- If the file is not open, it does nothing (avoids error from trying to close an unopened file).\n\n\n```rpgle\n        p closePROVIDE1   b\n        d closePROVIDE1   pi\n         /free\n           if %open(PROVIDE1);\n             close PROVIDE1;\n           endif;\n         /end-free\n        p closePROVIDE1   e\n```\n3. Getter Procedures (GetProXXX)\n- Each of these procedures does the same thing structurally.\n  - Accepts an input parameter packed numeric 5 digits - Provider ID `P_PRID`\n  - Calls procedure `chainPROVIDE1` to load the record from the database file\n  - Returns the specific field requested. \n\n```rpgle \n        PGetProName       B                     export\n        DGetProName       PI                  like(provnm)\n        D P_PRID                         5P 0  value\n         /free\n          chainPROVIDE1(P_PRID\n               );\n           return PROVNM;\n         /end-free\n        pGetProName       e\n```\n### 3.1  Example: Get Provider Name\n- `like(provnm)`  Return type is same as `PROVNM` database file field\n- `chainPROVIDE1(P_PRID);`  Loads the database record for passed parameter provide id `P_PRID`\n- `return PROVNM;`  Returns the *provider name* database file field\n\n4. Similar getters are implemented for:\n- `GetProCONT()`  Contact\n- `GetProPHONE()`  Phone\n- `GetProVAT()`  VAT number\n- `GetProMAIL()`  Email\n- `GetProAdr1() / Adr2() / Adr3()`  Address lines\n- `GetProZip()`  ZIP code\n- `GetProCity()`  City\n- `GetProCountry()`  Country\n\nEach of these is a single-purpose function returning just one field.\n\n5. `ExistProvider` procedure - Existence checker\n- This procedure checks if record is found in database file `PROVIDE1`\n- and that database record is active (`PRDEL` is not `X` - not deleted).\n- It returns a boolean indicator *1* for success and *0* for failure.\n```rpgle\n        P ExistProvider   B                     export\n        D ExistProvider   PI              n\n        D P_PRID                         5P 0  value\n         /free\n           chainPROVIDE1(P_PRID\n               );\n           return %found(provide1) and prdel <> 'X';\n         /end-free\n        p ExistProvider   e\n```\n6. `IsProDeleted` procedure - Deletion checkers \n- This procedure returns boolean indicator value *1*, if provider is deleted. `(PRDEL = 'X')`\n- If provider id is not deleted, it returns *0*. \n```rpgle \n        PIsProDeleted     B                     export\n        DIsProDeleted     PI              n\n        D P_PRID                         5P 0  value\n         /free\n           chainPROVIDE1(P_PRID\n               );\n           return PRDEL = 'X';\n         /end-free\n        pIsProDeleted     e\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fc","scope":"file","depth":"how"}}
{"id":"PRO300_ExistProvider_sum","input_data":"     P ExistProvider   B                     export\n     D ExistProvider   PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return %found(provide1) and prdel <> 'X';\n      /end-free\n     p ExistProvider   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"The ILE RPG procedure `ExistProvider` checks if a provider exists and is not marked as deleted. It returns `true` if the provider is active, otherwise `false`.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_ExistProvider/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"sum"}}
{"id":"PRO300_ExistProvider_api","input_data":"     P ExistProvider   B                     export\n     D ExistProvider   PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return %found(provide1) and prdel <> 'X';\n      /end-free\n     p ExistProvider   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"## Purpose  \n- The ILE RPG procedure `ExistProvider` procedure checks whether a provider exists in the `PROVIDE1` file and ensures it is not marked as deleted.\n\n## Parameters\n\n- The following parameters are used in the procedure:\n\n| Parameter Name | Data Type | Length | Usage | Description |\n|--------------|-----------|--------|-------|-------------|\n| `P_PRID`    | Packed    | 5,0    | Input | Provider ID to check |\n\n## Return Value\n\nReturns whether any provider by the given provider id exist and have not been marked deleted using the `PRDEL` field.\n\n## Impacts  \n\n### Dependencies  \n\n- The below subprocedures are used in the `ExistProvider` procedure:\n\n| Sub-procedure Name | Description |\n|--------------------|-------------|\n| `chainPROVIDE1`   | Fetches provider details from `PROVIDE1` using `P_PRID` |\n\n### Database\n\n- The procedure is related to the database using the below files: \n\n| File Name  | Type | Usage | Description |\n|------------|------|--------|-------------|\n| `PROVIDE1` | `PF` (Physical File) | Read | Stores provider details |\n\n## Usage Example\n\n- The procedure can be used in the RPGLE program as below:\n\n```rpgle\n        D validProvider   S              n\n        D providerID      S              5P 0\n\n        providerID = 12345;\n        validProvider = ExistProvider(providerID);\n\n        If validProvider;\n        dsply 'Provider Exists';\n        Else;\n        dsply 'Provider Not Found or Deleted';\n        Endif;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_ExistProvider/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"api"}}
{"id":"PRO300_ExistProvider_how","input_data":"     P ExistProvider   B                     export\n     D ExistProvider   PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return %found(provide1) and prdel <> 'X';\n      /end-free\n     p ExistProvider   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"- The ILE RPG procedure `ExistProvider` checks whether a provider exists in the `PROVIDE1` file and ensures it is not marked as deleted.\n\n### 1. Procedure Definition\n```rpgle\n        P ExistProvider   B                     export\n        D ExistProvider   PI              n\n        D P_PRID                         5P 0  value\n```\n- `ExistProvider` is defined as a procedure with the `export` keyword, making it available for use outside this module.\n- The procedure returns a Boolean value (`n`), meaning `true` or `false`.\n- It takes one input parameter, `P_PRID`, which is a 5-digit packed numeric value representing the provider's ID.\n\n### 2. Calling the `chainPROVIDE1` Subprocedure\n```rpgle\n        /Free\n        chainPROVIDE1(P_PRID);\n```\n- The procedure calls `chainPROVIDE1(P_PRID)`, which is another subprocedure responsible for retrieving the provider details from the `PROVIDE1` file.\n- This ensures that the requested provider's record is loaded into memory.\n\n### 3. Checking if the Provider Exists and Is Not Deleted\n```rpgle\n        return %found(PROVIDE1) and prdel <> 'X';\n        /End-Free\n```\n- `%found(PROVIDE1)`: This built-in function checks if a record was found in the `PROVIDE1` file.\n- `prdel <> 'X'`: Ensures that the provider is not marked as deleted.\n- If the provider exists and is not deleted, the procedure returns `true`.\n- Otherwise, it returns `false`.\n\n### 4. Procedure End\n```rpgle\n        P ExistProvider   E\n```\n- The procedure ends with `E`, marking the end of its execution.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_ExistProvider/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"how"}}
{"id":"PRO300_GetProCONT_sum","input_data":"     PGetProCONT       B                     export\n     DGetProCONT       PI                  like(prcont)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCONT;\n      /end-free\n     pGetProCONT       e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"The ILE RPG procedure `GetProCONT` fetches the contact person details of a provider based on the given provider ID. It ensures quick access to the provider's contact information for business operations.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProCONT/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"sum"}}
{"id":"PRO300_GetProCONT_api","input_data":"     PGetProCONT       B                     export\n     DGetProCONT       PI                  like(prcont)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCONT;\n      /end-free\n     pGetProCONT       e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"## Purpose\n\nThe fixed declarations free-format ILE RPG procedure `GetProCONT` retrieves the contact person (`PRCONT`) associated with a given provider ID (`P_PRID`) from the `PROVIDE1` file.  \n\n## Parameters  \n\n| Parameter Name | Data Type | Length | Usage  | Description                              |\n|--------------|-----------|--------|--------|------------------------------------------|\n| `P_PRID`    | Packed    | 5,0    | Input  | Provider ID used to fetch contact details. |\n\n## Return Value\n\n| Data Type | Length | Description                              |\n|-----------|--------|------------------------------------------|\n| Alphanumeric | 30  | Name of the contact person |\n\n## Impacts  \n\n### Dependencies  \n\n- The following subprocedures are used in `GetProCONT`:  \n\n| Subprocedure Name  | Description |\n|--------------------|-------------|\n| `chainPROVIDE1`   | Fetches provider details from `PROVIDE1` using `P_PRID`. |\n\n### Database Interactions  \n\n- The procedure reads from the following database file:  \n\n| File Name  | Type | Usage | Description |\n|------------|------|--------|-------------|\n| `PROVIDE1` | `LF` (Logical File) | Read | Logical view over the provider master physical file, used to retrieve provider details based on keyed access. |\n\n## Error Handling  \n\n- If the `P_PRID` is not found in `PROVIDE1`, the procedure will return a blanks.  \n\n## Usage Example  \n\n```rpgle\n      D ProviderContact   S            like(PRCONT)\n      D providerID        S              5P 0\n      \n      providerID = 12345;\n      ProviderContact = GetProCONT(providerID);\n      \n      dsply ProviderContact;\n```\n\n- In this example, `GetProCONT` retrieves the contact person (`PRCONT`) for the given provider ID (`P_PRID`) and displays it.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProCONT/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"api"}}
{"id":"PRO300_GetProCONT_how","input_data":"     PGetProCONT       B                     export\n     DGetProCONT       PI                  like(prcont)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCONT;\n      /end-free\n     pGetProCONT       e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"The fixed declarations free-formats ILE RPG procedure `GetProCONT` retrieves the contact person details (`PRCONT`) of a provider based on the given provider ID (`P_PRID`).\n\n### 1. Procedure Definition\n\n```rpgle\n     PGetProCONT       B                     export\n     DGetProCONT       PI                  like(prcont)\n     D P_PRID                         5P 0  value\n```\n\n- Defines `GetProCONT` as an exported procedure, making it accessible from other modules.    \n- Declares the procedure interface (PI) and specifies that the return type is the same type as `PRCONT` which is a 30 character alphanumeric.\n- A 5-digit packed numeric parameter used as the provider ID.  \n- The `value` keyword ensures that the argument is passed by value (a copy is used instead of modifying the original variable).  \n\n### 2. Calling the `chainPROVIDE1` Subprocedure\n\n```rpgle\n      /free\n         chainPROVIDE1(P_PRID);\n```\n\n- Calls the `chainPROVIDE1(P_PRID)` subprocedure, which searches the PROVIDE1 file for a record where the key (`P_PRID`) matches the given provider ID.  \n- If a matching record is found, all its fields (including `PRCONT`) are loaded into memory.  \n- If no matching record exists, the values are cleared.\n\n### 3. Returning the Contact Person\n\n```rpgle\n         return PRCONT;\n```\n\n- The procedure returns `PRCONT`, which stores the contact persons name for the given provider.  \n- If `P_PRID` exists in `PROVIDE1`, `PRCONT` contains the valid contact persons name.  \n- If `P_PRID` does not exist, `PRCONT` will contain blanks.\n\n### 4. Procedure End\n\n```rpgle\n      /end-free\n     PGetProCONT       e\n```\n\n- The procedure ends with `e`, marking the end of its execution.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProCONT/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"how"}}
{"id":"PRO300_GetProCountry_sum","input_data":"     PGetProCountry    B                     export\n     DGetProCountry    PI                  like(prcoun)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCOUN;\n      /end-free\n     pGetProCountry    e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"The column-limited free-format procedure `GetProCountry` retrieves the country code `PRCOUN` from a file named `PROVIDE1` based on a given provider ID `P_PRID`. It ensures accurate provider location identification for business operations.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProCountry/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4lf","scope":"proc","depth":"sum"}}
{"id":"PRO300_GetProCountry_api","input_data":"     PGetProCountry    B                     export\n     DGetProCountry    PI                  like(prcoun)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCOUN;\n      /end-free\n     pGetProCountry    e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"#### Purpose  \nThis procedure `GetProCountry` retrieves a country code `PRCOUN` from a file named `PROVIDE1` based on a provider ID.\nTo return the value of `PRCOUN` (a country code) for a given provider ID (`P_PRID`) by looking it up in the file `PROVIDE1`.  \n\n##### Parameters  \n- This procedure has one input parameter.  \n\n| Name     | Data Type        | Length | Usage         | Description                             |  \n|----------|------------------|--------|---------------|-----------------------------------------|  \n| `P_PRID` | Packed Decimal   | 5, 0   | Input (value) | The unique identifier for the provider. |  \n\n##### Dependencies  \nBelow mentioned objects needs to be in the library list.\n- `chainPROVIDE1` - Sub procedure Retrieves the provider record from the `PROVIDE1` file using the provider ID (`P_PRID`).   \n- `PROVIDE1` - Database file Stores provider details, including provider country.   \n\n##### Usage Example  \n- Calling `GetProCountry` in the RPGLE Program  \n- Below is an example of how the `GetProCountry` procedure is called.  \n```rpgle\n        D ProviderCountry  S           like(prcoun)\n        D ProviderID       S           5P 0\n        /Free\n        ProviderID = 10001;\n        ProviderCountry = GetProCountry(ProviderID);\n        dsply ProviderCountry;\n        /End-Free\n```  \n- `ProviderID` is assigned a value (e.g., `10001`).  \n- The `GetProCountry` procedure is called with `ProviderID` as an argument.  \n- The returned provider country is stored in `ProviderCountry`.  \n- The `dsply` operation displays the provider country.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProCountry/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4lf","scope":"proc","depth":"api"}}
{"id":"PRO300_GetProCountry_how","input_data":"     PGetProCountry    B                     export\n     DGetProCountry    PI                  like(prcoun)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRCOUN;\n      /end-free\n     pGetProCountry    e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"The column-limited free-format procedure `GetProCountry` looks up a record in the `PROVIDE1` file using a provider ID (`P_PRID`) and returns the associated country code (`PRCOUN`).\n\n1. Definition of Procedure \n```rpgle\n     PGetProCountry    B                     export \n```\n- The `GetProCountry` procedure is defined using the fixed `P` specification with a `B` in column 24.\n- The `export` keyword indicates that this procedure can be accessed from outside this module.\n\n2. Procedure Interface\n```rpgle\n     DGetProCountry    PI                  like(prcoun)\n     D P_PRID                         5P 0  value\n```\n- Procedure interface (`PI`) specifies the return type and input parameters.\n- *Return Type:* `like(prcoun)`, meaning it returns the providers country.\n- *Input Parameter:*  \n  - `P_PRID (5P 0 value)`: A 5-digit packed decimal number representing the provider ID.\n\n3. Retrieve Provider Country\n```rpgle\n     /free\n        chainPROVIDE1(P_PRID);\n```\n- It calls the `chainPROVIDE1` function to search for the provider record in the `PROVIDE1` file using the given `P_PRID`.\n- `chainPROVIDE1(P_PRID);` attempts to locate the provider record in the `PROVIDE1` file.\n- If a matching record is found, the relevant provider fields becomes available.\n\n4. Return the Provider Country\n```rpgle\n        return PRCOUN;\n```\n- After successfully fetching the record, the procedure returns the providers country (`PRCOUN`).\n\n5. End the Procedure\n```rpgle\n     /end-free\n     PGetProCountry    e\n```\n- The `GetProCountry` procedure is terminated with the `PGetProCountry e` statement.\n- This structure ensures that the provider's country is efficiently retrieved and returned based on the given provider ID.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProCountry/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4lf","scope":"proc","depth":"how"}}
{"id":"PRO300_GetProName_sum","input_data":"     PGetProName       B                     export\n     DGetProName       PI                  like(provnm)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PROVNM;\n      /end-free\n     pGetProName       e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"This ILE RPG procedure `GetProName` retrieves the name of a provider based on the given provider ID.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProName/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"sum"}}
{"id":"PRO300_GetProName_api","input_data":"     PGetProName       B                     export\n     DGetProName       PI                  like(provnm)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PROVNM;\n      /end-free\n     pGetProName       e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"## Purpose\n- The ILE RPG procedure `GetProName` with free-format calcs retrieves the name of a provider based on a given provider ID.\n\n## Parameters\n- The procedure has the following parameters:\n\n| Name   | Data Type | Length | Usage  | Description |\n|--------|----------|--------|--------|-------------|\n| `P_PRID` | Packed Decimal | 5, 0 | Input (value) | The unique identifier for the provider. |\n\n## Return Value\n\nThe name of the provider associated with the given provider id is returned as 30 character alphanumeric.\nIf no record is found associated with the given provider id, the the return value will be all blanks.\n\n### Database\n\n- The procedure is related to the below files in the database\n\n| File Name | Type | Usage | Description |\n|-----------|------|--------|-------------|\n| `PROVIDE1` | `PF` | Read | Stores provider details, including provider name (`PROVNM`). |\n\n## Usage Example\n\n- Calling `GetProName` in the RPGLE Program\n- Below is an example of how the `GetProName` procedure is called.\n\n```rpgle\n        D ProviderName    S           like(provnm)\n        D ProviderID      S           5P 0\n\n        /Free\n        ProviderID = 10001;\n        ProviderName = GetProName(ProviderID);\n        dsply ProviderName;\n        /End-Free\n```\n\n- `ProviderID` is assigned a value (e.g., `10001`).\n- The `GetProName` procedure is called with `ProviderID` as an argument.\n- The returned provider name is stored in `ProviderName`.\n- The `dsply` operation displays the provider name.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProName/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"api"}}
{"id":"PRO300_GetProName_how","input_data":"     PGetProName       B                     export\n     DGetProName       PI                  like(provnm)\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PROVNM;\n      /end-free\n     pGetProName       e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"- The ILE RPG procedure `GetProName` with free-format calcs retrieves the name of a provider based on a given provider ID. Below is a detailed breakdown of how it works.\n\n### 1. Procedure Definition\n\n- The procedure is defined using the `PGetProName` block. The `export` keyword indicates that this procedure can be called from outside this module.\n\n```rpgle\n        PGetProName       B                     export\n```\n\n### 2. Define the Procedure Interface\n\n- The procedure interface (`PI`) specifies the return type and input parameters.\n\n```rpgle\n        DGetProName       PI                  like(provnm)\n        D P_PRID                         5P 0  value\n```\n\n- Return Type: `like(provnm)`, meaning it returns the provider's name.\n- Input Parameter:  \n  - `P_PRID (5P 0 value)`: A 5-digit packed decimal number representing the provider ID.\n\n### 3. Retrieve Provider Name\n- The procedure calls the `chainPROVIDE1` subprocedure to search for the provider record in the `PROVIDE1` file using the given `P_PRID`.\n\n```rpgle\n        /Free\n        chainPROVIDE1(P_PRID);\n```\n\n- `chainPROVIDE1(P_PRID);` searches for the provider record.\n- If found, the corresponding provider fields are loaded.\n\n### 4. Return the Provider Name\n- After fetching the record, the procedure returns the provider's name (`PROVNM`).\n\n```rpgle\n        return PROVNM;\n        /End-Free\n```\n\n### 5. End the Procedure\n- The procedure ends with the `PGetProName e` statement.\n\n```rpgle\n        PGetProName       e\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_GetProName/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"how"}}
{"id":"PRO300_IsProDeleted_sum","input_data":"     PIsProDeleted     B                     export\n     DIsProDeleted     PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRDEL = 'X';\n      /end-free\n     pIsProDeleted     e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"The column-limited free-format ILE RPG procedure `IsProDeleted` checks whether a provider is marked as deleted by verifying if the `PRDEL` field is set to 'X' ensuring accurate provider status validation.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_IsProDeleted/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"sum"}}
{"id":"PRO300_IsProDeleted_api","input_data":"     PIsProDeleted     B                     export\n     DIsProDeleted     PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRDEL = 'X';\n      /end-free\n     pIsProDeleted     e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"## Purpose\n\nThe column-limited free-format ILE RPG procedure `IsProDeleted` checks whether a provider exists in the `PROVIDE1` file and is marked as deleted (`PRDEL = 'X'`). This helps prevent further processing of deleted provider records.  \n\n## Parameters\n\n| Parameter Name | Data Type | Length | Usage  | Description  |\n|--------------|-----------|--------|--------|-------------|\n| `P_PRID`    | Packed Decimal (P)    | 5,0    | Input  | Provider ID to check for deletion status. |\n\n## Return Value\n\nBoolean indicating whether the provider with the given provider id has been marked deleted using the `PRDEL = 'X'`.\n\n### Database Interaction\n\nThe procedure interacts with the following database file:  \n\n| File Name  | Type | Usage | Description |\n|------------|------|--------|-------------|\n| `PROVIDE1` |  PF | Read | Stores provider details, including deletion status `PRDEL`. |\n\n## Usage Example\n\n```rpgle\n     D ProviderDeleted  S               n\n     D ProviderID       S             5P 0\n\n      /free\n         // Assign a provider ID\n         ProviderID = 10023;  \n\n         // Check if the provider is deleted\n         ProviderDeleted = IsProDeleted(ProviderID);\n\n         // Display the result\n         if ProviderDeleted;\n            dsply ('Provider is deleted.');\n         else;\n            dsply ('Provider is active.');\n         endif;\n      /end-free\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_IsProDeleted/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"api"}}
{"id":"PRO300_IsProDeleted_how","input_data":"     PIsProDeleted     B                     export\n     DIsProDeleted     PI              n\n     D P_PRID                         5P 0  value\n      /free\n         chainPROVIDE1(P_PRID\n               );\n         return PRDEL = 'X';\n      /end-free\n     pIsProDeleted     e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn","output":"The ILE RPG procedure `IsProDeleted` checks whether a provider is marked as deleted in the `PROVIDE1` file.This helps in preventing operations on deleted providers and ensures data integrity.\n\n### Control Flow\n\n1. Retrieve Provider Record  \n   - Calls `chainPROVIDE1(P_PRID)` to fetch the provider record from `PROVIDE1`.  \n\n2. Check Deletion Status  \n   - The `PRDEL` field is checked:  \n     - If `PRDEL = 'X'`, the provider is considered deleted.  \n     - If `PRDEL` is blank or another value, the provider is considered active.  \n\n3. Return Deletion Status\n   - Returns the character value of the PRDEL field from PROVIDE1.\n     - 'X' indicates the provider is deleted.\n     - Blank (' ') indicates the provider is active.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_IsProDeleted/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"how"}}
{"id":"PRO300_chainPROVIDE1_sum","input_data":"     p chainPROVIDE1   b\n     d chainPROVIDE1   pi\n     D P_PRID                         5P 0  value\n      /free\n        if not %open(PROVIDE1);\n          open PROVIDE1;\n        endif;\n         if P_PRID <> PRID;\n           K_PRID =  P_PRID;\n           clear *all FPROV;\n           chain kf PROVIDE1;\n         endif;\n      /end-free\n     p chainPROVIDE1   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn\n     D K_PRID          S                   LIKE(PRID)","output":"This procedure is used to retrieve records from the `PROVIDE1` file based on a dynamic key `P_PRID` (representing the provider id) and is used to fetch data record.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_chainPROVIDE1/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"sum"}}
{"id":"PRO300_chainPROVIDE1_api","input_data":"     p chainPROVIDE1   b\n     d chainPROVIDE1   pi\n     D P_PRID                         5P 0  value\n      /free\n        if not %open(PROVIDE1);\n          open PROVIDE1;\n        endif;\n         if P_PRID <> PRID;\n           K_PRID =  P_PRID;\n           clear *all FPROV;\n           chain kf PROVIDE1;\n         endif;\n      /end-free\n     p chainPROVIDE1   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn\n     D K_PRID          S                   LIKE(PRID)","output":"## Purpose\n\nThis ILE RPG procedure `chainPROVIDE1` is used to retrieve a record from the database file `PROVIDE1` using a given key `P_PRID`. Before performing the `CHAIN` operation, it ensures that the file `PROVIDE1` is open. If the provided key is different from the currently loaded record key `PRID`, it clears all fields of the file buffer, sets the key value, and performs the `CHAIN` to load the corresponding data into memory.\n\n## Parameters  \n\nThis procedure accepts the following input parameter:\n\n| Parameter Name | Type  | Attributes | Description                                                                         |\n|----------------|-------|------------|-------------------------------------------------------------------------------------|\n| `P_PRID`       | PACKED(5 0) | `value`    | Packed numeric value passed by value used as a key to fetch a specific record from the `PROVIDE1` file. |\n\n## Dependencies\n\n- `PROVIDE1`  Database physical or logical file containing the records to be retrieved using key `PRID`. It must be declared in the RPG program.\n\n## File Handling  \n\nThe following file is accessed in this procedure:\n\n| File Name  | Access Type | Description                                                    |\n|------------|-------------|----------------------------------------------------------------|\n| `PROVIDE1` | Keyed Input  | File from which data is retrieved using the `CHAIN` operation |\n\n## Indicators  \n\nThis procedure does not explicitly use any indicators.  \n\n## Usage Example  \n\nThis procedure `chainPROVIDE1` is invoked as mentioned below:\n\n```rpgle\n        chainPROVIDE1(PRID); // Retrieves the record from PROVIDE1 where PRID = 10001\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_chainPROVIDE1/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"api"}}
{"id":"PRO300_chainPROVIDE1_how","input_data":"     p chainPROVIDE1   b\n     d chainPROVIDE1   pi\n     D P_PRID                         5P 0  value\n      /free\n        if not %open(PROVIDE1);\n          open PROVIDE1;\n        endif;\n         if P_PRID <> PRID;\n           K_PRID =  P_PRID;\n           clear *all FPROV;\n           chain kf PROVIDE1;\n         endif;\n      /end-free\n     p chainPROVIDE1   e","context":"pro300.rpgle:\n     FPROVIDE1  if   e           k disk    usropn\n     D K_PRID          S                   LIKE(PRID)","output":"#### Purpose\n\nThis fixed-form ILE RPG procedure `chainPROVIDE1` accesses the physical file `PROVIDE1` and retrieves a specific provider record based on a passed-in provider ID `P_PRID`. If the file is not already open, it opens the file. It then checks if the current ID is different from the last retrieved one and performs a keyed chain to retrieve the record.\n\n#### Global Variables  \n\nThe following global fields/variables are used in this procedure:\n\n| Variable/Field | Type   | Description                                                                 |\n|----------------|--------|-----------------------------------------------------------------------------|\n| `PRID`         | 5P 0   | Field in file `PROVIDE1` representing the primary key of the current record |\n| `K_PRID`       | 5P 0   | Program-defined variable used to store the key used in the CHAIN operation  |\n| `FPROV`        | *ALL   | Represents the file record format. Used to clear all fields before CHAIN.   |\n\n#### Algorithm\n\n##### 1. Procedure Begins\n\nThis marks the start of the procedure named `chainPROVIDE1` with a single numeric parameter representing the provider id that the database should be positioned to.\n\n- `pi` indicates the procedure interface.\n- `D` This denotes a definition specification D-spec line in fixed-format RPG. It's used to define variables, constants, parameters, data structures, etc.\n  - `P_PRID` This is the name of the parameter. It's the identifier that the procedure will use internally to refer to the value being passed in.\n    - `5P 0` This is the data type and length:\n      - `5P` means it is a packed decimal field with a total of 5 digits.\n      - `0` means there are 0 decimal places (it's a whole number).\n  - `value` This keyword indicates call by value.\n\n- The parameter is passed by value, not by reference. That means a copy of the data is passed into the procedure, and any changes made to it inside the procedure do not affect the original value outside.\n\n```rpgle\n     p chainPROVIDE1   b\n     d chainPROVIDE1   pi\n     D P_PRID                         5P 0  value\n```\n\n##### 2. Check and Open File\n\n- Verifies whether the file `PROVIDE1` is open.\n- Opens it only if not already open to avoid runtime error.\n\n```rpgle\n      /free\n        if not %open(PROVIDE1);\n          open PROVIDE1;\n        endif;\n```\n\n##### 3. Retrieve Record if Needed\n\n- Compares passed-in `P_PRID` with the last used ID `PRID`\n- If different, prepares the key and clears related fields `FPROV`\n- Then, performs a keyed chain operation to retrieve the matching record from `PROVIDE1`\n\n```rpgle\n         if P_PRID <> PRID;\n           K_PRID =  P_PRID;\n           clear *all FPROV;\n           chain kf PROVIDE1;\n         endif;\n```\n\n##### 4. Procedure Ends\n\n- Marks the end of the procedure.\n- Control returns to the caller.\n\n```rpgle\n      /end-free\n     p chainPROVIDE1   e\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/PRO300_chainPROVIDE1/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fc","scope":"proc","depth":"how"}}
{"id":"Rpgle_main_subr_sum","input_data":"**free\n        dcl-f qprint printer(80);\n        dcl-f staff;\n\n        dcl-ds prtds len(80) end-ds;\n\n        read staff;\n         dow not %eof;\n           exsr get_info;\n             write qprint prtds;\n           read staff;\n         enddo;\n        *inlr = *on;\n\n        begsr get_info;\n           prtds = %trim(name)\n                 + ' has been working for '\n                 + %char(years)\n                 + ' years.';\n        endsr;","context":"main_subr.rpgle:\n        dcl-f qprint printer(80);\n        dcl-f staff;\n        dcl-ds prtds len(80) end-ds;","output":"This RPGLE program reads records from `staff` file formats a message for each record, and prints it to `qprint` (a printer file). the logic for formatting the message has been moved into a subroutine `get_info`.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/Rpgle_main_subr/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"sum"}}
{"id":"Rpgle_main_subr_api","input_data":"**free\n        dcl-f qprint printer(80);\n        dcl-f staff;\n\n        dcl-ds prtds len(80) end-ds;\n\n        read staff;\n         dow not %eof;\n           exsr get_info;\n             write qprint prtds;\n           read staff;\n         enddo;\n        *inlr = *on;\n\n        begsr get_info;\n           prtds = %trim(name)\n                 + ' has been working for '\n                 + %char(years)\n                 + ' years.';\n        endsr;","context":"main_subr.rpgle:\n        dcl-f qprint printer(80);\n        dcl-f staff;\n        dcl-ds prtds len(80) end-ds;","output":"## Purpose\nThis RPGLE program reads records from a file named `staff` formats a message for each record, and prints the message to `qprint` (a printer file).\n\n\n## Parameters\nNone\n\n### Global Variables Used\nBelow mentioned global variables are used.\n\n| variable Name | datatype     | length | description                                |\n|---------------|--------------|--------|--------------------------------------------|\n| `prtds`       | alphanumeric | 80     | build string used for printing stored here |\n\n## Dependencies\nBelow mentioned objects needs to be in the library list.\n- `staff` - Database physical file used for fetching *name and years of experience*.\n- `qprint` - Report file used for printing \n\n## Expected Output example (Printed on QPRINT):\nIf the `staff` file contains:\n\n| Name\t  |   Years   |\n|---------|-----------|\n| Alice   |    \t5     |\n|Bob      |\t   10     |\n|Charlie  |\t    3     |\n\n## Output printed:\n- Alice has been working for 5 years.\n- Bob has been working for 10 years.\n- Charlie has been working for 3 years.\n\n## Why Use a Subroutine?\n- *Code Reusability*: If the message formatting logic is needed elsewhere in same RPGLE program, we can invoke the `GET_INFO` subroutine instead of rewriting the same code.\n- *Improved Readability*: The main loop focuses only on reading records, calling the subroutine, and writing output.\n- *Easier Maintenance*: If the message format needs to change, it can be modified in one place (the subroutine) instead of multiple locations.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/Rpgle_main_subr/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"api"}}
{"id":"Rpgle_main_subr_how","input_data":"**free\n        dcl-f qprint printer(80);\n        dcl-f staff;\n\n        dcl-ds prtds len(80) end-ds;\n\n        read staff;\n         dow not %eof;\n           exsr get_info;\n             write qprint prtds;\n           read staff;\n         enddo;\n        *inlr = *on;\n\n        begsr get_info;\n           prtds = %trim(name)\n                 + ' has been working for '\n                 + %char(years)\n                 + ' years.';\n        endsr;","context":"main_subr.rpgle:\n        dcl-f qprint printer(80);\n        dcl-f staff;\n        dcl-ds prtds len(80) end-ds;","output":"This fully free RPGLE program reads records from `staff` file formats a message for each record, and prints it to `qprint` (a printer file). the logic for formatting the message has been moved into a subroutine `get_info`. \n\n1. File and data structure declarations \n- declares `staff` as an input file.\n- declares `qprint` as a printer file with an 80-character line length.\n- defines `prtds` an 80-character data structure that holds the formatted message before printing.\n```rpgle\n        dcl-f staff;\n        dcl-f qprint printer(80);\n        dcl-ds prtds len(80) end-ds;\n```\n2.  Reading the `staff` file and processing each record\n- reads the first record from `staff`\n- loops through the `staff` file until the end-of-file (EOF) is reached.\n- calls the subroutine `get_info`, which formats the message.\n```rpgle\n         read staff;\n          dow not %eof;\n            exsr get_info;\n```\n3. Inside the loop \n- It writes the message to the printer file `qprint`.\n- It reads the next record from `staff`.\n- After processing all records, it sets *last record indicator as On* to indicate the program has finished execution.\n```rpgle\n        write qprint prtds;\n          read staff;\n         enddo;\n        *inlr = *on;\n```\n4. process subroutine `get_info`\n- Begins the subroutine `get_info` \n- %trim(`name`)  Removes extra spaces from the `name` field.\n- %char(`years`)  Converts the numeric `years` field to a character format.\n- The entire string is concatenated to form a readable sentence.\n- Ends the subroutine `get_info`\n```rpgle\n        begsr get_info;\n          prtds = %trim(name)\n               + ' has been working for '\n               + %char(years)\n               + ' years.';\n        endsr;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/Rpgle_main_subr/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"how"}}
{"id":"helloworld_sum","input_data":"**free\ndsply 'hello world';\nreturn;","context":"","output":"The fully free-form ILE RPG program displays the message 'hello world'.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/helloworld/output/sum_output.md","task":"explain","difficulty":0,"language":"rpg4ff","scope":"file","depth":"sum"}}
{"id":"helloworld_api","input_data":"**free\ndsply 'hello world';\nreturn;","context":"","output":"The fully free-form ILE RPG program displays the message 'hello world' to the 5250 workstation \nthat invoked the interactive program.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/helloworld/output/api_output.md","task":"explain","difficulty":0,"language":"rpg4ff","scope":"file","depth":"api"}}
{"id":"helloworld_how","input_data":"**free\ndsply 'hello world';\nreturn;","context":"","output":"The fully free-form ILE RPG program displays the message\n'hello world' to the 5250 workstation that invoked the interactive program.\n\n```rpgle\n**free\ndsply 'hello world';\nreturn;\n```\n\nThe `**free` marks this a fully free ILE RPG program with no column restrictions.\nThe [DSPLY opcode](https://www.ibm.com/docs/api/v1/content/ssw_ibm_i_75/rzasd/zzdsply.htm#zzdsply ) is used.\n\nThe 'hello world' parameter is the message which will be sent.\nThe `return` opcode ends the program.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/IBM/helloworld/output/how_output.md","task":"explain","difficulty":0,"language":"rpg4ff","scope":"file","depth":"how"}}
{"id":"CMFILE1_sum","input_data":"**Free\n// PROJECT NAME: CMFILE\n// THE PURPOSE OF THIS PROJECT IS TO IMPLEMENT VARIOUS CHARACTER\n// FUNCTIONS TO THE PROGRAM.\n//---------------------------------Control options\nCtl-opt Option(*Nodebugio);\n//---------------------------------File Declarations\nDcl-f CSCSTP   Disk       Usage(*Input);\nDcl-f CMPRT1   Printer Usage(*Output) Oflind(Endofpage);\n\n//---------------------------------Constant declarations\nDcl-c Editp '0(   )   -    ';\nDcl-c Editz '(0''     -    '')';\n\nDcl-c Lowercase 'abcdefghijklmnopqrstuvwxyz';\nDcl-c Uppercase 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n//---------------------------------Data Structure declarations\n\n\n//---------------------------------Standalone variable declarations\nDcl-s PHONE    ZONED(11:0);\nDcl-s MyDate   VarChar (8);\nDcl-s USERNO   CHAR (6);\nDcl-s RUFFN    CHAR (10);\nDcl-s RUFLN    CHAR (15);\nDcl-s RFFN     CHAR (1);\nDcl-s RFLN     CHAR (1);\nDcl-s NUMZIP   PACKED (9:0);\n\nDcl-s Endofpage Ind Inz(*On);\n\n//---------------------------------Main Procedure\nRead CSCSTP;\nDow Not %Eof;\n/////////////////////////////Convert name and charactes to correct case\nRUFFN = %XLATE(Uppercase:Lowercase:CFNAME);\nRUFLN = %XLATE(Uppercase:Lowercase:CLNAME);\nRFFN = %XLATE(Lowercase:Lowercase:RUFFN);\nRFLN = %XLATE(Lowercase:Lowercase:RUFLN);\nUSERNO = %Char(CUSTNO);      //Convert Custno to a string\n\nUSERID = %Trim(RUFFN)+ '.' + %Trim(RUFLN)+ '.' + USERNO;  //Define User ID\n\n\nPASSWORD = %Trim(RFFN) + %Trim(RFLN) + USERNO + '!';    //Generate Password\n\n//////////////////////Generates a Name\nNAME = %XLATE(Lowercase:Uppercase:RFFN) + %Trim(%Subst(RUFFN:2)) + ' '\n+ %XLATE(Lowercase:Uppercase:RFLN)+ %Trim(%Subst(RUFLN:2));\n\n\nNUMZIP = %DEC(CZIP:9:0);\nFINZIP = %Editw(NUMZIP:('     -    '));\n\nPHONE = CPHONE;\nFRMTPH = %Editw(PHONE:Editp);\n\n///////////////////////////////Pulls the 4 year date from the string\nMyDate = %Char(ORDDAT);\nBALANCE = %Editc(BALDUE:'J':*Cursym);\n\nIF %LEN(MyDate) = 7;\n  YearOut = %SUBST(MyDate:4:4);\nELSE;\n  YearOut = %SUBST(MyDate:5:4);\nENDIF;\n\nIf Endofpage;\n\n  Write HEADINGS;\n  Endofpage = *off;\nEndif;\nWrite DETAIL;\nRead CSCSTP;\nEnddo;\n*Inlr = *On;\nreturn;","context":"","output":"This fully free form ILE RPG will loop through the customer master file (CSCSTP) and\nprint out the formatted customer info to a report using the externally described PRTF (CMPRT1).","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/JacobAnderson/CMFILE1/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"sum"}}
{"id":"CMFILE1_api","input_data":"**Free\n// PROJECT NAME: CMFILE\n// THE PURPOSE OF THIS PROJECT IS TO IMPLEMENT VARIOUS CHARACTER\n// FUNCTIONS TO THE PROGRAM.\n//---------------------------------Control options\nCtl-opt Option(*Nodebugio);\n//---------------------------------File Declarations\nDcl-f CSCSTP   Disk       Usage(*Input);\nDcl-f CMPRT1   Printer Usage(*Output) Oflind(Endofpage);\n\n//---------------------------------Constant declarations\nDcl-c Editp '0(   )   -    ';\nDcl-c Editz '(0''     -    '')';\n\nDcl-c Lowercase 'abcdefghijklmnopqrstuvwxyz';\nDcl-c Uppercase 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n//---------------------------------Data Structure declarations\n\n\n//---------------------------------Standalone variable declarations\nDcl-s PHONE    ZONED(11:0);\nDcl-s MyDate   VarChar (8);\nDcl-s USERNO   CHAR (6);\nDcl-s RUFFN    CHAR (10);\nDcl-s RUFLN    CHAR (15);\nDcl-s RFFN     CHAR (1);\nDcl-s RFLN     CHAR (1);\nDcl-s NUMZIP   PACKED (9:0);\n\nDcl-s Endofpage Ind Inz(*On);\n\n//---------------------------------Main Procedure\nRead CSCSTP;\nDow Not %Eof;\n/////////////////////////////Convert name and charactes to correct case\nRUFFN = %XLATE(Uppercase:Lowercase:CFNAME);\nRUFLN = %XLATE(Uppercase:Lowercase:CLNAME);\nRFFN = %XLATE(Lowercase:Lowercase:RUFFN);\nRFLN = %XLATE(Lowercase:Lowercase:RUFLN);\nUSERNO = %Char(CUSTNO);      //Convert Custno to a string\n\nUSERID = %Trim(RUFFN)+ '.' + %Trim(RUFLN)+ '.' + USERNO;  //Define User ID\n\n\nPASSWORD = %Trim(RFFN) + %Trim(RFLN) + USERNO + '!';    //Generate Password\n\n//////////////////////Generates a Name\nNAME = %XLATE(Lowercase:Uppercase:RFFN) + %Trim(%Subst(RUFFN:2)) + ' '\n+ %XLATE(Lowercase:Uppercase:RFLN)+ %Trim(%Subst(RUFLN:2));\n\n\nNUMZIP = %DEC(CZIP:9:0);\nFINZIP = %Editw(NUMZIP:('     -    '));\n\nPHONE = CPHONE;\nFRMTPH = %Editw(PHONE:Editp);\n\n///////////////////////////////Pulls the 4 year date from the string\nMyDate = %Char(ORDDAT);\nBALANCE = %Editc(BALDUE:'J':*Cursym);\n\nIF %LEN(MyDate) = 7;\n  YearOut = %SUBST(MyDate:4:4);\nELSE;\n  YearOut = %SUBST(MyDate:5:4);\nENDIF;\n\nIf Endofpage;\n\n  Write HEADINGS;\n  Endofpage = *off;\nEndif;\nWrite DETAIL;\nRead CSCSTP;\nEnddo;\n*Inlr = *On;\nreturn;","context":"","output":"This fully free form ILE RPG will loop through the customer master file (CSCSTP) and\nprint out the formatted customer info to a report using the externally described PRTF (CMPRT1).\n\nThe HEADER PRTF record will be printed out when the page overflows using the *Endofpage* indicator.\n\nFor each record in the Customer Master File the DETAIL PRTF record will be written to the report.\nThis record will formatted values of the customer record.\nA number of fields in the customer records will be formatted for the report:\n\n- User ID: Concatenate the customer's first and last names (converted to lowercase) with their customer number\n- Password: Create using the first initial (lowercase), the last initial (lowercase), the customer number, and an exclamation mark\n- Name: Format the customer's first and last names with only the first letter of each name in uppercase and a single space in between\n- Zip Code: Format with the - separator after the first five digits\n- Phone Number:  Format into the `(123) 456-7890` format\n- Balance Due: Format with have comma thousand delimiter and a '-' for negative balances\n- Order Date: The 4 digit year will be extracted from the order date.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/JacobAnderson/CMFILE1/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"api"}}
{"id":"CheckDate_sum","input_data":"**free\n        dcl-s fechaNumerica packed(7:0);\n        dcl-s fechaISO  date;\n        dcl-s wFecha    zoned(8:0);\n        dcl-s fechaISO2 date;\n\n        fechaNumerica = 1240915; // Suponiendo que el campo numrico contiene el valor 1230915\n\n        fechaISO = %date(%char(fechaNumerica):*cymd0);\n\n        dsply %char(fechaISO : *ISO); // Mostrar la fecha convertida en formato *ISO\n\n        wFecha = 20241104;\n        FechaIso2 = %date(%Editc(wfecha:'X'):*iso);\n\n        *inlr = *on;","context":"","output":"This ILE RPG program demonstrates the conversion between a numeric date representation and an ISO date format, showcasing the use of built-in functions for date manipulation.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/KindSoftw/CheckDate/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"sum"}}
{"id":"CheckDate_api","input_data":"**free\n        dcl-s fechaNumerica packed(7:0);\n        dcl-s fechaISO  date;\n        dcl-s wFecha    zoned(8:0);\n        dcl-s fechaISO2 date;\n\n        fechaNumerica = 1240915; // Suponiendo que el campo numrico contiene el valor 1230915\n\n        fechaISO = %date(%char(fechaNumerica):*cymd0);\n\n        dsply %char(fechaISO : *ISO); // Mostrar la fecha convertida en formato *ISO\n\n        wFecha = 20241104;\n        FechaIso2 = %date(%Editc(wfecha:'X'):*iso);\n\n        *inlr = *on;","context":"","output":"#### 1. Program Summary\n\nThis ILE RPG program demonstrates the conversion between a numeric date representation and an ISO date format, showcasing the use of built-in functions for date manipulation.\n\n#### 2. Inputs and outputs of the provided program\n\nThere are no input or output parameters or return value for this program\n\n#### 3. Side effects of the provided program\n\nThe global variables `fechaISO` and `fechaISO2` are computed as ISO dates and displayed on the screen using the `dsply` opcode.\n\n#### 8. Dependencies of the provided procedure\n\nThe `CheckDate` procedure, as it stands, has no dependencies on other procedures or modules or QSYS objects since it doesn't call or reference any external functions, procedures, or resources.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/KindSoftw/CheckDate/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"api"}}
{"id":"CheckDate_how","input_data":"**free\n        dcl-s fechaNumerica packed(7:0);\n        dcl-s fechaISO  date;\n        dcl-s wFecha    zoned(8:0);\n        dcl-s fechaISO2 date;\n\n        fechaNumerica = 1240915; // Suponiendo que el campo numrico contiene el valor 1230915\n\n        fechaISO = %date(%char(fechaNumerica):*cymd0);\n\n        dsply %char(fechaISO : *ISO); // Mostrar la fecha convertida en formato *ISO\n\n        wFecha = 20241104;\n        FechaIso2 = %date(%Editc(wfecha:'X'):*iso);\n\n        *inlr = *on;","context":"","output":"#### Purpose\n\nThis code demonstrates the conversion between numeric representations of dates and ISO-format dates, highlighting the use of the `%date` and `%editc` functions for these conversions, which are common tasks when dealing with date manipulation in RPGLE programs.\n\n#### Implementation\n\n1. The provided RPGLE (RPG IV) code begins with the declaration of several variables used to handle dates. These variables are:\n   - `fechaNumerica`: A packed decimal variable with a length of 7 digits and no decimal places, intended to store a numeric representation of a date.\n   - `fechaISO`: A date-type variable that will hold a date value.\n   - `wFecha`: A numeric variable with a length of 8 digits and no decimal places, presumably intended to store a numeric date value in a different format.\n   - `fechaISO2`: A date-type variable similar to `fechaISO`.\n\n2. The numeric date value `1230915` is assigned to `fechaNumerica`. This assumes that the numeric field contains a date represented by the number of days since January 1, 0001, which is a common practice in some systems.\n\n3. The `%date` built-in function converts the `fechaNumerica` value into a `date` data type, formatted as `*cymd0`, which represents the date as `CCYYMMDD`. The result is stored in `fechaISO`.\n\n4. The `dsply` operation displays the date stored in `fechaISO` in the ISO format (`YYYY-MM-DD`). The `%char` function converts the date to a character string, and the `*ISO` option specifies the output format.\n\n5. The variable `wFecha` is assigned the value `20241104`, which represents a specific date.\n\n6. The `%editc` function formats the numeric date value in `wFecha` into a character string using the `X` edit code, which produces a 8-digit date in the format `YYMMDD`. The result is then converted to a date using the `%date` function, and the resulting date is stored in `fechaISO2`.\n\n7. The program ends with setting the `*inlr` indicator to `*on`, which signifies that the program should perform cleanup operations and then terminate.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/KindSoftw/CheckDate/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"how"}}
{"id":"ADMDASHRPG_Changepassword_sum","input_data":"           Dcl-Proc Changepassword ;\n             Dcl-Pi Changepassword;\n               Orgadid Char(6);\n             End-Pi;\n\n             Dow Cancel  = *Off;\n              Exfmt Changepwd ;\n\n             Select;\n\n               When Cancel  = *On;\n                    Cancel  = *Off;\n                    Offindicator(); // Call Off indicator subprocedure of change\n                    Clear Changepwd ;\n                    Leave;\n\n               Other;\n                    Changeadminpassword(); // Call change admin password subproc\n             Endsl;\n             Enddo;\n           End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"This free-form ILE RPG procedure `Changepassword` is used to update *encrypted password* for admin password for provided admin id `Orgadid` in datbase file `Loginpf`.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Changepassword/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4lf-sql","scope":"proc","depth":"sum"}}
{"id":"ADMDASHRPG_Changepassword_api","input_data":"           Dcl-Proc Changepassword ;\n             Dcl-Pi Changepassword;\n               Orgadid Char(6);\n             End-Pi;\n\n             Dow Cancel  = *Off;\n              Exfmt Changepwd ;\n\n             Select;\n\n               When Cancel  = *On;\n                    Cancel  = *Off;\n                    Offindicator(); // Call Off indicator subprocedure of change\n                    Clear Changepwd ;\n                    Leave;\n\n               Other;\n                    Changeadminpassword(); // Call change admin password subproc\n             Endsl;\n             Enddo;\n           End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"## Purpose \nThis free-form ILE RPG procedure `Changepassword` is used to update *encrypted password* for admin password for provided admin id `Orgadid` in database file `Loginpf`.\n\n## Parameters\n\n## Input  \nBelow mentioned input parameter is accepted by this procedure.\n- `Orgadid` - admin id - data type alphanumeric of length 6 bytes.\n\n## Global Variables\nNone\n\n## Dependencies \nBelow mentioned procedures are used in this procedure.\n- `Offindicator` - screen fields indicators under record format `CHANGEPWD` used for error handling were switched off.\n- `Changeadminpassword` - procedure to validate and update *encrypted password* in database file `Loginpf` for passed in parameter `Orgadid` admin id.\n\nBelow mentioned indicator and screen file record format were used in this procedure.\n- `Cancel` - named indicator for function key *f12*\n- `Changepwd` - record format of display file `admdashdsp.dspf`\n\nBelow mentioned objects need to be in the library list.\n- `Admdashdsp` - Display file object used for user input/output\n\n## Usage example \nCall procedure `Changepassword` with parameter `Orgadid` admin id.\n\n```rpgle\n        Changepassword(Orgadid);\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Changepassword/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4lf-sql","scope":"proc","depth":"api"}}
{"id":"ADMDASHRPG_Changepassword_how","input_data":"           Dcl-Proc Changepassword ;\n             Dcl-Pi Changepassword;\n               Orgadid Char(6);\n             End-Pi;\n\n             Dow Cancel  = *Off;\n              Exfmt Changepwd ;\n\n             Select;\n\n               When Cancel  = *On;\n                    Cancel  = *Off;\n                    Offindicator(); // Call Off indicator subprocedure of change\n                    Clear Changepwd ;\n                    Leave;\n\n               Other;\n                    Changeadminpassword(); // Call change admin password subproc\n             Endsl;\n             Enddo;\n           End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"## Purpose\nThis free-form ILE RPG procedure `Changepassword` is used to update *encrypted password* for admin password for provided admin id `Orgadid` in database file `Loginpf`.      \n\n## Logic\n\n### 1. Procedure interface and main loop\n\nThis procedure accepts an input parameter of alphanumeric datatype of length 6.\nUntil user presses *f12* function key display the screen under record format `Changepwd`.\n```Rpgle\n        Dcl-Pi Changepassword;\n           Orgadid Char(6);\n        End-Pi;\n\n        Dow Cancel  = *Off;\n          Exfmt Changepwd ;\n\n        Select;\n```\n### 2. Handle Cancel Key\n\nwhen *f12* key is pressed, procedure `Offindicator` is invoked to set screen fields indicators under record format `CHANGEPWD` for error handling to be switched off. Record format is cleared `Changepwd` *f12* key is switched off and exits from this procedure.\n```Rpgle\n         When Cancel  = *On;\n          Cancel  = *Off;\n          Offindicator(); // Call Off indicator subprocedure of change\n          Clear Changepwd ;\n          Leave;\n```\n\n### 3. Handle Password Change\n\nOtherwise invoke `Changeadminpassword` - procedure to validate and update *encrypted password* in database file `Loginpf` for passed in parameter `Orgadid` admin id.\n```Rpgle\n         Other;\n          Changeadminpassword(); // Call change admin password subproc\n         Endsl;\n        Enddo;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Changepassword/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4lf-sql","scope":"proc","depth":"how"}}
{"id":"ADMDASHRPG_Dltclearsubfile_sum","input_data":"           Dcl-Proc Dltclearsubfile;\n               Dmsflclr = *On;\n               Drrn = 0;\n               Write Dltorgctl;\n               Dmsflclr = *Off;\n           End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S Drrn Zoned(4);\n          Dcl-S I Zoned(2);","output":"The column-limited free-format SQLRPGLE `Dltclearsubfile` procedure clears the list by turning on a reset flag, setting the position to the start, refreshing the display, and then turning off the reset flag.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Dltclearsubfile/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4lf-sql","scope":"proc","depth":"sum"}}
{"id":"ADMDASHRPG_Dltclearsubfile_api","input_data":"           Dcl-Proc Dltclearsubfile;\n               Dmsflclr = *On;\n               Drrn = 0;\n               Write Dltorgctl;\n               Dmsflclr = *Off;\n           End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S Drrn Zoned(4);\n          Dcl-S I Zoned(2);","output":"## Purpose  \nThe column-limited free-format SQLRPGLE procedure `Dltclearsubfile` is responsible for clearing a subfile by resetting relevant control variables and writing the subfile control record. This ensures the subfile is refreshed and ready for new data.\n\n## Parameters  \n- None  \n\n## Impacts  \n\n### Global Variables  \n- The procedure uses the following global variables:  \n\n| Variable Name | Data Type | Length | Usage |  \n|--------------|----------|--------|-------|  \n| `Dmsflclr`   | `Ind`    | 1      | Controls the clearing of the subfile. Set to *ON before clearing and *OFF after. |  \n| `Drrn`       | `Packed` | 5,0    | Stores the relative record number, reset to `0` when the subfile is cleared. |  \n\n### Standalone Variables  \n- None  \n\n### Indicators  \n- The procedure uses the following Indicator Variables:  \n\n| Indicator Name | Data Type | Indicator Number | Usage |  \n|---------------|----------|------------------|-------|  \n| `Dmsflclr`    | `Ind`    | *INXX (Assumed)  | Used to clear the subfile by setting it ON before execution and OFF after. |  \n\n### Error Messages  \n- None  \n\n## Dependencies  \n\n### Subprocedures Called  \n- None  \n\n### Database  \n| File Name  | Purpose |  \n|------------|---------|  \n| `Dltorgctl` | Subfile control record written to refresh the subfile. |  \n\n## Usage Example  \nTo call the `Dltclearsubfile` procedure inside a **column-limited RPGLE** program, use:  \n```rpgle\n       Dltclearsubfile();\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Dltclearsubfile/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4lf-sql","scope":"proc","depth":"api"}}
{"id":"ADMDASHRPG_Dltclearsubfile_how","input_data":"           Dcl-Proc Dltclearsubfile;\n               Dmsflclr = *On;\n               Drrn = 0;\n               Write Dltorgctl;\n               Dmsflclr = *Off;\n           End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S Drrn Zoned(4);\n          Dcl-S I Zoned(2);","output":"## Explanation  \n\n### 1. Declare Procedure \n- Declares the procedure `Dltclearsubfile`, which is responsible for clearing the subfile and resetting relevant fields.\n\n```rpgle\nDcl-Proc Dltclearsubfile;\n```\n\n### 2. Set Subfile Clear Indicator \n- Activates the indicator `Dmsflclr`, which is typically used to clear the subfile before repopulating it. \n\n```rpgle\nDmsflclr = *On;\n``` \n\n### 3. Reset Relative Record Number (RRN)\n- Resets the relative record number `Drrn` to zero, ensuring that the subfile starts fresh when reloaded. \n\n```rpgle\nDrrn = 0;\n```\n\n### 4. Write Control Record\n- Writes to the subfile control record `Dltorgctl`, which manages the display attributes of the subfile.\n\n```rpgle\nWrite Dltorgctl;\n```\n\n### 5. Turn Off Subfile Clear Indicator\n- Deactivates the subfile clear indicator after the operation is complete, allowing for new data to be loaded into the subfile.\n\n```rpgle\nDmsflclr = *Off;\n```\n\n### 6. End Procedure \n- Marks the end of the `Dltclearsubfile` procedure, completing the execution of subfile clearing.\n\n```rpgle\nEnd-Proc;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Dltclearsubfile/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4lf-sql","scope":"proc","depth":"how"}}
{"id":"ADMDASHRPG_EventDetails_sum","input_data":"             Dcl-Proc Eventdetails ;\n               Dcl-Pi Eventdetails ;\n                 Sevntid Char(6);\n               End-Pi;\n\n\n            Exec Sql\n                Select Evntid,Evntname,Evntdate,Artname,Evnttype,Evnttktcst,\n                       Availseats,Totalseats,Aboutevent,Evntvenue,Evnttime,\n                       Evntaddate,Evntupdate,Evntstatus\n\n                Into   :Vwid, :Vwevname, :Vwevdate, :Vwartname, :Vwevtype,\n                       :Vwtkcst, :Vwevseats, :Vwtotseats, :Vwabevnt, :Vwevvenue,\n                       :Vwevtime, :Vwevaddate, :Vwevupdate, :Vwevstatus\n                From Eventpf\n                Where Evntid = :Sevntid  ;\n              Dow Cancel  = *Off;\n               Vdetails = *On;\n               Exfmt Dsplyevnt ;\n\n                 If Cancel = *On;\n                    Vdetails = *Off;\n                    Cancel  = *Off;\n                    Reset Viwevntctl;\n                    Clear Evopt;\n                    Leave;\n                 Endif;\n              Enddo;\n          End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"This free-form RPG procedure puts up a screen showing the details of an event from table EVENTPF.The event id is specified as a parameter to the procedure. The user is only able to view the details of the event.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_EventDetails/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"ADMDASHRPG_EventDetails_api","input_data":"             Dcl-Proc Eventdetails ;\n               Dcl-Pi Eventdetails ;\n                 Sevntid Char(6);\n               End-Pi;\n\n\n            Exec Sql\n                Select Evntid,Evntname,Evntdate,Artname,Evnttype,Evnttktcst,\n                       Availseats,Totalseats,Aboutevent,Evntvenue,Evnttime,\n                       Evntaddate,Evntupdate,Evntstatus\n\n                Into   :Vwid, :Vwevname, :Vwevdate, :Vwartname, :Vwevtype,\n                       :Vwtkcst, :Vwevseats, :Vwtotseats, :Vwabevnt, :Vwevvenue,\n                       :Vwevtime, :Vwevaddate, :Vwevupdate, :Vwevstatus\n                From Eventpf\n                Where Evntid = :Sevntid  ;\n              Dow Cancel  = *Off;\n               Vdetails = *On;\n               Exfmt Dsplyevnt ;\n\n                 If Cancel = *On;\n                    Vdetails = *Off;\n                    Cancel  = *Off;\n                    Reset Viwevntctl;\n                    Clear Evopt;\n                    Leave;\n                 Endif;\n              Enddo;\n          End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"This free form ILE RPG procedure `Eventdetails` shows a screen with the details for the event specified by the input parameter.\n\n## Parameters\n\nThe CHAR(6) parameter specifies the event id of the event to display,  It is passed by reference but it is not changed within the procedure.\n\n## Side effects\n\n### Database\n\nThe current record of the `EVENTPF` is moved to the first record whose key `EVNTID` matches the input parameter.\n\n### Global Variables\n\n- All the variables from the `DSPLYEVNT` format of the `ADMDASHDSP` display file are initialized to the values of the corresponding record in `EVENTPF`\n  - `VWID` - Event ID\n  - `VWEVNAME` - Event Name\n  - `VWEVDATE` - Event Date\n  - `VWEVTIME` - Event Time\n  - `VWEVTYPE` - Event Type\n  - `VWARTNAME` - Artist Name\n  - `VWTKCST` - Per Ticket Price\n  - `VWEVSEATS` - Available Seats\n  - `VWTOTSEATS` - Total Seats\n  - `VWABEVNT` - About Event\n  - `VWEVVENUE` - Event Venue\n  - `VWEVADDATE` - Add Event Date\n  - `VWEVUPDATE` - Update Event Date\n  - `VWEVSTATUS`  - Event Status\n\n- The `SRCHPOS` field from the `VIWEVNTCTL` subfile control format\n\n- Indicators from the INDDS data structure `Indrds`:\n  - `Cancel` - `*IN12` is turned on if F12 Cancel was pressed\n  - `Vdetails` - `*IN21` is turned off it the screen was cancelled\n  - `Evopt` - it clears the option currently selected by the user\n\n**Usage example**: Call procedure `Eventdetails` to display the event with id `id_number`.\n\n```rpgle\nEventdetails (id_number);\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_EventDetails/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"ADMDASHRPG_EventDetails_how","input_data":"             Dcl-Proc Eventdetails ;\n               Dcl-Pi Eventdetails ;\n                 Sevntid Char(6);\n               End-Pi;\n\n\n            Exec Sql\n                Select Evntid,Evntname,Evntdate,Artname,Evnttype,Evnttktcst,\n                       Availseats,Totalseats,Aboutevent,Evntvenue,Evnttime,\n                       Evntaddate,Evntupdate,Evntstatus\n\n                Into   :Vwid, :Vwevname, :Vwevdate, :Vwartname, :Vwevtype,\n                       :Vwtkcst, :Vwevseats, :Vwtotseats, :Vwabevnt, :Vwevvenue,\n                       :Vwevtime, :Vwevaddate, :Vwevupdate, :Vwevstatus\n                From Eventpf\n                Where Evntid = :Sevntid  ;\n              Dow Cancel  = *Off;\n               Vdetails = *On;\n               Exfmt Dsplyevnt ;\n\n                 If Cancel = *On;\n                    Vdetails = *Off;\n                    Cancel  = *Off;\n                    Reset Viwevntctl;\n                    Clear Evopt;\n                    Leave;\n                 Endif;\n              Enddo;\n          End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"This free form ILE RPG procedure `Eventdetails` shows a screen with the details for the event specified by the input parameter.\n\nThe six character input parameter `sevntid` specifies the event id of the event to display,  It is passed by reference but it is not changed within the procedure.\n\nThe procedure selects fields from file `EVENTPF` into the fields from  format `DSPLYEVNT`of display file `ADMDASHDSP`.\n\nThe `DSPLYEVNT` format is shown on the screen in a loop until `F12` for `Cancel` is pressed.  All the fields for the `DSPLYEVNT` are output-only except for the `VWABEVNT` field.\n\nThe `VWABEVNT` field is both input and output capable in the `DSPLYEVNT` format, but the field is protected from being updated by the user by the `DSPATR(PR)` keyword which is enabled by setting on indicator 20 in the display file. The RPG program controls indicator 20 using the `Vdetails` field in the indicator data structure `Indrds`, associated with the display file using the `INDDS`keyword.\n\nAfter the `EXFMT` operation, the `Cancel` indicator is checked. This indicator is set on when the user presses the `F12` key while viewing the screen. If the `Cancel` indicator is on it does the following:s\n\n- the `Cancel` (*IN12) and `Vdetails` (*IN26) indicator are set off\n- the `CLEAR` operation on the `VIWEVNTCTL` subfile control format clears the output capable fields, `FLD`, `RCD`, `POS`, and `SRCHPOS` in that format.`\n- the `Evopt` field from the `VIEWEVNT`subfile format is cleared\n- the loop is exited","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_EventDetails/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"ADMDASHRPG_Updatefieldsvalidation_sum","input_data":"                Dcl-S Regex Varchar(50);\n                Dcl-S C_String Char(53);\n                Dcl-S Count Zoned(5);\n\n                Result1 = %Scan( '0' : %Char(Uorgadhrid) : 1 );\n                Result2 = %Scan( '0' : %Char(Uorgmobno) : 1 );\n                Adharidlen = %Len(%Trim(%Char(Uorgadhrid)));\n                Contactlen = %Len(%Trim(%Char(Uorgmobno)));\n                Validmail = %Trim(Uorgmail);\n\n                Regex = '^(?:\\W+\\.?)*\\W+@(?:\\W+\\.)*\\W+$';\n              C_String = 'Abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';\n\n                Exec Sql\n                   Set :Count = Regexp_Count(:Validmail,:Regex);\n\n                Select;\n\n                   When Uorgadhrid = 0 ;\n                        Errmsg = 'Aadhar Id Field Cannot Be Blank';\n                        Madharid = *On;\n                        Return;\n\n\n                   When Adharidlen < 12;\n                        Errmsg = 'Aadhar Id Length Should Be Of 12 Digits';\n                        Madharid = *On;\n                        Return;\n\n\n                   When Uorgname = *Blanks;\n                        Errmsg = 'Event Organizer Field Cannot Be Blank';\n                        Dorgname = *On;\n                        Return;\n\n                   When %Check(C_String:Uorgname) <> 0;\n                        Errmsg = 'Only Characters Allowed';\n                        Dorgname = *On;\n                        Return;\n\n                   When Uorggender = *Blanks;\n                        Errmsg = 'Gender Feild Cannot Be Blank';\n                        Morggender = *On;\n                        Return;\n\n                   When Uorgstate  = *Blanks;\n                        Errmsg = 'State Feild Cannot Be Blank';\n                        Morgstate = *On;\n                        Return;\n\n                   When Uorgaddr  = *Blanks;\n                        Errmsg  = 'Address Field Cannot Be Blank';\n                        Morgaddress = *On;\n                        Return;\n\n                   When Uorgmobno = 0;\n                        Errmsg  = 'Contact Number Field Cannot Be Blank';\n                        Morgmobnumber =  *On;\n                        Return;\n\n                   When Result2 = 1 ;\n                         Errmsg = 'Mobile Number Should Not Strat With Zero';\n                         Morgmobnumber = *On;\n                         Return;\n\n                   When Contactlen < 10;\n                       Errmsg  = 'Contact Number Length Should Be Of 10 Digits';\n                        Morgmobnumber =  *On;\n                        Return;\n\n                   When Uorgmail = *Blank;\n                        Errmsg = 'Email Field Can Not Be Blank';\n                        Dorgmail = *On;\n                        Return;\n\n                   When Count <> 1;\n                         Errmsg = 'Invalid Email';\n                         Dorgmail = *On;\n                         Return;\n                Endsl;\n            End-Proc;\n\n      **************************************************************************\n      *             Update Event Organizer Record subprocedure (Option 2)     *\n      **************************************************************************\n           Dcl-Proc Updaterecord;\n              Dcl-Pi Updaterecord ;\n                Morgid Char(6);","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);\n          Dcl-S Count Zoned(2);","output":"### Summary\nThe column-limited SQLRPGLE `Updatefieldsvalidation` subprocedure is designed to validate various fields related to an event organizer. It ensures that the data entered meets specific criteria before proceeding further. This subprocedure performs checks on the Aadhar ID, contact number, email address, name, gender, state, and address fields. If any field fails validation, an appropriate error message is set, and the corresponding indicator is turned on.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Updatefieldsvalidation/output/sum_output.md","task":"explain","difficulty":3,"language":"rpglf-sql","scope":"proc","depth":"sum"}}
{"id":"ADMDASHRPG_Updatefieldsvalidation_api","input_data":"                Dcl-S Regex Varchar(50);\n                Dcl-S C_String Char(53);\n                Dcl-S Count Zoned(5);\n\n                Result1 = %Scan( '0' : %Char(Uorgadhrid) : 1 );\n                Result2 = %Scan( '0' : %Char(Uorgmobno) : 1 );\n                Adharidlen = %Len(%Trim(%Char(Uorgadhrid)));\n                Contactlen = %Len(%Trim(%Char(Uorgmobno)));\n                Validmail = %Trim(Uorgmail);\n\n                Regex = '^(?:\\W+\\.?)*\\W+@(?:\\W+\\.)*\\W+$';\n              C_String = 'Abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';\n\n                Exec Sql\n                   Set :Count = Regexp_Count(:Validmail,:Regex);\n\n                Select;\n\n                   When Uorgadhrid = 0 ;\n                        Errmsg = 'Aadhar Id Field Cannot Be Blank';\n                        Madharid = *On;\n                        Return;\n\n\n                   When Adharidlen < 12;\n                        Errmsg = 'Aadhar Id Length Should Be Of 12 Digits';\n                        Madharid = *On;\n                        Return;\n\n\n                   When Uorgname = *Blanks;\n                        Errmsg = 'Event Organizer Field Cannot Be Blank';\n                        Dorgname = *On;\n                        Return;\n\n                   When %Check(C_String:Uorgname) <> 0;\n                        Errmsg = 'Only Characters Allowed';\n                        Dorgname = *On;\n                        Return;\n\n                   When Uorggender = *Blanks;\n                        Errmsg = 'Gender Feild Cannot Be Blank';\n                        Morggender = *On;\n                        Return;\n\n                   When Uorgstate  = *Blanks;\n                        Errmsg = 'State Feild Cannot Be Blank';\n                        Morgstate = *On;\n                        Return;\n\n                   When Uorgaddr  = *Blanks;\n                        Errmsg  = 'Address Field Cannot Be Blank';\n                        Morgaddress = *On;\n                        Return;\n\n                   When Uorgmobno = 0;\n                        Errmsg  = 'Contact Number Field Cannot Be Blank';\n                        Morgmobnumber =  *On;\n                        Return;\n\n                   When Result2 = 1 ;\n                         Errmsg = 'Mobile Number Should Not Strat With Zero';\n                         Morgmobnumber = *On;\n                         Return;\n\n                   When Contactlen < 10;\n                       Errmsg  = 'Contact Number Length Should Be Of 10 Digits';\n                        Morgmobnumber =  *On;\n                        Return;\n\n                   When Uorgmail = *Blank;\n                        Errmsg = 'Email Field Can Not Be Blank';\n                        Dorgmail = *On;\n                        Return;\n\n                   When Count <> 1;\n                         Errmsg = 'Invalid Email';\n                         Dorgmail = *On;\n                         Return;\n                Endsl;\n            End-Proc;\n\n      **************************************************************************\n      *             Update Event Organizer Record subprocedure (Option 2)     *\n      **************************************************************************\n           Dcl-Proc Updaterecord;\n              Dcl-Pi Updaterecord ;\n                Morgid Char(6);","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);\n          Dcl-S Count Zoned(2);","output":"#### 1. Purpose\nThe colunm-limited SQLRPGLE `Updatefieldsvalidation` subprocedure validates various fields related to an event organizer's details. It ensures that the data entered meets specific criteria and standards.\n\n#### 2. Parameters\n- NA\n\n#### 3. Inputs \n  - `Uorgadhrid`: Aadhar ID of the event organizer.\n  - `Uorgmobno`: Contact number of the event organizer.\n  - `Uorgmail`: Email address of the event organizer.\n  - `Uorgname`: Name of the event organizer.\n  - `Uorggender`: Gender of the event organizer.\n  - `Uorgstate`: State of the event organizer.\n  - `Uorgaddr`: Address of the event organizer.\n\n#### 4. Outputs\n  - `Errmsg`: Error message indicating the validation failure.\n  - Various indicators (`Madharid`, `Dorgname`, `Morggender`, `Morgstate`, `Morgaddress`, `Morgmobnumber`, `Dorgmail`) set to `*On` to highlight the field with validation issues.\n\n#### 5. Limitations\n  - The subprocedure does not continue checking after any validation fails, requiring all fields to meet the specified criteria before proceeding.\n\n#### 6. Usage Example\n- When the `Updatefieldsvalidation` subprocedure is called, it performs a series of checks on the input fields. If any field fails validation, an appropriate error message is set, and the corresponding indicator is turned on. Then it does not continue checking after any validation fails, requiring all fields to meet the specified criteria before proceeding.\n- For example, if the email format is invalid, the `Errmsg` will be set to \"Invalid Email,\" and the `Dorgmail` indicator will be turned on.\n- The caller should not proceed with the update if `Errmsg` is not blank, as this indicates that the procedure found a problem with one of the fields.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Updatefieldsvalidation/output/api_output.md","task":"explain","difficulty":3,"language":"rpglf-sql","scope":"proc","depth":"api"}}
{"id":"ADMDASHRPG_Updatefieldsvalidation_how","input_data":"                Dcl-S Regex Varchar(50);\n                Dcl-S C_String Char(53);\n                Dcl-S Count Zoned(5);\n\n                Result1 = %Scan( '0' : %Char(Uorgadhrid) : 1 );\n                Result2 = %Scan( '0' : %Char(Uorgmobno) : 1 );\n                Adharidlen = %Len(%Trim(%Char(Uorgadhrid)));\n                Contactlen = %Len(%Trim(%Char(Uorgmobno)));\n                Validmail = %Trim(Uorgmail);\n\n                Regex = '^(?:\\W+\\.?)*\\W+@(?:\\W+\\.)*\\W+$';\n              C_String = 'Abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';\n\n                Exec Sql\n                   Set :Count = Regexp_Count(:Validmail,:Regex);\n\n                Select;\n\n                   When Uorgadhrid = 0 ;\n                        Errmsg = 'Aadhar Id Field Cannot Be Blank';\n                        Madharid = *On;\n                        Return;\n\n\n                   When Adharidlen < 12;\n                        Errmsg = 'Aadhar Id Length Should Be Of 12 Digits';\n                        Madharid = *On;\n                        Return;\n\n\n                   When Uorgname = *Blanks;\n                        Errmsg = 'Event Organizer Field Cannot Be Blank';\n                        Dorgname = *On;\n                        Return;\n\n                   When %Check(C_String:Uorgname) <> 0;\n                        Errmsg = 'Only Characters Allowed';\n                        Dorgname = *On;\n                        Return;\n\n                   When Uorggender = *Blanks;\n                        Errmsg = 'Gender Feild Cannot Be Blank';\n                        Morggender = *On;\n                        Return;\n\n                   When Uorgstate  = *Blanks;\n                        Errmsg = 'State Feild Cannot Be Blank';\n                        Morgstate = *On;\n                        Return;\n\n                   When Uorgaddr  = *Blanks;\n                        Errmsg  = 'Address Field Cannot Be Blank';\n                        Morgaddress = *On;\n                        Return;\n\n                   When Uorgmobno = 0;\n                        Errmsg  = 'Contact Number Field Cannot Be Blank';\n                        Morgmobnumber =  *On;\n                        Return;\n\n                   When Result2 = 1 ;\n                         Errmsg = 'Mobile Number Should Not Strat With Zero';\n                         Morgmobnumber = *On;\n                         Return;\n\n                   When Contactlen < 10;\n                       Errmsg  = 'Contact Number Length Should Be Of 10 Digits';\n                        Morgmobnumber =  *On;\n                        Return;\n\n                   When Uorgmail = *Blank;\n                        Errmsg = 'Email Field Can Not Be Blank';\n                        Dorgmail = *On;\n                        Return;\n\n                   When Count <> 1;\n                         Errmsg = 'Invalid Email';\n                         Dorgmail = *On;\n                         Return;\n                Endsl;\n            End-Proc;\n\n      **************************************************************************\n      *             Update Event Organizer Record subprocedure (Option 2)     *\n      **************************************************************************\n           Dcl-Proc Updaterecord;\n              Dcl-Pi Updaterecord ;\n                Morgid Char(6);","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);\n          Dcl-S Count Zoned(2);","output":"#### 1. Purpose\n- The column-limited SQLRPGLE `Updatefieldsvalidation` subprocedure is designed to validate various fields related to an event organizer. It ensures that the data entered meets specific criteria before proceeding further. This subprocedure performs checks on the Aadhar ID, contact number, email address, name, gender, state, and address fields. If any field fails validation, an appropriate error message is set, and the corresponding indicator is turned on.\n\n#### 2. Declaration Section\nThe subprocedure begins with the declaration of several standalone variables that are used for validation purposes.\n\n- `Dcl-S Validmail Varchar(100)`\n   - `Validmail`: A character variable with a maximum length of 100 characters.\n   - `S`: Indicates that this is a stand-alone variable.\n   - `Varchar(100)`: Specifies that the variable is a variable-length character field with a maximum length of 100 characters.\n   - It is used to store the email address for validation.\n\n- `Dcl-S Adharidlen Zoned(2)`\n   - `Adharidlen`: A numeric variable with a length of 2 digits and no decimal places.\n   - `S`: Indicates that this is a stand-alone variable.\n   - `Zoned(2)`: Specifies that the variable is numeric with a length of 2 digits and no decimal places.\n   - It is used to store the length of the Aadhar ID after trimming any leading or trailing spaces.\n\n- `Dcl-S Contactlen Zoned(10)`\n   - `Contactlen`: A numeric variable with a length of 10 digits and no decimal places.\n   - `S`: Indicates that this is a stand-alone variable.\n   - `Zoned(10)`: Specifies that the variable is numeric with a length of 10 digits and no decimal places.\n   - It is used to store the length of the contact number after trimming any leading or trailing spaces.\n\n- `Dcl-S Result1 Zoned(2)`\n   - `Result1`: A numeric variable with a length of 2 digits and no decimal places.\n   - `S`: Indicates that this is a stand-alone variable.\n   - `Zoned(2)`: Specifies that the variable is numeric with a length of 2 digits and no decimal places.\n   - It is used to store the result of scanning the Aadhar ID for the presence of the digit '0'.\n\n- `Dcl-S Result2 Zoned(2)`\n   - `Result2`: A numeric variable with a length of 2 digits and no decimal places.\n   - `S`: Indicates that this is a stand-alone variable.\n   - `Zoned(2)`: Specifies that the variable is numeric with a length of 2 digits and no decimal places.\n   - It is used to store the result of scanning the contact number for the presence of the digit '0'.\n\n- `Dcl-S Regex Varchar(50)`\n   - `Regex`: A character variable with a maximum length of 50 characters.\n   - `S`: Indicates that this is a stand-alone variable.\n   - `Varchar(50)`: Specifies that the variable is a variable-length character field with a maximum length of 50 characters.\n   - It is used to store the regular expression pattern for validating the email format.\n\n- `Dcl-S C_String Char(53)`\n   - `C_String`: A character variable with a fixed length of 53 characters.\n   - `S`: Indicates that this is a stand-alone variable.\n   - `Char(53)`: Specifies that the variable is a fixed-length character field with a length of 53 characters.\n   -  It is used to store a string of alphabetical characters for checking the validity of the event organizer's name.\n     \n\n- `Dcl-S Count Zoned(5)`\n   - `Count`: A numeric variable with a length of 5 digits and no decimal places.\n   - `S`: Indicates that this is a stand-alone variable.\n   - `Zoned(5)`: Specifies that the variable is numeric with a length of 5 digits and no decimal places.\n   - It is used to store the result of the regular expression count for validating the email format.\n\n#### 3. Initialization and Validation Logic\nThe subprocedure initializes the variables and performs validation checks.\n\n-  `Result1 = %Scan('0' : %Char(Uorgadhrid) : 1);`\n   - Scans the `Uorgadhrid` numeric variable (Aadhar ID) for the digit '0'.\n   - `%Scan` searches for a specified substring within a string.\n   - `%Char(Uorgadhrid)` converts the `Uorgadhrid` numeric variable to a character string.\n   - `'0'` is the substring to search for.\n   - `1` is the starting position for the scan.\n   - `Result1` will be set to the position of the first occurrence of '0' in the `Uorgadhrid` string. If '0' is not found, `Result1` will be set to 0.\n\n-  `Result2 = %Scan('0' : %Char(Uorgmobno) : 1);`\n   - Scans the `Uorgmobno` numeric variable (contact number) for the digit '0'.\n   - `%Scan` searches for the specified substring within the string.\n   - `%Char(Uorgmobno)` converts the `Uorgmobno` numeric variable to a character string.\n   - `'0'` is the substring to search for.\n   - `1` is the starting position for the scan.\n   - `Result2` will be set to the position of the first occurrence of '0' in the `Uorgmobno` string. If '0' is not found, `Result2` will be set to 0.\n\n-  `Adharidlen = %Len(%Trim(%Char(Uorgadhrid)));`\n   - Calculates the length of the trimmed `Uorgadhrid` numeric variable (Aadhar ID).\n   - `%Len` returns the length of a string.\n   - `%Trim(%Char(Uorgadhrid))` converts the `Uorgadhrid` numeric variable to a character string and trims any leading or trailing spaces.\n   - `Adharidlen` will be set to the length of the trimmed `Uorgadhrid` string.\n\n-  `Contactlen = %Len(%Trim(%Char(Uorgmobno)));`\n   - Calculates the length of the trimmed `Uorgmobno` numeric variable (contact number).\n   - `%Len` returns the length of a string.\n   - `%Trim(%Char(Uorgmobno))` converts the `Uorgmobno` numeric variable to a character string and trims any leading or trailing spaces.\n   - `Contactlen` will be set to the length of the trimmed `Uorgmobno` string.\n\n-  `Validmail = %Trim(Uorgmail);`\n   - Trims any leading or trailing spaces from the `Uorgmail` character variable (email address).\n   - `%Trim` removes leading and trailing spaces from a string.\n   - `Validmail` will be set to the trimmed `Uorgmail` string.\n\n-  `Regex = '^(?:\\W+\\.?)*\\W+@(?:\\W+\\.)*\\W+$';`\n   - Defines the regular expression pattern used for email validation.\n   - Regular expressions match patterns within strings.\n   - `^(?:\\W+\\.?)*\\W+@(?:\\W+\\.)*\\W+$` is the pattern to match a valid email address format.\n   - `Regex` will be set to the specified pattern.\n\n-  `C_String = 'Abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';`\n   - Defines a string of characters used for validation.\n   - The string contains a predefined set of alphanumeric characters.\n   - `'Abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'` is the string of characters.\n   - `C_String` will be set to the specified string.\n\n#### 4. SQL Statement for Regular Expression Count\n```rpgle for ILE RPG\n       Exec Sql\n       Set :Count = Regexp_Count(:Validmail, :Regex);\n```\n- This SQL statement counts the occurrences of the regular expression pattern defined in the `Regex` variable within the `Validmail` variable. The result is stored in the `Count` variable, which is used to validate the format of the email address. If the email address matches the pattern, `Count` will be set to the number of matches found. If it does not match, `Count` will be set to 0. This ensures the email address is in a valid format before proceeding with updates.\n\n#### 5. Validation Checks\nThe subprocedure performs a series of validation checks using a `Select` statement.\n\n#### 5.1 Aadhar Validation for Zeros\n  - If `Uorgadhrid` is 0, it sets `Errmsg` to \"Aadhar Id Field Cannot Be Blank\" and turns on the `Madharid` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.2 Aadhar Validation for Length\n  - If `Adharidlen` is less than 12, it sets `Errmsg` to \"Aadhar Id Length Should Be Of 12 Digits\" and turns on the `Madharid` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.3 Name Validation for Blanks\n  - If `Uorgname` is blank, it sets `Errmsg` to \"Event Organizer Field Cannot Be Blank\" and turns on the `Dorgname` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.4 Name Validation for Characters\n  - If `Uorgname` contains invalid characters or numeric, it sets `Errmsg` to \"Only Characters Allowed\" and turns on the `Dorgname` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.5 Gender Validation\n  - If `Uorggender` is blank, it sets `Errmsg` to \"Gender Field Cannot Be Blank\" and turns on the `Morggender` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.6 State Validation\n  - If `Uorgstate` is blank, it sets `Errmsg` to \"State Field Cannot Be Blank\" and turns on the `Morgstate` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.7 Address Validation\n  - If `Uorgaddr` is blank, it sets `Errmsg` to \"Address Field Cannot Be Blank\" and turns on the `Morgaddress` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.8 Mobile Number Validation for Zero\n  - If `Uorgmobno` is 0, it sets `Errmsg` to \"Contact Number Field Cannot Be Blank\" and turns on the `Morgmobnumber` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.9 Mobile Number Validation for Starting Digit\n  - If `Result2` is 1, it sets `Errmsg` to \"Mobile Number Should Not Start With Zero\" and turns on the `Morgmobnumber` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.10 Mobile Number Validation for Length\n  - If `Contactlen` is less than 10, it sets `Errmsg` to \"Contact Number Length Should Be Of 10 Digits\" and turns on the `Morgmobnumber` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.11 Email Validation for Blanks\n  - If `Uorgmail` is blank, it sets `Errmsg` to \"Email Field Cannot Be Blank\" and turns on the `Dorgmail` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 5.12 Email Validation for Format\n  - If `Count` is not 1, it sets `Errmsg` to \"Invalid Email\" and turns on the `Dorgmail` indicator.\n  - If the condition fails, then returns immediately without doing any further validation.\n\n#### 6. End-Proc Statement\n- If the subprocedure reaches the `End-Proc` statement, it means that no errors were found in the validation.\n\n### 7. Possible Problems with the Procedure\n\n- `Contactlen Zoned(10)`\n  - The `Contactlen` variable is declared as `Zoned(10)`, which is excessive for storing the length of a contact number.\n  - The length of a contact number is typically a small integer. Therefore, a length of 2 digits (e.g., `Zoned(2)`) would be sufficient to hold the length of a 10-digit number.\n\n- `C_String = 'Abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz';`\n  - The `C_String` variable includes repeated lowercase characters.\n  - The first 26 characters are supposed to be uppercase A-Z. The `C_String` is only used for the first parameter of `%Check`, so there is no reason to have the b-z characters repeated.\n\n- `Result1 = %Scan('0' : %Char(Uorgadhrid) : 1);`\n  - The procedure sets the value of `Result1` but does not validate whether the Aadhar ID starts with zero.\n  - While `Result1` stores the position of the first occurrence of '0' in the `Uorgadhrid` string, there is no check to ensure that the Aadhar ID does not start with zero.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Updatefieldsvalidation/output/how_output.md","task":"explain","difficulty":3,"language":"rpglf-sql","scope":"proc","depth":"how"}}
{"id":"ADMDASHRPG_Viewbookings_sum","input_data":"          Dcl-Proc Viewbookings ;\n              Viwclear(); //Call Clear subfile subproceudre for view bookings\n              Viwload(); //Call Load subfile subprocedure for View bookings\n\n            Dow Exit = *Off Or Cancel = *Off;\n\n                Viwdisplay(); //Call Display subfile subproceudre for view booki\n\n                Select;\n\n                  When Exit = *On;\n                   Reset Viwbkngctl;\n                   Leave;\n\n                  When Cancel = *On;\n                   Cancel = *Off;\n\n                   Clear Viwbkngctl ;\n                   Clear Errmsg;\n                   Leave;\n\n                  When Refresh = *On;\n                       Refresh  = *Off;\n                       Binopt  = *Off;\n                       Bsflnxtchg = *Off;\n                       Resetbookings(); //Call Refresh subproceudre for view boo\n\n                  When Fld = 'Srchpos' Or Fld = 'Fbkngdate' Or\n                       Fld = 'Tobkngdate';\n                   Viwclear();\n\n                Select;\n\n                  When Srchpos <> *Blanks ;\n                   Bkloadpos(); // Call Position to by subfile subproceudre for\n\n                  When Fbkngdate <> *Blanks;\n                   Daterange(); // Call Date Range subproceudre for view booking\n\n                  When Tobkngdate <> *Blanks;\n                   Daterange();\n\n                  Other;\n                   Viwload();\n\n                Endsl;\n\n                 Other;\n\n                 Readc Viwbooking ;\n                 Dow Not%Eof();\n\n                   Binopt  = *Off;\n                   Bsflnxtchg = *Off;\n                Select;\n\n                  When Svopt = 5;\n                   Bookingdetails(Sbkgid); //Call View booking details subproceu\n                   Clear Svopt;\n\n                    If Svopt = 0;\n                      Binopt  = *Off;\n                      Bsflnxtchg = *Off;\n                    Endif;\n\n                  When Svopt > 0 ;\n                   Errmsg = 'Invalid Option';\n                   Binopt  = *On;\n                   Bsflnxtchg = *On;\n                Endsl;\n\n                   Update Viwbooking;\n                   Readc Viwbooking ;\n                 Enddo;\n                Endsl;\n            Enddo;\n\n          End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"ILE RPG procedure `Viewbookings` shows a screen with all the bookings from table `BOOKING_TABLE`. The user can subset the list by a range of dates or position the list to a particular booking, and the user can select bookings to view in detail.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Viewbookings/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4lf-sql","scope":"proc","depth":"sum"}}
{"id":"ADMDASHRPG_Viewbookings_api","input_data":"          Dcl-Proc Viewbookings ;\n              Viwclear(); //Call Clear subfile subproceudre for view bookings\n              Viwload(); //Call Load subfile subprocedure for View bookings\n\n            Dow Exit = *Off Or Cancel = *Off;\n\n                Viwdisplay(); //Call Display subfile subproceudre for view booki\n\n                Select;\n\n                  When Exit = *On;\n                   Reset Viwbkngctl;\n                   Leave;\n\n                  When Cancel = *On;\n                   Cancel = *Off;\n\n                   Clear Viwbkngctl ;\n                   Clear Errmsg;\n                   Leave;\n\n                  When Refresh = *On;\n                       Refresh  = *Off;\n                       Binopt  = *Off;\n                       Bsflnxtchg = *Off;\n                       Resetbookings(); //Call Refresh subproceudre for view boo\n\n                  When Fld = 'Srchpos' Or Fld = 'Fbkngdate' Or\n                       Fld = 'Tobkngdate';\n                   Viwclear();\n\n                Select;\n\n                  When Srchpos <> *Blanks ;\n                   Bkloadpos(); // Call Position to by subfile subproceudre for\n\n                  When Fbkngdate <> *Blanks;\n                   Daterange(); // Call Date Range subproceudre for view booking\n\n                  When Tobkngdate <> *Blanks;\n                   Daterange();\n\n                  Other;\n                   Viwload();\n\n                Endsl;\n\n                 Other;\n\n                 Readc Viwbooking ;\n                 Dow Not%Eof();\n\n                   Binopt  = *Off;\n                   Bsflnxtchg = *Off;\n                Select;\n\n                  When Svopt = 5;\n                   Bookingdetails(Sbkgid); //Call View booking details subproceu\n                   Clear Svopt;\n\n                    If Svopt = 0;\n                      Binopt  = *Off;\n                      Bsflnxtchg = *Off;\n                    Endif;\n\n                  When Svopt > 0 ;\n                   Errmsg = 'Invalid Option';\n                   Binopt  = *On;\n                   Bsflnxtchg = *On;\n                Endsl;\n\n                   Update Viwbooking;\n                   Readc Viwbooking ;\n                 Enddo;\n                Endsl;\n            Enddo;\n\n          End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"## Purpose\n\nILE RPG procedure `Viewbookings` shows a screen with all the bookings from table `BOOKINGPF`. The user can subset the list by a range of dates or position the list to a particular booking, and the user can select bookings to view in detail.\n\n## Parameters\n\nNone\n\n## Impacts\n\n### Global variables modified\n\n- `Errmsg` - Error message\n- `Svopt` - The option in the subfile\n\n- Indicators from the `INDDS` data structure `Indrds`:\n  - `Exit`\n  - `Refresh`\n  - `Cancel`\n  - `Binopt`\n  - `Bsflnxtchg`\n- All the fields in the format 'VIWBKNGCTL`\n  - `FLD`\n  - `RCD`\n  - `POS`\n  - `SRCHPOS`\n  - `FBKNGDATE`\n  - `TOBKNGDATE`\n\n## Usage\n\n```rpgle\n        Viewbookings();\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Viewbookings/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4lf-sql","scope":"proc","depth":"api"}}
{"id":"ADMDASHRPG_Viewbookings_how","input_data":"          Dcl-Proc Viewbookings ;\n              Viwclear(); //Call Clear subfile subproceudre for view bookings\n              Viwload(); //Call Load subfile subprocedure for View bookings\n\n            Dow Exit = *Off Or Cancel = *Off;\n\n                Viwdisplay(); //Call Display subfile subproceudre for view booki\n\n                Select;\n\n                  When Exit = *On;\n                   Reset Viwbkngctl;\n                   Leave;\n\n                  When Cancel = *On;\n                   Cancel = *Off;\n\n                   Clear Viwbkngctl ;\n                   Clear Errmsg;\n                   Leave;\n\n                  When Refresh = *On;\n                       Refresh  = *Off;\n                       Binopt  = *Off;\n                       Bsflnxtchg = *Off;\n                       Resetbookings(); //Call Refresh subproceudre for view boo\n\n                  When Fld = 'Srchpos' Or Fld = 'Fbkngdate' Or\n                       Fld = 'Tobkngdate';\n                   Viwclear();\n\n                Select;\n\n                  When Srchpos <> *Blanks ;\n                   Bkloadpos(); // Call Position to by subfile subproceudre for\n\n                  When Fbkngdate <> *Blanks;\n                   Daterange(); // Call Date Range subproceudre for view booking\n\n                  When Tobkngdate <> *Blanks;\n                   Daterange();\n\n                  Other;\n                   Viwload();\n\n                Endsl;\n\n                 Other;\n\n                 Readc Viwbooking ;\n                 Dow Not%Eof();\n\n                   Binopt  = *Off;\n                   Bsflnxtchg = *Off;\n                Select;\n\n                  When Svopt = 5;\n                   Bookingdetails(Sbkgid); //Call View booking details subproceu\n                   Clear Svopt;\n\n                    If Svopt = 0;\n                      Binopt  = *Off;\n                      Bsflnxtchg = *Off;\n                    Endif;\n\n                  When Svopt > 0 ;\n                   Errmsg = 'Invalid Option';\n                   Binopt  = *On;\n                   Bsflnxtchg = *On;\n                Endsl;\n\n                   Update Viwbooking;\n                   Readc Viwbooking ;\n                 Enddo;\n                Endsl;\n            Enddo;\n\n          End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n        Dcl-Ds Indrds;\n           Updateind Ind Pos(2);\n           Exit      Ind Pos(3);\n           Prompt    Ind Pos(4);\n           Refresh   Ind Pos(5);\n           Logout    Ind Pos(10);\n           Cancel    Ind Pos(12);\n           Vbdetails Ind Pos(21) Inz(*On);\n           Sdetails  Ind Pos(22) Inz(*On);\n           Adchoice  Ind Pos(82);\n\n           Vsfldsp    Ind Pos(25);\n           Vsfldspctl Ind Pos(26);\n           Vsflend    Ind Pos(27);\n           Vsflclr    Ind Pos(28);\n           Vinopt     Ind Pos(71);\n           Vsflnxtchg Ind Pos(72);\n           Vdetails   Ind Pos(20) Inz(*On);\n\n           Bsfldsp    Ind Pos(42);\n           Bsfldspctl Ind Pos(43);\n           Bsflend    Ind Pos(44);\n           Bsflclr    Ind Pos(45);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);\n\n           Usfldsp    Ind Pos(46);\n           Usfldspctl Ind Pos(47);\n           Usflend    Ind Pos(48);\n           Usflclr    Ind Pos(49);\n           Uinopt     Ind Pos(73);\n           Usflnxtchg Ind Pos(76);\n\n           Ssfldsp    Ind Pos(51);\n           Ssfldspctl Ind Pos(52);\n           Ssflend    Ind Pos(53);\n           Ssflclr    Ind Pos(54);\n\n           Rtodate    Ind Pos(30);\n           Rinopt     Ind Pos(40);\n           Rfromdate  Ind Pos(41);\n           Rsfldsp    Ind Pos(55);\n           Rsfldspctl Ind Pos(56);\n           Rsflend    Ind Pos(57);\n           Rsflclr    Ind Pos(58);\n           Rsflnxtchg Ind Pos(73);\n\n           Minopt     Ind Pos(23);\n           Msfldsp    Ind Pos(31);\n           Msfldspctl Ind Pos(32);\n           Msflclr    Ind Pos(33);\n           Msflend    Ind Pos(34);\n           Msflnxtchg Ind Pos(80);\n           Madharid   Ind Pos(61);\n           Dorgname   Ind Pos(62);\n           Morggender Ind Pos(63);\n           Morgstate   Ind Pos(64);\n           Morgaddress Ind Pos(65);\n           Morgmobnumber Ind Pos(66);\n           Dorgmail    Ind Pos(67);\n\n\n           Dmsfldsp    Ind Pos(94);\n           Dmsfldspctl Ind Pos(95);\n           Dmsflclr    Ind Pos(97);\n           Dmsflend    Ind Pos(96);\n\n\n           Chgid       Ind Pos(94);\n           Chgpwd      Ind Pos(91);\n           Newpwd      Ind Pos(92);\n           Cnfpwd      Ind Pos(93);\n\n\n        End-Ds;\n          Dcl-S I Zoned(2);","output":"ILE RPG procedure `Viewbookings` allows a user to view one or more bookings from table `BOOKINGP_TABLE` using subfile format `VIWBOOKING` and subfile control format `VIWBKNGCTL` from display file `ADMDASHDSP`. The user can reposition the list of bookings or subset the list by a range of dates. The user interacts with the list until they press `PF3` (Exit) or `PF12` (Cancel).\n\nWithin the RPG source, table `BOOKING_TABLE` is referred to by its system name `BOOKINGPF`.\n\nThe `ADMDASHDSP` display file is defined in the RPG module to use the `Indrds` as the `INDDS` indicator data structure. The subfields of the `Indrds` data structure are mapped to the `*INnn` indicators used by the display file.\n\n```rpgle\n        Dcl-Ds Indrds;\n           Exit      Ind Pos(3);\n           Refresh   Ind Pos(5);\n           Cancel    Ind Pos(12);\n           Binopt     Ind Pos(69);\n           Bsflnxtchg Ind Pos(75);           \n        End-Ds;\n```\n\n- subfield `Exit` is mapped to `*IN03`. *IN03 is set on when the user presses `F3`, due to `CF03(03 'Exit')` in the source for the display file.\n- subfield `Refresh` is mapped to `*IN05`. `*IN05` is set on when the user presses `F5`. Due to `CF05(05 'Refresh')` in the source for the display file.\n- subfield `Cancel` is mapped to `*IN12`. `*IN12` is set on when the user presses `F12`, due to `CF12(12 'Cancel')` in the source for the display file.\n- subfield `Binopt` is mapped to `IN69`. It is used to control how the `SVOPT` field is displayed in the `VIWBOOKING` subfile.\n- subfield `Bsflnxtchg`is mapped to `IN75`. It is mapped to the `SFLNXTCHG` keyword for the `VIWBOOKING` subfile record. It is used by other procedures in the module to handle error situations.\n\nThe procedure has no parameters.\n\nThe procedure calls several other procedures to do most of the work.\n\nIt starts by calling procedure `Viwclear` to initialize the subfile and procedure `Viwload` to load all the records from table `BOOKING_TABLE`(called  `BOOKINGPF`in the RPG code) into the `VIWBOOKING` subfile, ordered by the `EVNTDATE` column in the table.\n\nThen it has a loop that runs until it reaches a `LEAVE` operation within the loop. The loop could also stop when both the `Exit` and `Cancel` indicators are on, but that cannot happen because the loop ends due to a `LEAVE` operation if it finds either of those indicators on within the loop.\n\nThe following is done for each iteration of the loop:\n\n- It calls procedure `Viwdisplay` to show the bookings to the user.\n- Then it has a `SELECT` statement to determine what to do next\n  - If the `Exit` indicator is on, it means that the user is finished working with the bookings. The procedure then does the following:\n    - it uses the `RESET` operation to set the output capable fields `FLD`, `RCD`, `POS`, `SRCHPOS`, `FBKNGDATE`, and `TOBKNGDATE` from format 'VIWBKNGCTL` to the default values they had at the beginning of the program\n    - it leaves the loop\n  - Else if the `Cancel` indicator is on, it means that the user is finished working with the bookings. The procedure does the following:\n    - it sets the `Cancel` indicator off\n    - it uses the `CLEAR` operation to clear the output capable fields `FLD`, `RCD`, `POS`, `SRCHPOS`, `FBKNGDATE`, and `TOBKNGDATE` from format 'VIWBKNGCTL`\n    - it uses the `CLEAR` operation to clear the `Errmsg` field\n    - it leaves the loop\n  - Else if the `Refresh` indicator is on, it means the user wants to start working with the list of bookings again. The procedure does the following:\n    - it sets the `Refresh`, `Binopt`, and `Bsflnxtchg` indicators off\n    - it calls the `Resetbookings` procedure to clear and load the subfile again\n  - Else iff `Fld` has the value \"Srchpos\", \"Fbkngdate\", or \"Tobkngdate\", the procedure does the following:\n    - it sets `Fld` to \"Tobkngdate\"\n    - it calls procedure `Viwclear` to remove all the records from the subfile\n    - then it loads the subfile again according to the user's request:\n      - if `Srchpos` is not blank, it calls `Bkloadpos` to position the subfile to the required record\n      - else if `Fbkngdate` is not blank, it calls `Daterange` to load the subfile with the records from the required date range\n      - else if `Tobkngdate`is not blank, it calls `Daterange` to load the subfile with the records up to the required date\n      - otherwise it loads the subfile again with all the records\n- Otherwise it loops through all the records of the subfile that the user has modified while working with the list:\n  - It has a standard `READC` loop with a priming read before the loop, and then within the loop it processes the current record and ends with another read.\n\n  ```rpgle\n       Readc Viwbooking ;\n       Dow Not%Eof();\n          ...\n          Readc Viwbooking ;\n       Enddo;\n   ```\n\n- To process each changed record in the subfile it does the following:\n  - it sets indicators `Binopt` and `Bsflnxtchg` off\n  - if `Svopt` = 5 it does the following:\n    - it calls the `Bookingdetails` procedure passing the booking id `Sbkgid` from the subfile record\n    - it clears `Svopt` to zero and then since `Svopt` is now zero, it sets indicator `Binopt` and `Bsflnxtchg` off\n    - else if `Svopt` is greater than 0, it does the following:\n      - it sets `Errmsg` to the message \"Invalid Option\"\n      - it sets indicators `Binopt` and `Bsflnxtchg` to on so that an error message will be displayed to the user the next time they view the list of bookings\n      - Then it updates the subfile record","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Viewbookings/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4lf-sql","scope":"proc","depth":"how"}}
{"id":"ADMDASHRPG_Viwevload_sum","input_data":"           Dcl-Proc Viwevload;\n\n             Exec Sql\n                Declare Viwcrsr Cursor For\n                   Select  Evntid, Evntname, Evntdate, Artname, Evntstatus\n                   From Eventpf\n                   Order By Evntdate  ;\n\n             Exec Sql\n                Open Viwcrsr;\n\n             Exec Sql\n                   Fetch From Viwcrsr Into :Sevntid, :Sevntname, :Sevntdate,\n                                           :Sartname, :Sevnstatus;\n\n                    Dow Sqlcod = 0 ;\n\n                    Vrrn += 1;\n\n                     If  Vrrn > 9999;\n                       Leave ;\n                     Endif ;\n                       Write Viewevnt;\n\n                Exec Sql\n                  Fetch Next From Viwcrsr Into :Sevntid, :Sevntname,\n                                             :Sevntdate, :Sartname,:Sevnstatus;\n\n                    Enddo;\n\n                Exec Sql\n                  Close Viwcrsr;\n\n             End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n          Dcl-S Vrrn Zoned(4);\n          Dcl-S I Zoned(2);","output":"This fully free RPG procedure reads records from the table `Eventpf` using an embedded SQL cursor and writes them to View Event Subfile in the display file `Admdashdsp`.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Viwevload/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"ADMDASHRPG_Viwevload_api","input_data":"           Dcl-Proc Viwevload;\n\n             Exec Sql\n                Declare Viwcrsr Cursor For\n                   Select  Evntid, Evntname, Evntdate, Artname, Evntstatus\n                   From Eventpf\n                   Order By Evntdate  ;\n\n             Exec Sql\n                Open Viwcrsr;\n\n             Exec Sql\n                   Fetch From Viwcrsr Into :Sevntid, :Sevntname, :Sevntdate,\n                                           :Sartname, :Sevnstatus;\n\n                    Dow Sqlcod = 0 ;\n\n                    Vrrn += 1;\n\n                     If  Vrrn > 9999;\n                       Leave ;\n                     Endif ;\n                       Write Viewevnt;\n\n                Exec Sql\n                  Fetch Next From Viwcrsr Into :Sevntid, :Sevntname,\n                                             :Sevntdate, :Sartname,:Sevnstatus;\n\n                    Enddo;\n\n                Exec Sql\n                  Close Viwcrsr;\n\n             End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n          Dcl-S Vrrn Zoned(4);\n          Dcl-S I Zoned(2);","output":"## Purpose\n\nThis fully free RPG procedure reads records from the table `Eventpf` using an embedded SQL cursor and writes them to View Event Subfile in the display file `Admdashdsp`.\n\n## Parameters\n\n- none\n\n## Global Variables Modified\n\n- All the variables in the `VIEWEVNT` format of the `ADMDASHDSP` display file are changed to the values from the last event read from the `EVENTPF' table:\n  - `SEVNTID` - Event id\n  - `SEVNTNAME` - Event name\n  - `SEVNTDATE` - Event date\n  - `SARTNAME` - Artist name\n  - `SEVNSTATUS` - Event status\n  - `EVOPT` - Option to apply to event has the value entered by the user\n  - `Vrrn` - Relative record number of the last record loaded into the subfile\n\n## Constraints\n\nOnly the first 9,999 records will be loaded into subfile 'Viewevnt'.  \n\n## Usage example\n\n```rpgle\nViewload ();\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Viwevload/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"ADMDASHRPG_Viwevload_how","input_data":"           Dcl-Proc Viwevload;\n\n             Exec Sql\n                Declare Viwcrsr Cursor For\n                   Select  Evntid, Evntname, Evntdate, Artname, Evntstatus\n                   From Eventpf\n                   Order By Evntdate  ;\n\n             Exec Sql\n                Open Viwcrsr;\n\n             Exec Sql\n                   Fetch From Viwcrsr Into :Sevntid, :Sevntname, :Sevntdate,\n                                           :Sartname, :Sevnstatus;\n\n                    Dow Sqlcod = 0 ;\n\n                    Vrrn += 1;\n\n                     If  Vrrn > 9999;\n                       Leave ;\n                     Endif ;\n                       Write Viewevnt;\n\n                Exec Sql\n                  Fetch Next From Viwcrsr Into :Sevntid, :Sevntname,\n                                             :Sevntdate, :Sartname,:Sevnstatus;\n\n                    Enddo;\n\n                Exec Sql\n                  Close Viwcrsr;\n\n             End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n          Dcl-S Vrrn Zoned(4);\n          Dcl-S I Zoned(2);","output":"This fully free RPG procedure reads records from the table `Eventpf` using an embedded SQL cursor `Viwcrsr` and writes them to `Viwevnt` subfile in the display file `Admdashdsp` sorted by the date of the event.\n\nFree-form procedure `Viwevload` is declared with no parameters.\n\n```rpgle\n        Dcl-Proc Viwevload;\n```\n\nThe first thing it does is declare and open a SQL cursor named `Viwcrsr` with embedded SQL statement. This cursor is used to get columns `Evntid`, `Evntname`, `Evntdate`, `Artname` and `Evntstatus` from the table `Eventpf` and use column `Evntdate` to order the resultset.\n\n```rpgle\nExec Sql\n    Declare Viwcrsr Cursor For\n        Select  Evntid, Evntname, Evntdate, Artname, Evntstatus\n        From Eventpf\n        Order By Evntdate  ;\nExec Sql\n    Open Viwcrsr;\n```\n\nFetch the first record from cursor Viwcrsr into host variables `Sevntid`, `Sevntname`, `Sevntdate`, `Sartname` and `Sevnstatus`. These host variables are defined in the display file `ADMDASHDSP` subfile record format `VIEWEVNT`\n\n```rpgle\nExec Sql\n    Fetch From Viwcrsr Into :Sevntid, :Sevntname, :Sevntdate,\n        :Sartname, :Sevnstatus;\n```\n\nRun a loop to write the values from the host variables into the subfile `VIEWEVNT` of the display file `ADMDASHDSP` and fetch the next record again. When the counter Vrrn is greater than 9999, exit the loop.\n\n```rpgle\n        Dow Sqlcod = 0 ;\n          Vrrn += 1;\n          If Vrrn > 9999;\n              Leave ;\n          Endif ;\n          Write Viewevnt;\n\n          Exec Sql\n              Fetch Next From Viwcrsr Into :Sevntid, :Sevntname,\n                  :Sevntdate, :Sartname,:Sevnstatus;\n        Enddo;\n```\n\nFinally close the cursor `Viwcrsr`.\n\n```rpgle\nExec Sql\n    Close Viwcrsr;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_Viwevload/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"ADMDASHRPG_dltloadsubfile_api","input_data":"           Dcl-Proc Dltloadsubfile;\n              For Index = 1 To Index1-1;\n\n                Currentid = Dltarr(Index);\n\n                 Exec Sql\n                   Select Orgid , Orgname , Orgcontact,Orgmail\n                   Into :Dltorgid, :Dltorgname, :Dltorgcont , :Dltorgmail\n                   From Evntorgpf\n                   Where Orgid = :Currentid;\n\n                   Drrn += 1;\n\n                     If Drrn > 9999;\n                      Leave;\n                     Endif;\n\n                     Write Dltorgsfl;\n\n              Endfor;\n\n\n           End-Proc;","context":"    \n    \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R VIEWEVNT                  SFL\n    \n     A  72                                  SFLNXTCHG\n     A            SEVNTID        6A  O 11  6\n     A            SEVNTNAME     20A  O 11 15\n     A            SEVNTDATE     10A  O 11 37\n     A            SARTNAME      20A  O 11 49\n     A            SEVNSTATUS    10A  O 11 71\n     A            EVOPT          1S 0B 11  2\n     A  71                                  DSPATR(RI)\n     A  71                                  DSPATR(PC)\n     A          R VIWEVNTCTL                SFLCTL(VIEWEVNT)\nadmdashrpg.pgm.sqlrpgle:\n         Dcl-F Admdashdsp   Workstn Indds(Indrds) Sfile(Viwbooking:Brrn)\n                   Exec Sql\n          Dcl-S Drrn Zoned(4);\n          Dcl-S I Zoned(2);\n          Dcl-S Index Zoned(5) Inz(*Zero);\n          Dcl-S Index1 Zoned(4) Inz(1);\n          Dcl-S Currentid Char(20) Inz(*Blank);\n          Dcl-S Dltarr  Char(20) Dim(9999);","output":"#### 1. Purpose\nThis free-form SQLRPGLE subprocedure `Dltloadsubfile` is designed to load multiple organizer records into a subfile for deletion. It iterates through an array of organizer IDs and retrieves the corresponding details from the `Evntorgpf` file, then writes these details to the subfile `Dltorgsfl`.\n\n#### 2. Parameters\n- None\n\n#### 3. Inputs\n- `Dltarr`: An array containing the IDs of the organizers to be deleted.\n- `Index1`: The upper limit for the loop, indicating the number of organizer IDs in the `Dltarr` array.\n- `Evntorgpf`: The file from which organizer details are retrieved.\n\n#### 4. Outputs\n- `Dltorgsfl`: The subfile where the organizer details are written for deletion.\n\n#### 5. Dependencies\n- `Evntorgpf`: The physical file containing organizer details.\n- `Dltorgsfl`: The subfile where the retrieved organizer details are written.\n- `Dltorgid, Dltorgname, Dltorgcont, Dltorgmail`: Variables to store the retrieved organizer details.\n\n#### 6. Limitations\n- `Subfile Size`: The subfile can handle a maximum of 9999 records. If the number of records exceeds this limit, the procedure will exit the loop early.\n\n#### 7. Side Effects\n- `Database Access`: The procedure performs SQL queries to retrieve data from the `Evntorgpf` file, which may impact performance depending on the size of the file and the number of records being processed.\n\n#### 8. How Example\n- Iterate through the `Dltarr` array from index 1 to `Index1-1`.\n- For each organizer ID in the array, retrieve the corresponding details (`Orgid`, `Orgname`, `Orgcontact`, `Orgmail`) from the `Evntorgpf` file.\n- Increment the subfile record number (`Drrn`) and write the retrieved details to the `Dltorgsfl` subfile.\n- If the subfile record number exceeds 9999, exit the loop early.\n\n#### 8.1 Example Output:\nIf `Dltarr` contains organizer IDs `['ORG001', 'ORG002', 'ORG003']` and `Index1` is 4, the subprocedure will retrieve details for these three organizers and write them to the `Dltorgsfl` subfile. If there are more than 9999 records, it will stop processing further records.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMDASHRPG_dltloadsubfile/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4lf-sql","scope":"proc","depth":"api"}}
{"id":"ADMINBKNGM_BookingLoad_sum","input_data":"  Dcl-Proc BookingLoad;\n    Setll *Loval BOOKINGPF;\n\n   // Loading records from Bookingpf if positionto is not blank\n    If DBKPOSTO <> *Blanks;\n      Read BOOKINGPF;\n      Dow Not %EOF();\n        v_Length = %Min(%Len(%Trim(DBKPOSTO)):%LEN(%Trim(BKID)));\n        Chain FltId FlightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        Endif;\n\n       // checking if searched record is found or not\n        If %Check(%trim(DBKPOSTO):\n        %Subst(BKID:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(AIRNAME:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(FLTORIGIN:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(FLTDEST:1:v_Length)) = 0;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n\n         // validation for field DBKSTATUS\n          If BkStatus = 'U';\n           DBKSTATUS = 'Upcoming';\n          ElseIf BkStatus = 'P';\n           DBKSTATUS = 'Completed';\n          Else;\n           DBKSTATUS = 'Cancelled';\n          EndIf;\n          // Monitor;\n            v_Rrn = v_Rrn + 1;\n\n           // Rrn cannot be greater than 9999\n            If v_Rrn > 9999;\n              Leave;\n            EndIf;\n            Write UsrBkSfl;\n          //   On-Error;\n          //     ADMINERROR = 'Position To Cannot Work On Empty Subfile';\n          // EndMon;\n          Leave;\n        Else;\n          Read BOOKINGPF;\n        EndIf;\n      Enddo;\n\n     // reading last record of file bookingpf\n      If DBKPOSTO <> *Blanks And %EOF(BookingPf);\n        Readp BOOKINGPF;\n        Chain FltId FLightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        EndIf;\n        DBKID = BkId;\n        DBKAIRNAME = AirName;\n        DBKORIGIN = FltOrigin;\n        DBKDEST = FltDest;\n        DBKDEPDATE = BkDepDate;\n\n       // validtion for field DBKSTATUS\n        If BkStatus = 'U';\n          DBKSTATUS = 'Upcoming';\n        ElseIf BkStatus = 'P';\n          DBKSTATUS = 'Completed';\n        ElseIf BkStatus = 'C';\n          DBKSTATUS = 'Cancelled';\n        EndIf;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write UsrBkSfl;\n        Return;\n      EndIf;\n    EndIf;\n\n   // loading all records from bookingpf\n    Read BOOKINGPF;\n    Dow Not %EOF();\n     // Loading either upcoming, cancelled or completed records\n      If Prompt = *On;\n\n       // Loading only upcoming records\n        If BkStatus = 'U' and v_IndUpcoming = *Off;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Upcoming';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n\n       // loading only completed records\n        ElseIf BkStatus = 'P' and v_IndUpcoming = *On\n        and v_IndCompleted = *Off;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Completed';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n\n       // loading only cancelled records\n        ElseIf BkStatus = 'C' and v_IndCompleted = *On\n        and v_IndUpcoming = *On;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Cancelled';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n        Else;\n          Read BOOKINGPF;\n        Endif;\n\n     // Loading all the records from file bookingpf\n      Else;\n        Chain FltId FLightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        EndIf;\n        DBKID = BkId;\n        DBKAIRNAME = AirName;\n        DBKORIGIN = FltOrigin;\n        DBKDEST = FltDest;\n        DBKDEPDATE = BkDepDate;\n\n       // Validation for field DBKSTATUS\n        If BkStatus = 'U';\n         DBKSTATUS = 'Upcoming';\n        ElseIf BkStatus = 'P';\n         DBKSTATUS = 'Completed';\n        ElseIf BkStatus = 'C';\n         DBKSTATUS = 'Cancelled';\n        EndIf;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Leave;\n        EndIf;\n        Write UsrBkSfl;\n        Read BOOKINGPF;\n      EndIf;\n    EndDo;\n\n   // resetting the F4 key\n    If Prompt = *On;\n      Prompt = *Off;\n      If v_IndUpcoming = *Off;\n        v_IndUpcoming = *On;\n      ElseIf v_IndUpcoming = *On and v_IndCompleted = *Off;\n        v_IndCompleted = *On;\n      Else;\n        v_IndUpcoming = *Off;\n        v_IndCompleted = *Off;\n      EndIf;\n    EndIf;\n  End-Proc;","context":"bookingpf.table:\n\nCreate Or Replace Table Booking_Table(\n Bk_Id              For Column BKID       Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Tot_Tickets        For Column TOTTKT     Numeric(2) Not Null With Default 0,\n Bk_SeatCat         For Column BKSEATCAT  Char(1) Not Null With Default ' ',\n Bk_Price           For Column BKPRICE    Numeric(6) Not Null With Default 0,\n Bk_Date            For Column BKDATE     Date,\n Bk_Dep_Date        For Column BKDEPDATE  Date,\n Bk_Dep_Time        For Column BKDEPTIME  Time,\n Bk_Status          For Column BKSTATUS   Char(1) With Default 'U',\n Bk_Remark          For Column BKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (BKID),\nFOREIGN KEY (FLTID) References FLIGHTPF(FLTID),\nFOREIGN KEY (USRID) References USRMASTER(USRID)\n )\nRcdfmt BOOKINGPFR;\n\n\nRename table Booking_Table To System Name BOOKINGPF;\n\nLabel On Table Booking_Table Is 'Booking Details';\n\nLabel On Column Booking_Table(\n BKID        Is 'Booking Id',\n USRID       Is 'User Id',\n FLTID       Is 'Flight Id',\n BKDATE      Is 'Booking Date',\n BKDEPDATE   Is 'Departure Date',\n BKDEPTIME   Is 'Departure Time',\n TOTTKT      Is 'Total Tickets',\n BKSEATCAT   Is 'Seat Category',\n BKPRICE     Is 'Booking Price',\n BKSTATUS    Is 'Booking Status',\n BKREMARK    Is 'Remark');\n\nLabel On Column Booking_Table(\n BKID        Text Is 'Booking Id',\n USRID       Text Is 'User Id',\n FLTID       Text Is 'Flight Id',\n BKDATE      Text Is 'Booking Date',\n BKDEPDATE   Text Is 'Departure Date',\n BKDEPTIME   Text Is 'Departure Time',\n TOTTKT      Text Is 'Total Tickets',\n BKSEATCAT   Text Is 'Seat Category',\n BKPRICE     Text Is 'Booking Price',\n BKSTATUS    Text Is 'Booking Status',\n BKREMARK    Text Is 'Remark');\n\n\nflightpf.table:\n\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\n     \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n     \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R DSPUSRINFO\nadminbkngm.rpgle:\n  Dcl-F Bookingpf   Usage(*Input:*Output) Keyed;\n  Dcl-F Flightpf    Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster   Usage(*Input:*Output) Keyed;\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(UsrBkSfl:v_Rrn)\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit             Ind Pos(03);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(05);\n    Cancel           Ind Pos(12);\n   // UsrBkSfl Subfile Indicators\n    BkSflDsp         Ind Pos(37);\n    BkSflCtl         Ind Pos(38);\n    BkSflClr         Ind Pos(39);\n    BkSflEnd         Ind Pos(40);\n   // UsrTktSfl Subfile Indicators\n    TktSflDsp        Ind Pos(41);\n    TktSflCtl        Ind Pos(42);\n    TktSflClr        Ind Pos(43);\n    TktSflEnd        Ind Pos(44);\n   // Field Indicators\n    v_OverlayInd     Ind Pos(85);\n    v_TktOverlayInd  Ind Pos(86);\n  End-Ds;\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Length       Packed(2);\n  Dcl-S v_IndUpcoming  Ind Inz(*Off);\n  Dcl-S v_IndCompleted Ind Inz(*Off);","output":"This fully-free ILE RPG program is used to load flight booking details into a subfile.  By default all bookings are selected but based on what was selected on the screen, the list can be subset or positioned within.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINBKNGM_BookingLoad/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"sum"}}
{"id":"ADMINBKNGM_BookingLoad_api","input_data":"  Dcl-Proc BookingLoad;\n    Setll *Loval BOOKINGPF;\n\n   // Loading records from Bookingpf if positionto is not blank\n    If DBKPOSTO <> *Blanks;\n      Read BOOKINGPF;\n      Dow Not %EOF();\n        v_Length = %Min(%Len(%Trim(DBKPOSTO)):%LEN(%Trim(BKID)));\n        Chain FltId FlightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        Endif;\n\n       // checking if searched record is found or not\n        If %Check(%trim(DBKPOSTO):\n        %Subst(BKID:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(AIRNAME:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(FLTORIGIN:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(FLTDEST:1:v_Length)) = 0;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n\n         // validation for field DBKSTATUS\n          If BkStatus = 'U';\n           DBKSTATUS = 'Upcoming';\n          ElseIf BkStatus = 'P';\n           DBKSTATUS = 'Completed';\n          Else;\n           DBKSTATUS = 'Cancelled';\n          EndIf;\n          // Monitor;\n            v_Rrn = v_Rrn + 1;\n\n           // Rrn cannot be greater than 9999\n            If v_Rrn > 9999;\n              Leave;\n            EndIf;\n            Write UsrBkSfl;\n          //   On-Error;\n          //     ADMINERROR = 'Position To Cannot Work On Empty Subfile';\n          // EndMon;\n          Leave;\n        Else;\n          Read BOOKINGPF;\n        EndIf;\n      Enddo;\n\n     // reading last record of file bookingpf\n      If DBKPOSTO <> *Blanks And %EOF(BookingPf);\n        Readp BOOKINGPF;\n        Chain FltId FLightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        EndIf;\n        DBKID = BkId;\n        DBKAIRNAME = AirName;\n        DBKORIGIN = FltOrigin;\n        DBKDEST = FltDest;\n        DBKDEPDATE = BkDepDate;\n\n       // validtion for field DBKSTATUS\n        If BkStatus = 'U';\n          DBKSTATUS = 'Upcoming';\n        ElseIf BkStatus = 'P';\n          DBKSTATUS = 'Completed';\n        ElseIf BkStatus = 'C';\n          DBKSTATUS = 'Cancelled';\n        EndIf;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write UsrBkSfl;\n        Return;\n      EndIf;\n    EndIf;\n\n   // loading all records from bookingpf\n    Read BOOKINGPF;\n    Dow Not %EOF();\n     // Loading either upcoming, cancelled or completed records\n      If Prompt = *On;\n\n       // Loading only upcoming records\n        If BkStatus = 'U' and v_IndUpcoming = *Off;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Upcoming';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n\n       // loading only completed records\n        ElseIf BkStatus = 'P' and v_IndUpcoming = *On\n        and v_IndCompleted = *Off;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Completed';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n\n       // loading only cancelled records\n        ElseIf BkStatus = 'C' and v_IndCompleted = *On\n        and v_IndUpcoming = *On;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Cancelled';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n        Else;\n          Read BOOKINGPF;\n        Endif;\n\n     // Loading all the records from file bookingpf\n      Else;\n        Chain FltId FLightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        EndIf;\n        DBKID = BkId;\n        DBKAIRNAME = AirName;\n        DBKORIGIN = FltOrigin;\n        DBKDEST = FltDest;\n        DBKDEPDATE = BkDepDate;\n\n       // Validation for field DBKSTATUS\n        If BkStatus = 'U';\n         DBKSTATUS = 'Upcoming';\n        ElseIf BkStatus = 'P';\n         DBKSTATUS = 'Completed';\n        ElseIf BkStatus = 'C';\n         DBKSTATUS = 'Cancelled';\n        EndIf;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Leave;\n        EndIf;\n        Write UsrBkSfl;\n        Read BOOKINGPF;\n      EndIf;\n    EndDo;\n\n   // resetting the F4 key\n    If Prompt = *On;\n      Prompt = *Off;\n      If v_IndUpcoming = *Off;\n        v_IndUpcoming = *On;\n      ElseIf v_IndUpcoming = *On and v_IndCompleted = *Off;\n        v_IndCompleted = *On;\n      Else;\n        v_IndUpcoming = *Off;\n        v_IndCompleted = *Off;\n      EndIf;\n    EndIf;\n  End-Proc;","context":"bookingpf.table:\n\nCreate Or Replace Table Booking_Table(\n Bk_Id              For Column BKID       Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Tot_Tickets        For Column TOTTKT     Numeric(2) Not Null With Default 0,\n Bk_SeatCat         For Column BKSEATCAT  Char(1) Not Null With Default ' ',\n Bk_Price           For Column BKPRICE    Numeric(6) Not Null With Default 0,\n Bk_Date            For Column BKDATE     Date,\n Bk_Dep_Date        For Column BKDEPDATE  Date,\n Bk_Dep_Time        For Column BKDEPTIME  Time,\n Bk_Status          For Column BKSTATUS   Char(1) With Default 'U',\n Bk_Remark          For Column BKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (BKID),\nFOREIGN KEY (FLTID) References FLIGHTPF(FLTID),\nFOREIGN KEY (USRID) References USRMASTER(USRID)\n )\nRcdfmt BOOKINGPFR;\n\n\nRename table Booking_Table To System Name BOOKINGPF;\n\nLabel On Table Booking_Table Is 'Booking Details';\n\nLabel On Column Booking_Table(\n BKID        Is 'Booking Id',\n USRID       Is 'User Id',\n FLTID       Is 'Flight Id',\n BKDATE      Is 'Booking Date',\n BKDEPDATE   Is 'Departure Date',\n BKDEPTIME   Is 'Departure Time',\n TOTTKT      Is 'Total Tickets',\n BKSEATCAT   Is 'Seat Category',\n BKPRICE     Is 'Booking Price',\n BKSTATUS    Is 'Booking Status',\n BKREMARK    Is 'Remark');\n\nLabel On Column Booking_Table(\n BKID        Text Is 'Booking Id',\n USRID       Text Is 'User Id',\n FLTID       Text Is 'Flight Id',\n BKDATE      Text Is 'Booking Date',\n BKDEPDATE   Text Is 'Departure Date',\n BKDEPTIME   Text Is 'Departure Time',\n TOTTKT      Text Is 'Total Tickets',\n BKSEATCAT   Text Is 'Seat Category',\n BKPRICE     Text Is 'Booking Price',\n BKSTATUS    Text Is 'Booking Status',\n BKREMARK    Text Is 'Remark');\n\n\nflightpf.table:\n\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\n     \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n     \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R DSPUSRINFO\nadminbkngm.rpgle:\n  Dcl-F Bookingpf   Usage(*Input:*Output) Keyed;\n  Dcl-F Flightpf    Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster   Usage(*Input:*Output) Keyed;\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(UsrBkSfl:v_Rrn)\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit             Ind Pos(03);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(05);\n    Cancel           Ind Pos(12);\n   // UsrBkSfl Subfile Indicators\n    BkSflDsp         Ind Pos(37);\n    BkSflCtl         Ind Pos(38);\n    BkSflClr         Ind Pos(39);\n    BkSflEnd         Ind Pos(40);\n   // UsrTktSfl Subfile Indicators\n    TktSflDsp        Ind Pos(41);\n    TktSflCtl        Ind Pos(42);\n    TktSflClr        Ind Pos(43);\n    TktSflEnd        Ind Pos(44);\n   // Field Indicators\n    v_OverlayInd     Ind Pos(85);\n    v_TktOverlayInd  Ind Pos(86);\n  End-Ds;\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Length       Packed(2);\n  Dcl-S v_IndUpcoming  Ind Inz(*Off);\n  Dcl-S v_IndCompleted Ind Inz(*Off);","output":"## Purpose\n\nThis fully-free ILE RPG program is used to load flight booking details into the subfile `UsrBkSfl` from the DSPF object `ADMIND`.  \n\n## Parameters\n\nNone\n\n## Input\n\nThe following variables which are read from the screen impact what set of records are read.\nBy default all records in `BOOKINGPF` are loaded into subfile.  But the following globals can subset the list.\n\n`DBKPOSTO` -  This field is initialized from end user entering data on the related SFLCTL `USRBKCTL`. If this is not blank, the records are subset to those whose fields match the value of `DBKPOSTO`\n\nThe following indicators have their values cycled through the F4 key\n\n- `v_IndUpcoming` - if off then only show those bookins that are upcoming\n- `v_IndCompleted` - if off then only show those booking that are completed\nIf both are on, then only show the cancelled bookings.\n\n- `v_Rrn` - holds the Relative Record Number of the last record read.\n\n- `Prompt` - the F4 Prompt Key Indicator will turned On if the user presses F4.  \n\n## Output\n\nThe subfile `UsrBkSfl` is loaded based on the criteria described above.\nIt contains data from `BOOKING_TABLE`\n\n- BKID - Booking id\n- BKSTATUS - Booking status\n- BKDEPDATE - Departure Date\n\nThe following fields are retrieved from `FLIGHT_TABLE` based on the common field `FLTID`\n\n- Flt_Origin - Flight Origin\n- Flt_Destination - Flight Destination\n\nThis last field is retrieved from `Airline_Table` based on the key `AIRID` which is also in `FLIGHT_TABLE`\n\n- Airline_Name - Airline Name\n\n## Dependencies\n\nThe following objects should be found in the library list\n\n- `ADMIND` is the DSPF object that is used for screen I/O\n- `BOOKINGPF` contains `Booking_Table` table\n- `FLIGHTPF` contains `Flight_Table` table\n- `AIRMASTER` contains `Airline_Table` table\n\n## Limitation\n\nAt most 9999 records will be loaded into this subfile, after which this procedure will return without raising any errors.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINBKNGM_BookingLoad/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"api"}}
{"id":"ADMINBKNGM_BookingLoad_how","input_data":"  Dcl-Proc BookingLoad;\n    Setll *Loval BOOKINGPF;\n\n   // Loading records from Bookingpf if positionto is not blank\n    If DBKPOSTO <> *Blanks;\n      Read BOOKINGPF;\n      Dow Not %EOF();\n        v_Length = %Min(%Len(%Trim(DBKPOSTO)):%LEN(%Trim(BKID)));\n        Chain FltId FlightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        Endif;\n\n       // checking if searched record is found or not\n        If %Check(%trim(DBKPOSTO):\n        %Subst(BKID:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(AIRNAME:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(FLTORIGIN:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(FLTDEST:1:v_Length)) = 0;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n\n         // validation for field DBKSTATUS\n          If BkStatus = 'U';\n           DBKSTATUS = 'Upcoming';\n          ElseIf BkStatus = 'P';\n           DBKSTATUS = 'Completed';\n          Else;\n           DBKSTATUS = 'Cancelled';\n          EndIf;\n          // Monitor;\n            v_Rrn = v_Rrn + 1;\n\n           // Rrn cannot be greater than 9999\n            If v_Rrn > 9999;\n              Leave;\n            EndIf;\n            Write UsrBkSfl;\n          //   On-Error;\n          //     ADMINERROR = 'Position To Cannot Work On Empty Subfile';\n          // EndMon;\n          Leave;\n        Else;\n          Read BOOKINGPF;\n        EndIf;\n      Enddo;\n\n     // reading last record of file bookingpf\n      If DBKPOSTO <> *Blanks And %EOF(BookingPf);\n        Readp BOOKINGPF;\n        Chain FltId FLightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        EndIf;\n        DBKID = BkId;\n        DBKAIRNAME = AirName;\n        DBKORIGIN = FltOrigin;\n        DBKDEST = FltDest;\n        DBKDEPDATE = BkDepDate;\n\n       // validtion for field DBKSTATUS\n        If BkStatus = 'U';\n          DBKSTATUS = 'Upcoming';\n        ElseIf BkStatus = 'P';\n          DBKSTATUS = 'Completed';\n        ElseIf BkStatus = 'C';\n          DBKSTATUS = 'Cancelled';\n        EndIf;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write UsrBkSfl;\n        Return;\n      EndIf;\n    EndIf;\n\n   // loading all records from bookingpf\n    Read BOOKINGPF;\n    Dow Not %EOF();\n     // Loading either upcoming, cancelled or completed records\n      If Prompt = *On;\n\n       // Loading only upcoming records\n        If BkStatus = 'U' and v_IndUpcoming = *Off;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Upcoming';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n\n       // loading only completed records\n        ElseIf BkStatus = 'P' and v_IndUpcoming = *On\n        and v_IndCompleted = *Off;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Completed';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n\n       // loading only cancelled records\n        ElseIf BkStatus = 'C' and v_IndCompleted = *On\n        and v_IndUpcoming = *On;\n          Chain FltId FLightPf;\n          If %Found();\n            Chain AirId Airmaster;\n          EndIf;\n          DBKID = BkId;\n          DBKAIRNAME = AirName;\n          DBKORIGIN = FltOrigin;\n          DBKDEST = FltDest;\n          DBKDEPDATE = BkDepDate;\n          DBKSTATUS = 'Cancelled';\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write UsrBkSfl;\n          Read BOOKINGPF;\n        Else;\n          Read BOOKINGPF;\n        Endif;\n\n     // Loading all the records from file bookingpf\n      Else;\n        Chain FltId FLightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        EndIf;\n        DBKID = BkId;\n        DBKAIRNAME = AirName;\n        DBKORIGIN = FltOrigin;\n        DBKDEST = FltDest;\n        DBKDEPDATE = BkDepDate;\n\n       // Validation for field DBKSTATUS\n        If BkStatus = 'U';\n         DBKSTATUS = 'Upcoming';\n        ElseIf BkStatus = 'P';\n         DBKSTATUS = 'Completed';\n        ElseIf BkStatus = 'C';\n         DBKSTATUS = 'Cancelled';\n        EndIf;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Leave;\n        EndIf;\n        Write UsrBkSfl;\n        Read BOOKINGPF;\n      EndIf;\n    EndDo;\n\n   // resetting the F4 key\n    If Prompt = *On;\n      Prompt = *Off;\n      If v_IndUpcoming = *Off;\n        v_IndUpcoming = *On;\n      ElseIf v_IndUpcoming = *On and v_IndCompleted = *Off;\n        v_IndCompleted = *On;\n      Else;\n        v_IndUpcoming = *Off;\n        v_IndCompleted = *Off;\n      EndIf;\n    EndIf;\n  End-Proc;","context":"bookingpf.table:\n\nCreate Or Replace Table Booking_Table(\n Bk_Id              For Column BKID       Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Tot_Tickets        For Column TOTTKT     Numeric(2) Not Null With Default 0,\n Bk_SeatCat         For Column BKSEATCAT  Char(1) Not Null With Default ' ',\n Bk_Price           For Column BKPRICE    Numeric(6) Not Null With Default 0,\n Bk_Date            For Column BKDATE     Date,\n Bk_Dep_Date        For Column BKDEPDATE  Date,\n Bk_Dep_Time        For Column BKDEPTIME  Time,\n Bk_Status          For Column BKSTATUS   Char(1) With Default 'U',\n Bk_Remark          For Column BKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (BKID),\nFOREIGN KEY (FLTID) References FLIGHTPF(FLTID),\nFOREIGN KEY (USRID) References USRMASTER(USRID)\n )\nRcdfmt BOOKINGPFR;\n\n\nRename table Booking_Table To System Name BOOKINGPF;\n\nLabel On Table Booking_Table Is 'Booking Details';\n\nLabel On Column Booking_Table(\n BKID        Is 'Booking Id',\n USRID       Is 'User Id',\n FLTID       Is 'Flight Id',\n BKDATE      Is 'Booking Date',\n BKDEPDATE   Is 'Departure Date',\n BKDEPTIME   Is 'Departure Time',\n TOTTKT      Is 'Total Tickets',\n BKSEATCAT   Is 'Seat Category',\n BKPRICE     Is 'Booking Price',\n BKSTATUS    Is 'Booking Status',\n BKREMARK    Is 'Remark');\n\nLabel On Column Booking_Table(\n BKID        Text Is 'Booking Id',\n USRID       Text Is 'User Id',\n FLTID       Text Is 'Flight Id',\n BKDATE      Text Is 'Booking Date',\n BKDEPDATE   Text Is 'Departure Date',\n BKDEPTIME   Text Is 'Departure Time',\n TOTTKT      Text Is 'Total Tickets',\n BKSEATCAT   Text Is 'Seat Category',\n BKPRICE     Text Is 'Booking Price',\n BKSTATUS    Text Is 'Booking Status',\n BKREMARK    Text Is 'Remark');\n\n\nflightpf.table:\n\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\n     \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n     \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R DSPUSRINFO\nadminbkngm.rpgle:\n  Dcl-F Bookingpf   Usage(*Input:*Output) Keyed;\n  Dcl-F Flightpf    Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster   Usage(*Input:*Output) Keyed;\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(UsrBkSfl:v_Rrn)\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit             Ind Pos(03);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(05);\n    Cancel           Ind Pos(12);\n   // UsrBkSfl Subfile Indicators\n    BkSflDsp         Ind Pos(37);\n    BkSflCtl         Ind Pos(38);\n    BkSflClr         Ind Pos(39);\n    BkSflEnd         Ind Pos(40);\n   // UsrTktSfl Subfile Indicators\n    TktSflDsp        Ind Pos(41);\n    TktSflCtl        Ind Pos(42);\n    TktSflClr        Ind Pos(43);\n    TktSflEnd        Ind Pos(44);\n   // Field Indicators\n    v_OverlayInd     Ind Pos(85);\n    v_TktOverlayInd  Ind Pos(86);\n  End-Ds;\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Length       Packed(2);\n  Dcl-S v_IndUpcoming  Ind Inz(*Off);\n  Dcl-S v_IndCompleted Ind Inz(*Off);","output":"## Overview\n\nThis fully-free ILE RPG procedure `BookingLoad` is used to load flight booking details into the subfile `UsrBkSfl` from the DSPF object `ADMIND`.\n\n## Common Code\n\nThe procedure will loop through all records of `BOOKING_TABLE` (system name `BOOKINGPF`) in either the first loop or the second. In every case the folowing data will be retrieved ad placed into the corresponding `UsrBkSfl` subfile fields.\n\nData from `BOOKING_TABLE`\n\n- `DBKID` = `BKID` - Booking Id\n- `DBKDEPDATE` = `BKDEPDATE` - Departure Date\n- `DBKSTATUS` = expanded version of `BKSTATUS` - Booking Status\n  \nThe following fields are retrieved from `FLIGHT_TABLE` (system name `FLIGHTF`) based on the common field `FLTID`\n\n- `DBKORIGIN`= Flt_Origin - Flight Origin\n- `DBKDEST` = Flt_Destination - Flight Destination\n\nThis last field is retrieved from `Airline_Table` (system name `AIRMASTER`) based on the key `AIRID` which is also in `FLIGHT_TABLE`\n\n- `DBKAIRNAME` = `Airline_Name` - Airline Name\n\nThis code or a variant of it is reused many times in this procedure.\n\n```rpgle\n        Readp BOOKINGPF;\n        Chain FltId FLightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        EndIf;\n        DBKID = BkId;\n        DBKAIRNAME = AirName;\n        DBKORIGIN = FltOrigin;\n        DBKDEST = FltDest;\n        DBKDEPDATE = BkDepDate;\n\n       // validtion for field DBKSTATUS\n        If BkStatus = 'U';\n          DBKSTATUS = 'Upcoming';\n        ElseIf BkStatus = 'P';\n          DBKSTATUS = 'Completed';\n        ElseIf BkStatus = 'C';\n          DBKSTATUS = 'Cancelled';\n        EndIf;\n```\n\nSince a record has been wrtten to the subfile, the associated relative record number has to be incremented.  If the resultant record number would overflow a four digit integer, the procedure is exited to prevent an overflow.\n\n```rpgle\n            v_Rrn = v_Rrn + 1;\n\n           // Rrn cannot be greater than 9999\n            If v_Rrn > 9999;\n              Leave;\n            EndIf;\n            Write UsrBkSfl;\n```\n\nThe association of the v_Rrrn with that particular subfile is specified when the file is declared.\n\n```rpgle\nDcl-F Admind Workstn Indds(#IndicatorDs) Sfile(UsrBkSfl:v_Rrn)\n```\n\n## Position To Loop\n\nIf `DBKPOSTO` is initialized from end user entering data on the related SFLCTL `USRBKCTL` and is not blank, the records are subset to those whose fields match the value of `DBKPOSTO`.\n\n```rpgle\n        v_Length = %Min(%Len(%Trim(DBKPOSTO)):%LEN(%Trim(BKID)));\n        Chain FltId FlightPf;\n        If %Found();\n          Chain AirId Airmaster;\n        Endif;\n\n       // checking if searched record is found or not\n        If %Check(%trim(DBKPOSTO):\n        %Subst(BKID:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(AIRNAME:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(FLTORIGIN:1:v_Length)) = 0 Or\n        %Check(%Trim(DBKPOSTO):\n        %Subst(FLTDEST:1:v_Length)) = 0;\n```\n\nThe very last record needs to be treated as a special case since the loop will not be entered since `%EOF()` will be true.\nSo it is processed after the loop. However it is not filtered based on the `DBKPOSTO` and so it is always included in the subfile.\n\n## Filter By Status Loop\n\nIf `DBKPSTO` is blank then a separate loop is entered visiting every booking.\n\nIf F4 was pressed then the `Prompt` indicator will be `*ON`.  This triggers subsetting of the records loaded into the subfile.   The criteria can be those records that are upcoming, completed or cancelled.\nOtherwise all records will be added to the subfile.\nThe the three state of which of the three  criteria are subset is active is represented efficiently using only 2 indicators.\n\n| Filter | `v_IndUpcoming` | `v_IndCompleted` |\n|-----------|--------|--------|\n| Upcoming  | `*OFF` | either |\n| Completed | `*ON`  | `*OFF` |\n| Cancelled | `*ON`  | `*ON`  |\n\nThis is reflected in the if statements guarding the three scenarios.\n\n```rpgle\n       // Loading only upcoming records\n        If BkStatus = 'U' and v_IndUpcoming = *Off;\n```\n\n```rpgle\n       // loading only completed records\n        ElseIf BkStatus = 'P' and v_IndUpcoming = *On\n        and v_IndCompleted = *Off;\n```\n\n```rpgle\n       // loading only cancelled records\n        ElseIf BkStatus = 'C' and v_IndCompleted = *On\n        and v_IndUpcoming = *On;\n```\n\nAt the end of the procedure, the booleans are cycled to the next state if the Prompt key was hit.\nThe order of progression is 'Upcoming -> 'Completed' -> 'Canceled'.\n\n```rpgle\n   // resetting the F4 key\n    If Prompt = *On;\n      Prompt = *Off;\n      If v_IndUpcoming = *Off;\n        v_IndUpcoming = *On;\n      ElseIf v_IndUpcoming = *On and v_IndCompleted = *Off;\n        v_IndCompleted = *On;\n      Else;\n        v_IndUpcoming = *Off;\n        v_IndCompleted = *Off;\n      EndIf;\n    EndIf;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINBKNGM_BookingLoad/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"how"}}
{"id":"ADMINGRVNM_GriefSubfile_sum","input_data":"  Dcl-Proc GriefSubfile Export;\n   // Clearing, Loading and Displaying Subfile MngGrvSfl\n    Dow Exit = *Off Or Cancel = *Off;\n     // Clearing Subfile MngGrvSfl\n      GrievClear();\n\n     // Loading Subfile MngGrvSfl\n      GrievLoad();\n\n     // Displaying Subfile MngGrvSfl\n      GrievDisplay();\n\n     // Screen Operations\n      Select;\n\n     // If user presses F3 or F12\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Reset MNGGRVCTL;\n        Reset SFLERROR;\n        v_OverlayInd = *Off;\n        Leave;\n\n     // If User Presses F5\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset MngGrvCtl;\n\n     // If User Presses Any other key\n      Other;\n       // Read Subfile MngGrvSfl\n        ReadGrvSfl();\n      Endsl;\n    Enddo;\n  End-Proc;","context":"     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;","output":"This fully-free ILE RPG procedure `GriefSubfile`  manages  grievance records by clearing, loading, and displaying the `MngGrvSfl` subfile. It handles user inputs, allowing navigation, refreshing and exiting while managing grievance-related operations efficiently.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GriefSubfile/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"sum"}}
{"id":"ADMINGRVNM_GriefSubfile_api","input_data":"  Dcl-Proc GriefSubfile Export;\n   // Clearing, Loading and Displaying Subfile MngGrvSfl\n    Dow Exit = *Off Or Cancel = *Off;\n     // Clearing Subfile MngGrvSfl\n      GrievClear();\n\n     // Loading Subfile MngGrvSfl\n      GrievLoad();\n\n     // Displaying Subfile MngGrvSfl\n      GrievDisplay();\n\n     // Screen Operations\n      Select;\n\n     // If user presses F3 or F12\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Reset MNGGRVCTL;\n        Reset SFLERROR;\n        v_OverlayInd = *Off;\n        Leave;\n\n     // If User Presses F5\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset MngGrvCtl;\n\n     // If User Presses Any other key\n      Other;\n       // Read Subfile MngGrvSfl\n        ReadGrvSfl();\n      Endsl;\n    Enddo;\n  End-Proc;","context":"     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;","output":"## Purpose\nThe fully-free ILE RPG procedure`GriefSubfile` manages the subfile `MngGrvSfl`, including clearing, loading, displaying and handling user interactions for grievance records.\n\n## Parameters\nThis procedure does not accept any input and output parameters.\n\n## Database\nReads and processes records from the `GRIEVPF` physical \n\n## Dependencies\n`GrievClear()` - Clears the subfile `MngGrvSfl`, removing any existing grievance records.\n`GrievLoad()` - Loads the grievance records from the `GRIEVPF` physical file into the subfile.\n`GrievDisplay()` - Displays the grievances in the subfile for user interaction.\n`ReadGrvSfl()` - Reads the subfile records to process user selections.\n`ManageGriev()` - Handles updates to grievance records when an admin selects a record.\n`ViewGriefDetail()` - Displays detailed information about a selected grievance.\n\n###  Global Variables\nThe procedure interacts with the following global variables:\n\nIndicators from IndicatorDs Data Structure:\n`Exit` - *IN03, used to `exit` the screen.\n`Cancel` - *IN12, used to `cancel` operations.\n`Refresh` - *IN05, used to `refresh` the subfile.\n`Prompt` - *IN04, used to toggle between pending and resolved grievances.\n`GrvSflDsp` - *IN49, controls subfile display.\n`GrvSflCtl` - *IN50, controls subfile operations.\n`GrvSflClr` - *IN51, clears subfile records.\n`GrvSflEnd` - *IN52, indicates the end of the subfile.\n`viewComplaint` - *IN80, used to manage grievance details.\n\nSubfile Control Variables:\n`v_Rrn` - Current relative record number for the subfile.\n`v_IndPending` - Controls whether pending or resolved grievances are displayed.\n`SFLERROR` - Displays messages when no grievances are found.\n`UserFld` - Displays the current user (Admin).\n`SflFtr` - Displays function key options on the screen.\n\nFunctionality\nClears, Loads, and Displays the Subfile `MngGrvSfl`:\nCalls `GrievClear()` to reset subfile content.\nCalls `GrievLoad()` to populate the subfile with grievances.\nCalls `GrievDisplay()` to show grievances to the user.\n\nHandles User Inputs:\n`F3` or `F12` (Exit or Cancel): Closes the subfile and exits the procedure.\n`F5` (Refresh): Reloads the subfile data.\n`F4` (Prompt): Toggles between pending and resolved grievances.\nReads subfile records and processes selected grievances.\n\nManages Grievance Selection (`ReadGrvSfl`)\nAllows an admin to manage or view grievances.\nCalls `ManageGriev()` to update grievance details.\nCalls `ViewGriefDetail()` to display grievance information.\n\n## Usage Example\nCall procedure `GriefSubfile` to display and manage grievance records.\n\n```rpgle\nGriefSubfile();\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GriefSubfile/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"api"}}
{"id":"ADMINGRVNM_GriefSubfile_how","input_data":"  Dcl-Proc GriefSubfile Export;\n   // Clearing, Loading and Displaying Subfile MngGrvSfl\n    Dow Exit = *Off Or Cancel = *Off;\n     // Clearing Subfile MngGrvSfl\n      GrievClear();\n\n     // Loading Subfile MngGrvSfl\n      GrievLoad();\n\n     // Displaying Subfile MngGrvSfl\n      GrievDisplay();\n\n     // Screen Operations\n      Select;\n\n     // If user presses F3 or F12\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Reset MNGGRVCTL;\n        Reset SFLERROR;\n        v_OverlayInd = *Off;\n        Leave;\n\n     // If User Presses F5\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset MngGrvCtl;\n\n     // If User Presses Any other key\n      Other;\n       // Read Subfile MngGrvSfl\n        ReadGrvSfl();\n      Endsl;\n    Enddo;\n  End-Proc;","context":"     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;","output":"The fully-free ILE RPG `GriefSubfile` procedure is designed to manage a subfile named `MngGrvSfl`. It follows a loop-based structure that keeps executing until an exit condition is met. The procedure handles three main operations: clearing, loading and displaying the subfile. It also includes user input handling for function keys.\n\n```rpgle\n  Dcl-Proc GriefSubfile Export;\n```\n\n- Declares a procedure named `GriefSubfile`, which is exported for use in other modules.\n\nLoop Execution Until Exit or Cancel\n\n```rpgle\n  Dow Exit = *Off Or Cancel = *Off;\n```\n\n- The `Dow` (Do While) loop continues running until either `Exit` or `Cancel` is turned on.\n- This ensures that the subfile keeps processing until the user explicitly chooses to exit.\n\nClearing, Loading, and Displaying the Subfile\n\n```rpgle\n  // Clearing Subfile MngGrvSfl\n  GrievClear();\n  // Loading Subfile MngGrvSfl\n  GrievLoad();\n  // Displaying Subfile MngGrvSfl\n  GrievDisplay();\n```\n\n- `GrievClear()`: Clears the subfile `MngGrvSfl`, ensuring no stale data is present.\n- `GrievLoad()`: Loads fresh data into the subfile.\n- `GrievDisplay()`: Displays the subfile on the screen.\nThese functions prepare the subfile for user interaction.\n\nHandling User Input\n\n```rpgle\n  // Screen Operations\n  Select;\n```\n- The `Select` statement is used to evaluate user input and execute corresponding actions.\n\nExit Handling (F3 or F12)\n\n```rpgle\nWhen Exit = *On Or Cancel = *On;\n  Cancel = *Off;\n  Reset MNGGRVCTL;\n  Reset SFLERROR;\n  v_OverlayInd = *Off;\n  Leave;\n```\n\n- If `F3` (Exit) or `F12` (Cancel) is pressed:\n  - `Cancel` flag is reset.\n  - `MngGrvCtl` (Control structure for the subfile) is reset.\n  - `SFLERROR` (Subfile error handling variable) is reset.\n  - `v_OverlayInd` is turned off (possibly hiding overlay screens).\n  - The loop is exited using `Leave`.\n\nRefresh Handling (F5)\n\n- If `F5` (Refresh) is pressed:\n  - The `Refresh` flag is reset.\n  - The `MngGrvCtl` is reset, ensuring a fresh load of data.\n\nDefault Action for Other Keys\n\n```rpgle\n  Other;\n  // Read Subfile MngGrvSfl\n  ReadGrvSfl();\n  Endsl;\n```\n\n- If the user presses any other key:\n  - The `ReadGrvSfl()` function is called to read the subfile data.\n\nEnd of Loop and Procedure\n\n- The loop continues until `Exit` or `Cancel` is activated.\n- The procedure ends when the user exits the subfile.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GriefSubfile/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"how"}}
{"id":"ADMINGRVNM_GrievClear_sum","input_data":"  Dcl-Proc GrievClear;\n    GrvSflClr = *On;\n    v_Rrn = 0;\n    Write MngGrvCtl;\n    GrvSflClr = *Off;\n  End-Proc;","context":"     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;\n  Dcl-S v_Rrn        Packed(4);","output":"This fully-free ILE RPG procedure `GrievClear` is to clear subfile `MngGrvSfl` in display file `Admind.dspf`.\nIt is part of fully-free ILE RPG program `ADMINGRVNM` that handles subfile operations for grievances.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GrievClear/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"proc","depth":"sum"}}
{"id":"ADMINGRVNM_GrievClear_api","input_data":"  Dcl-Proc GrievClear;\n    GrvSflClr = *On;\n    v_Rrn = 0;\n    Write MngGrvCtl;\n    GrvSflClr = *Off;\n  End-Proc;","context":"     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;\n  Dcl-S v_Rrn        Packed(4);","output":"## Purpose \n\nThis fully-free ILE RPG procedure `GrievClear` clears the subfile `MngGrvSfl` of display file `Admind.dspf` and sets program variable `v_Rrn` to zero.\n\n## Parameters \nNone \n\nThe following Global variable has been processed in this procedure.\n\n- `v_Rrn` - Relative record number of subfile `MngGrvSfl` of display file `Admind.dspf`. Variable declared in that program of numeric packed 4 bytes with zero decimals has been initialized to zero. \n\n### Usage example \n\nGrievClear(); \n\n### Dependencies \n\nThe following objects should be found in the library list.\n`Admind.dspf` is the display file object that is used for screen input/output.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GrievClear/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"proc","depth":"api"}}
{"id":"ADMINGRVNM_GrievClear_how","input_data":"  Dcl-Proc GrievClear;\n    GrvSflClr = *On;\n    v_Rrn = 0;\n    Write MngGrvCtl;\n    GrvSflClr = *Off;\n  End-Proc;","context":"     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;\n  Dcl-S v_Rrn        Packed(4);","output":"This fully-free ILE RPG procedure `GrievClear` is used to clear the subfile `MngGrvSfl` of display file `Admind.dspf` and sets relative record number program variable value to zero. \n\n Below are the steps involved.\nNamed Indicator `GrvSflClr` for Clearing subfile `MngGrvSfl` of display file `Admind.dspf` has been set On.\nRelative record number used in program variable 'v_Rrn' has been initialized to zero.\nWrite Control record format 'MngGrvCtl' for subfile `MngGrvSfl` of display file `Admind.dspf`.\nNamed Indicator `GrvSflClr` for Clearing subfile `MngGrvSfl` of display file `Admind.dspf` has been set Off.\n\n```Rpgle\n Dcl-Proc GrievClear;\n    GrvSflClr = *On;\n    v_Rrn = 0;\n    Write MngGrvCtl;\n    GrvSflClr = *Off;\n End-Proc;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GrievClear/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"proc","depth":"how"}}
{"id":"ADMINGRVNM_GrievLoad_sum","input_data":"  Dcl-Proc GrievLoad;\n    Setll *Loval GrievPf;\n\n   // Loading Records according to position to\n    If GrvPosTo <> *Blanks;\n      Read(N) GrievPf;\n      Dow Not %EOF();\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        Chain UsrId Usrmaster;\n        v_Length = %Min(%Len(%Trim(GRVPOSTO)):%Len(%Trim(GRVID)));\n\n       // Searched Record Found\n        If %Check(%Trim(GRVPOSTO):\n        %Subst(GRVID:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(FLTID:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(AIRNAME:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(USRNAME:1:v_Length)) = 0;\n          CID = GRVID;\n          CFID = FltId;\n         // Validation For CSTATUS\n          If GRVSTATUS = 'P';\n            CSTATUS = 'Pending';\n          ElseIf GRVSTATUS = 'R';\n            CSTATUS = 'Resolved';\n          Endif;\n          CAIRLINE = AirName;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Leave;\n        Else;\n          Read(N) GrievPf;\n        EndIf;\n      Enddo;\n\n     // Reading Last Record of file Grievpf\n      If GRVPOSTO <> *BLanks and %EOF();\n        Read(N) Grievpf;\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        Chain UsrId Usrmaster;\n        CID = GRVID;\n        CFID = FltId;\n\n       // Validation of CSTATUS\n        If GRVSTATUS = 'P';\n          CSTATUS = 'Pending';\n        ElseIf GRVSTATUS = 'R';\n          CSTATUS = 'Resolved';\n        Endif;\n        CAIRLINE = AirName;\n        CUSER = UsrName;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn value cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write MngGrvSfl;\n        Return;\n      EndIf;\n    EndIf;\n\n   // Loading all records of file GrievPf\n    Read(N) GrievPf;\n    Dow Not %EOF();\n     // Toggling Pending And Resolved Records\n      If Prompt = *On;\n\n       // Loading Pending Grievences\n        If GrvStatus = 'P' And v_IndPending = *Off;\n          CID = GRVID;\n          CFID = FltId;\n          CSTATUS = 'Pending';\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n          CAIRLINE = AirName;\n          Chain UsrId Usrmaster;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Read(N) Grievpf;\n\n       // Loading Resolved Grievences\n        ElseIf GrvStatus = 'R' and v_IndPending = *On;\n          CID = GRVID;\n          CFID = FltId;\n          CSTATUS = 'Resolved';\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n          CAIRLINE = AirName;\n          Chain UsrId Usrmaster;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Read(N) Grievpf;\n        Else;\n          Read(N) Grievpf;\n        Endif;\n\n     // Loading all the records\n      Else;\n        CID = GRVID;\n        CFID = FltId;\n       // Validation for CSTATUS\n        If GrvStatus = 'P';\n          CSTATUS = 'Pending';\n        ElseIf GRVSTATUS = 'R';\n          CSTATUS = 'Resolved';\n        EndIf;\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        CAIRLINE = AirName;\n        Chain UsrId Usrmaster;\n        CUSER = UsrName;\n        v_Rrn = v_Rrn + 1;\n\n       // Value Of Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Leave;\n        EndIf;\n        Write MngGrvSfl;\n        Read(N) Grievpf;\n      EndIf;\n    Enddo;\n  End-Proc;","context":"flightpf.table:\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Grievpf   Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Flightpf  Usage(*Input:*Output)         Keyed;\n  Dcl-F Airmaster Usage(*Input:*Output)         Keyed;\n  Dcl-F Usrmaster Usage(*Input:*Output)         Keyed;\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;\n  Dcl-S v_Rrn        Packed(4);\n  Dcl-S v_Length     Packed(2);\n  Dcl-S v_IndPending Ind Inz(*Off);","output":"This fully-free ILE Rpg procedure `GrievLoad` loads data from database file `GrievPf` into subfile screen. Data in subfile screen can be filtered based on `position to` or load all the records from database file `GrievPf` into subfile screen. Data records in Subfile screen can be toggled between Pending and Resolved grievences status.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GrievLoad/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"proc","depth":"sum"}}
{"id":"ADMINGRVNM_GrievLoad_api","input_data":"  Dcl-Proc GrievLoad;\n    Setll *Loval GrievPf;\n\n   // Loading Records according to position to\n    If GrvPosTo <> *Blanks;\n      Read(N) GrievPf;\n      Dow Not %EOF();\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        Chain UsrId Usrmaster;\n        v_Length = %Min(%Len(%Trim(GRVPOSTO)):%Len(%Trim(GRVID)));\n\n       // Searched Record Found\n        If %Check(%Trim(GRVPOSTO):\n        %Subst(GRVID:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(FLTID:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(AIRNAME:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(USRNAME:1:v_Length)) = 0;\n          CID = GRVID;\n          CFID = FltId;\n         // Validation For CSTATUS\n          If GRVSTATUS = 'P';\n            CSTATUS = 'Pending';\n          ElseIf GRVSTATUS = 'R';\n            CSTATUS = 'Resolved';\n          Endif;\n          CAIRLINE = AirName;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Leave;\n        Else;\n          Read(N) GrievPf;\n        EndIf;\n      Enddo;\n\n     // Reading Last Record of file Grievpf\n      If GRVPOSTO <> *BLanks and %EOF();\n        Read(N) Grievpf;\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        Chain UsrId Usrmaster;\n        CID = GRVID;\n        CFID = FltId;\n\n       // Validation of CSTATUS\n        If GRVSTATUS = 'P';\n          CSTATUS = 'Pending';\n        ElseIf GRVSTATUS = 'R';\n          CSTATUS = 'Resolved';\n        Endif;\n        CAIRLINE = AirName;\n        CUSER = UsrName;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn value cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write MngGrvSfl;\n        Return;\n      EndIf;\n    EndIf;\n\n   // Loading all records of file GrievPf\n    Read(N) GrievPf;\n    Dow Not %EOF();\n     // Toggling Pending And Resolved Records\n      If Prompt = *On;\n\n       // Loading Pending Grievences\n        If GrvStatus = 'P' And v_IndPending = *Off;\n          CID = GRVID;\n          CFID = FltId;\n          CSTATUS = 'Pending';\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n          CAIRLINE = AirName;\n          Chain UsrId Usrmaster;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Read(N) Grievpf;\n\n       // Loading Resolved Grievences\n        ElseIf GrvStatus = 'R' and v_IndPending = *On;\n          CID = GRVID;\n          CFID = FltId;\n          CSTATUS = 'Resolved';\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n          CAIRLINE = AirName;\n          Chain UsrId Usrmaster;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Read(N) Grievpf;\n        Else;\n          Read(N) Grievpf;\n        Endif;\n\n     // Loading all the records\n      Else;\n        CID = GRVID;\n        CFID = FltId;\n       // Validation for CSTATUS\n        If GrvStatus = 'P';\n          CSTATUS = 'Pending';\n        ElseIf GRVSTATUS = 'R';\n          CSTATUS = 'Resolved';\n        EndIf;\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        CAIRLINE = AirName;\n        Chain UsrId Usrmaster;\n        CUSER = UsrName;\n        v_Rrn = v_Rrn + 1;\n\n       // Value Of Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Leave;\n        EndIf;\n        Write MngGrvSfl;\n        Read(N) Grievpf;\n      EndIf;\n    Enddo;\n  End-Proc;","context":"flightpf.table:\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Grievpf   Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Flightpf  Usage(*Input:*Output)         Keyed;\n  Dcl-F Airmaster Usage(*Input:*Output)         Keyed;\n  Dcl-F Usrmaster Usage(*Input:*Output)         Keyed;\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;\n  Dcl-S v_Rrn        Packed(4);\n  Dcl-S v_Length     Packed(2);\n  Dcl-S v_IndPending Ind Inz(*Off);","output":"## Purpose \n\nThis fully-free ILE Rpg procedure `GrievLoad` loads data from database file `GrievPf` into subfile `MngGrvSfl` screen of display file `admind`. Data in subfile screen can be filtered based on `position to` or it will load all the records from database file `GrievPf` into subfile screen. Data records in Subfile can be toggled between Pending and resolved grievences status by pressing f4 prompt key.\n\n## Parameters \nNone\n\n## Global variables \nBelow mentioned Global variables are used in this procedure.\n\n- `GrvPosTo` - Position To screen field\n- `v_Rrn` - Variable to hold relative record number of last record loaded into the subfile\n- `Prompt` - Named indicator for function key f4\n- `v_IndPending` - Standalone indicator for pending complaints\n\n## Screen \nBelow mentioned Output fields in screen are populated from this procedure.\n\n- `CID` - Complaint Id\n- `CFID` - Flight Id \n- `CUSER` - User\n- `CAIRLINE` - Airline\n- `CSTATUS` - Status\n\n## Constraints\n\nSubfile screen can load and display data *Only till 9,999 records*. \n\n## Dependencies\n\nThe following objects should be found in library list.\n\n- `Admind` - display file object that is used for screen Input/Output\n- `Grievpf` - Grievance database input file\n- `Flightpf` - Flight details database input file \n- `Airmaster` - Airline Details databse input file \n- `Usrmaster` - User details database input file\n\n\n### Usage example\n```Rpgle\n         // Loading Subfile MngGrvSfl\n        GrievLoad();\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GrievLoad/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"proc","depth":"api"}}
{"id":"ADMINGRVNM_GrievLoad_how","input_data":"  Dcl-Proc GrievLoad;\n    Setll *Loval GrievPf;\n\n   // Loading Records according to position to\n    If GrvPosTo <> *Blanks;\n      Read(N) GrievPf;\n      Dow Not %EOF();\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        Chain UsrId Usrmaster;\n        v_Length = %Min(%Len(%Trim(GRVPOSTO)):%Len(%Trim(GRVID)));\n\n       // Searched Record Found\n        If %Check(%Trim(GRVPOSTO):\n        %Subst(GRVID:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(FLTID:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(AIRNAME:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(USRNAME:1:v_Length)) = 0;\n          CID = GRVID;\n          CFID = FltId;\n         // Validation For CSTATUS\n          If GRVSTATUS = 'P';\n            CSTATUS = 'Pending';\n          ElseIf GRVSTATUS = 'R';\n            CSTATUS = 'Resolved';\n          Endif;\n          CAIRLINE = AirName;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Leave;\n        Else;\n          Read(N) GrievPf;\n        EndIf;\n      Enddo;\n\n     // Reading Last Record of file Grievpf\n      If GRVPOSTO <> *BLanks and %EOF();\n        Read(N) Grievpf;\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        Chain UsrId Usrmaster;\n        CID = GRVID;\n        CFID = FltId;\n\n       // Validation of CSTATUS\n        If GRVSTATUS = 'P';\n          CSTATUS = 'Pending';\n        ElseIf GRVSTATUS = 'R';\n          CSTATUS = 'Resolved';\n        Endif;\n        CAIRLINE = AirName;\n        CUSER = UsrName;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn value cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write MngGrvSfl;\n        Return;\n      EndIf;\n    EndIf;\n\n   // Loading all records of file GrievPf\n    Read(N) GrievPf;\n    Dow Not %EOF();\n     // Toggling Pending And Resolved Records\n      If Prompt = *On;\n\n       // Loading Pending Grievences\n        If GrvStatus = 'P' And v_IndPending = *Off;\n          CID = GRVID;\n          CFID = FltId;\n          CSTATUS = 'Pending';\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n          CAIRLINE = AirName;\n          Chain UsrId Usrmaster;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Read(N) Grievpf;\n\n       // Loading Resolved Grievences\n        ElseIf GrvStatus = 'R' and v_IndPending = *On;\n          CID = GRVID;\n          CFID = FltId;\n          CSTATUS = 'Resolved';\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n          CAIRLINE = AirName;\n          Chain UsrId Usrmaster;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Read(N) Grievpf;\n        Else;\n          Read(N) Grievpf;\n        Endif;\n\n     // Loading all the records\n      Else;\n        CID = GRVID;\n        CFID = FltId;\n       // Validation for CSTATUS\n        If GrvStatus = 'P';\n          CSTATUS = 'Pending';\n        ElseIf GRVSTATUS = 'R';\n          CSTATUS = 'Resolved';\n        EndIf;\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        CAIRLINE = AirName;\n        Chain UsrId Usrmaster;\n        CUSER = UsrName;\n        v_Rrn = v_Rrn + 1;\n\n       // Value Of Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Leave;\n        EndIf;\n        Write MngGrvSfl;\n        Read(N) Grievpf;\n      EndIf;\n    Enddo;\n  End-Proc;","context":"flightpf.table:\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadmingrvnm.rpgle:\n  Dcl-F Grievpf   Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Flightpf  Usage(*Input:*Output)         Keyed;\n  Dcl-F Airmaster Usage(*Input:*Output)         Keyed;\n  Dcl-F Usrmaster Usage(*Input:*Output)         Keyed;\n  Dcl-F Admind Workstn Indds(#IndicatorDs) Sfile(MngGrvSfl:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit          Ind Pos(03);\n    Prompt        Ind Pos(04);\n    Refresh       Ind Pos(05);\n    Confirm       Ind Pos(06);\n    Cancel        Ind Pos(12);\n   // Subfile Indicator\n    GrvSflDsp     Ind Pos(49);\n    GrvSflCtl     Ind Pos(50);\n    GrvSflClr     Ind Pos(51);\n    GrvSflEnd     Ind Pos(52);\n   // Field Indicator;\n    viewComplaint Ind Pos(80);\n    v_OverlayInd  Ind Pos(85);\n  End-DS;\n  Dcl-S v_Rrn        Packed(4);\n  Dcl-S v_Length     Packed(2);\n  Dcl-S v_IndPending Ind Inz(*Off);","output":"This fully-free ILE Rpg procedure `GrievLoad` loads data from database file `GrievPf` into subfile `MngGrvSfl` screen of display file `admind`. Data in subfile screen can be filtered based on `position to` or it will load all the records from database file `GrievPf` into subfile screen. Data records in Subfile screen can be toggled between Pending and resolved Grievances status.\n\n### Below are the details\n\nThis free-form procedure is declared with no parameters. Start processing all records from database file `GrievPf`.\n\n```rpgle\n        Dcl-Proc GrievLoad;\n         Setll *Loval GrievPf;\n```\n\n## Position-To screen field\n\nBased on `Position to` screen field load record from database file.\nWhen it is not blanks within a Loop read all the records from `GrievPf` database file.\n\n```rpgle\n      // Loading Records according to position to\n        If GrvPosTo <> *Blanks;\n         Read(N) GrievPf;\n          Dow Not %EOF();\n```\n\nFrom database files `Flightpf,Airmaster,Usrmaster` fetch exact record for key field values `Fltid,Airid,UsrId` respectively.\nFetch minimum length between `position to` screen field and `Grievances id` database file field.\n\n```rpgle\n        Chain FltId FlightPf;\n        Chain AirId Airmaster;\n        Chain UsrId Usrmaster;\n        v_Length = %Min(%Len(%Trim(GRVPOSTO)):%Len(%Trim(GRVID)));\n```\n\nCheck if `Position to` value is found in `Grievances Id` or\n `flight Id` Or `Airline name` Or `User name` database file fields.\n\n```rpgle\n// Searched Record Found\n        If %Check(%Trim(GRVPOSTO):\n        %Subst(GRVID:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(FLTID:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(AIRNAME:1:v_Length)) = 0 Or\n        %Check(%Trim(GRVPOSTO):\n        %Subst(USRNAME:1:v_Length)) = 0;\n```\n\n If record exists populate Subfile fields `MNGGRVSFL` of `admind` display file\n as per below mappings.\n\n | Subfile screen field | Database file name | Database file field |\n |----------------------|--------------------|---------------------|\n | `CID`                | `Grievpf`          |   `GRVID`           |\n | `CFID`               | `FlightPf`         |   `FltId`           |\n | `CAIRLINE`           | `Airmaster`        |   `AirName`         |\n | `CUSER`              | `Usrmaster`        |  `UsrName`          |\n\n | Subfile screen field | Database file name | Database file field | Hardcoded value | Condition       |\n |----------------------|--------------------|---------------------|-----------------|-----------------|\n | `CSTATUS`            | `Grievpf`          |   `GRVSTATUS`       |   \"Pending\"     | GRVSTATUS = 'P' |\n | `CSTATUS`            | `Grievpf`          |   `GRVSTATUS`       |   \"Resolved\"    | GRVSTATUS = 'R' |\n\n``` rpgle\n        CID = GRVID;\n        CFID = FltId;\n          // Validation For CSTATUS\n              If GRVSTATUS = 'P';\n                CSTATUS = 'Pending';\n              ElseIf GRVSTATUS = 'R';\n                CSTATUS = 'Resolved\n              Endif;\n        CAIRLINE = AirName;\n        CUSER = UsrName;\n```\n\nIncrement Relative record number (Rrn) value by one. when Rrn value greater than 9,999 then exit from this loop.\nWrite a record to subfile `MngGrvSfl` of `admind` display file and exit from this loop.\nIf `position to` record Not found continue the loop to read all records from database file `GrievPf`.\n\n```rpgle\n          v_Rrn = v_Rrn + 1;\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n        Write MngGrvSfl;\n         Leave;\n        Else;\n          Read(N) GrievPf;\n        EndIf;\n       Enddo;\n```\n\nWhen `position to` record Not found in database file `Grievpf`\nread last record from database file `Grievpf` and write it into subfile `MngGrvSfl` screen of display file `admind` as per above field mapping and return back to the caller.\n\n```rpgle\n     // Reading Last Record of file Grievpf\n      If GRVPOSTO <> *BLanks and %EOF();\n         Read(N) Grievpf;\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n          Chain UsrId Usrmaster;\n         CID = GRVID;\n         CFID = FltId;\n      // Validation of CSTATUS\n        If GRVSTATUS = 'P';\n          CSTATUS = 'Pending';\n        ElseIf GRVSTATUS = 'R';\n          CSTATUS = 'Resolved';\n        Endif;\n          CAIRLINE = AirName;\n          CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n       // Rrn value cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write MngGrvSfl;\n        Return;\n      EndIf;\n    EndIf;\n```\n\n## prompt key for Toggling between pending and Resolved status records\n\n*Scenario 1:* When `position to` is blanks, it will load all the records from the database file `Grievpf` into subfile  `MngGrvSfl` of display file `admind`.\n*Scenario 2:* When `position to` is Not blanks, after matching record already loaded into subfile. Remaining records\nfrom database file `Grievpf` are loaded into subfile  `MngGrvSfl` of display file `admind`.\n\nRead all the records from database file `GrievPf` in a loop.\nWhen prompt f4 function key is on.\n\n```rpgle\n  // Loading all records of file GrievPf\n        Read(N) GrievPf;\n       Dow Not %EOF();\n          // Toggling Pending And Resolved Records\n          If Prompt = *On;\n```\n\n## Loading Pending Grievances\n\nCheck if `GrvStatus` database file field of database file `GrievPf` is `'P'` and pending named indicator `v_IndPending` is off. Set subfile screen field `Status` as `Pending`.\n\n```rpgle\n       // Loading Pending Grievances\n        If GrvStatus = 'P' And v_IndPending = *Off;\n          CID = GRVID;\n          CFID = FltId;\n          CSTATUS = 'Pending';\n```\n\nMapping for remaining display subfile `MngGrvSfl` screen fields same as above.\nWrite records to subfile `MngGrvSfl` of display file `admind`. read records from `Grievpf` database file.\n\n```rpgle\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n            CAIRLINE = AirName;\n          Chain UsrId Usrmaster;\n            CUSER = UsrName;\n          v_Rrn = v_Rrn + 1;\n         // Rrn value cannot be greater than 9999\n          If v_Rrn > 9999;\n            Leave;\n          EndIf;\n          Write MngGrvSfl;\n          Read(N) Grievpf;\n```\n\n## Loading Resolved Grievances\n\nCheck if `GrvStatus` database file field of database file `GrievPf` is `'R'` and pending named indicator `v_IndPending` is on. Set subfile screen field `Status` as `Resolved`. mapping for subfile screen fields are same as above.\n\n```rpgle\n   // Loading Resolved Grievances\n        ElseIf GrvStatus = 'R' and v_IndPending = *On;\n            CID = GRVID;\n            CFID = FltId;\n            CSTATUS = 'Resolved';\n          Chain FltId FlightPf;\n          Chain AirId Airmaster;\n            CAIRLINE = AirName;\n          Chain UsrId Usrmaster;\n            CUSER = UsrName;\n```\n\nWrite records to subfile `MngGrvSfl` of display file `admind`. In either condition\ncontinue to read all the records from database file `Grievpf` in a loop.\n\n```rpgle\n          v_Rrn = v_Rrn + 1;\n          // Rrn value cannot be greater than 9999\n         If v_Rrn > 9999;\n          Leave;\n         EndIf;\n           Write MngGrvSfl;\n          Read(N) Grievpf;\n        Else;\n          Read(N) Grievpf;\n        Endif;\n```\n\n## Loading All Records from `Grievpf` database file\n\nWhen Prompt function key f4 is off populate subfile screen `MNGGRVSFL` fields as per mappings mentioned above.\n\n```rpgle\n     // Loading all the records\n      Else;\n        CID = GRVID;\n        CFID = FltId;\n       // Validation for CSTATUS\n        If GrvStatus = 'P';\n          CSTATUS = 'Pending';\n        ElseIf GRVSTATUS = 'R';\n          CSTATUS = 'Resolved';\n        EndIf;\n         Chain FltId FlightPf;\n         Chain AirId Airmaster;\n          CAIRLINE = AirName;\n         Chain UsrId Usrmaster;\n          CUSER = UsrName;\n```\n\nWrite Records to subfile `MNGGRVSFL` from database file `GrievPf` continue to read all\nthe records from database file `Grievpf` in a loop.\n\n```rpgle\n        v_Rrn = v_Rrn + 1;\n       // Value Of Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Leave;\n        EndIf;\n         Write MngGrvSfl;\n        Read(N) Grievpf;\n      EndIf;\n    Enddo;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINGRVNM_GrievLoad/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"proc","depth":"how"}}
{"id":"ADMINM_AdminDashBoard_sum","input_data":"  Dcl-Proc AdminDashboard Export;\n   Clear AdminError;\n\n  // Display screen Admindash\n   Dow Exit = *Off Or Cancel = *Off;\n    Cancel = *Off;\n    Userfld = 'Admin';\n    Write Header;\n    Exfmt Admindash;\n\n   // Handle Screen Operations\n    Select;\n\n   // Exit out of screen AdminDash\n    When Exit = *On Or Cancel = *On;\n     Cancel = *Off;\n     Leave;\n\n   // Reset the screen AdminDash\n    When Refresh = *On;\n     Refresh = *Off;\n     Reset AdminDash;\n\n   // List of All Airlines\n    When DADMININP  = 1;\n     Clear DADMININP;\n     AirSubfile();\n\n   // List of all customers\n    When DADMININP = 2;\n     Clear DADMININP;\n     UserSubfile();\n\n   // List of all bookings\n    When DADMININP = 3;\n     Clear DADMININP;\n     BookingSubfile();\n\n   // List of all flights\n    When DADMININP = 4;\n     Clear DADMININP;\n     FlightSubfile();\n\n   // List of all the complaints\n    When DADMININP = 5;\n     Clear DADMININP;\n     GriefSubfile();\n\n   // Manage control table\n    When DADMININP = 6;\n     Clear DADMININP;\n     ControlSubfile();\n\n   // Invalid Input\n    Other;\n     AdminError = 'Invalid Operation';\n     Clear DADMININP;\n    Endsl;\n   Enddo;\n  End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadminm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit Ind Pos(3);\n    Refresh Ind Pos(5);\n    Cancel Ind Pos(12);\n  End-Ds;","output":"This fully-free ILE RPG procedure `AdminDashboard` provides an interface for administrators to manage airline-related data. It allows viewing and managing airlines, customers, bookings, flights, complaints, and system controls while handling screen navigation.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINM_AdminDashBoard/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"sum"}}
{"id":"ADMINM_AdminDashBoard_api","input_data":"  Dcl-Proc AdminDashboard Export;\n   Clear AdminError;\n\n  // Display screen Admindash\n   Dow Exit = *Off Or Cancel = *Off;\n    Cancel = *Off;\n    Userfld = 'Admin';\n    Write Header;\n    Exfmt Admindash;\n\n   // Handle Screen Operations\n    Select;\n\n   // Exit out of screen AdminDash\n    When Exit = *On Or Cancel = *On;\n     Cancel = *Off;\n     Leave;\n\n   // Reset the screen AdminDash\n    When Refresh = *On;\n     Refresh = *Off;\n     Reset AdminDash;\n\n   // List of All Airlines\n    When DADMININP  = 1;\n     Clear DADMININP;\n     AirSubfile();\n\n   // List of all customers\n    When DADMININP = 2;\n     Clear DADMININP;\n     UserSubfile();\n\n   // List of all bookings\n    When DADMININP = 3;\n     Clear DADMININP;\n     BookingSubfile();\n\n   // List of all flights\n    When DADMININP = 4;\n     Clear DADMININP;\n     FlightSubfile();\n\n   // List of all the complaints\n    When DADMININP = 5;\n     Clear DADMININP;\n     GriefSubfile();\n\n   // Manage control table\n    When DADMININP = 6;\n     Clear DADMININP;\n     ControlSubfile();\n\n   // Invalid Input\n    Other;\n     AdminError = 'Invalid Operation';\n     Clear DADMININP;\n    Endsl;\n   Enddo;\n  End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadminm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit Ind Pos(3);\n    Refresh Ind Pos(5);\n    Cancel Ind Pos(12);\n  End-Ds;","output":"## Purpose\n\nThe fully-free ILE RPG procedure `AdminDashboard` provides an interface for administrators to manage various aspects of the airline system, such as airlines, customers, bookings, flights, complaints, and system controls. It also handles user interactions, refresh operations, and error handling.  \n\n## Parameters\n\n- None\n\n## Impacts\n### Global Variables \n\n| Variable Name | Description |  \n|------------------|----------------|  \n| `AdminError`    | Stores error messages for invalid operations |  \n| `Userfld`       | Stores the logged-in user type (set as 'Admin') |  \n| `DADMININP`     | Stores the user input to determine which operation to perform |  \n\n### Indicators Used  \n| Indicator Name | Indicator Number | Usage |  \n|------------------|-------------|---------|  \n| `Exit`         | *IN03         | Used to exit the Admin Dashboard |  \n| `Refresh`      | *IN05           | Used to refresh the Admin Dashboard screen |  \n| `Cancel`       | *IN12          | Used to cancel and exit the screen |  \n\n## Dependencies\n### Subprocedures Used in the Procedure \n- `AirSubfile`  Displays a list of all airlines.  \n- `UserSubfile`  Displays a list of all customers.  \n- `BookingSubfile`  Displays a list of all bookings.  \n- `FlightSubfile`  Displays a list of all flights.  \n- `GriefSubfile`  Displays a list of all complaints.  \n- `ControlSubfile`  Manages control table data.  \n\n## Usage Example\n- In an RPGLE program, you can call the `AdminDashboard` procedure as follows:  \n```rpgle\n        AdminDashboard();\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINM_AdminDashBoard/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"api"}}
{"id":"ADMINM_AdminDashBoard_how","input_data":"  Dcl-Proc AdminDashboard Export;\n   Clear AdminError;\n\n  // Display screen Admindash\n   Dow Exit = *Off Or Cancel = *Off;\n    Cancel = *Off;\n    Userfld = 'Admin';\n    Write Header;\n    Exfmt Admindash;\n\n   // Handle Screen Operations\n    Select;\n\n   // Exit out of screen AdminDash\n    When Exit = *On Or Cancel = *On;\n     Cancel = *Off;\n     Leave;\n\n   // Reset the screen AdminDash\n    When Refresh = *On;\n     Refresh = *Off;\n     Reset AdminDash;\n\n   // List of All Airlines\n    When DADMININP  = 1;\n     Clear DADMININP;\n     AirSubfile();\n\n   // List of all customers\n    When DADMININP = 2;\n     Clear DADMININP;\n     UserSubfile();\n\n   // List of all bookings\n    When DADMININP = 3;\n     Clear DADMININP;\n     BookingSubfile();\n\n   // List of all flights\n    When DADMININP = 4;\n     Clear DADMININP;\n     FlightSubfile();\n\n   // List of all the complaints\n    When DADMININP = 5;\n     Clear DADMININP;\n     GriefSubfile();\n\n   // Manage control table\n    When DADMININP = 6;\n     Clear DADMININP;\n     ControlSubfile();\n\n   // Invalid Input\n    Other;\n     AdminError = 'Invalid Operation';\n     Clear DADMININP;\n    Endsl;\n   Enddo;\n  End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       10A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nadminm.rpgle:\n  Dcl-F Admind Workstn Indds(#IndicatorDs);\n  Dcl-Ds #IndicatorDs;\n   // Function Keys\n    Exit Ind Pos(3);\n    Refresh Ind Pos(5);\n    Cancel Ind Pos(12);\n  End-Ds;","output":"The `AdminDashboard` procedure is responsible for handling the admin dashboard interface. It continuously loops, displaying a menu and processing the selected operations until the user exits or cancels.\n\n## Explanation\n\n### 1. Procedure Declaration and Initialization\n- At the beginning, the procedure is declared and `AdminError` is cleared to remove any previous error messages.\n- Prepares the procedure for execution and ensures no previous errors interfere.\n```rpgle\n\t\tDcl-Proc AdminDashboard Export;  \n\t\tClear AdminError;\n```\n\n### 2. Start the Admin Dashboard Loop\n- The `Dow` (Do-While) loop keeps running until the admin chooses to exit or cancel.\n- The loop continues as long as neither `Exit` nor `Cancel` is set to `*On`.\n- If the user selects an option, the loop will process it before redisplaying the dashboard.\n```rpgle\n\t\tDow Exit = *Off Or Cancel = *Off;\n```\n\n### 3. Reset Cancel Flag and Display Dashboard Screen\nBefore waiting for user input, we reset the cancel flag and display the `Admindash` screen.\n```rpgle\n\t\tCancel = *Off;\n\t\tUserfld = 'Admin';\n\t\tWrite Header;\n\t\tExfmt Admindash;\n```\n- `Cancel = *Off;` ensures that the cancel operation does not remain active from previous iterations.\n- `Userfld = 'Admin';` identifies the logged-in user as an admin.\n- `Write Header;` writes the screen header.\n- `Exfmt Admindash;` displays the `Admindash` screen and waits for the user to enter input.\n\n### 4. Process the User Input using a `Select` Statement\n- Once the user enters a value, we determine what operation to perform.\n- This block helps execute different actions based on `DADMININP` (admin's input).\n```rpgle\nSelect;\n```\n\n### 5. Handling Exit or Cancel\n- If the user presses the exit or cancel button, the loop terminates.\n- `Cancel = *Off;` resets the cancel flag.\n- `Leave;` exits the loop, ending the procedure.\n```rpgle\n\t\tWhen Exit = *On Or Cancel = *On;\n\t\t\tCancel = *Off;\n\t\t\tLeave;\n```\n\n### 6. Refreshing the Screen\n- If the refresh key is pressed, reset the screen.\n- `Refresh = *Off;` clears the refresh flag.\n- `Reset AdminDash;` resets the dashboard screen.\n```rpgle\n\t\tWhen Refresh = *On;\n\t\t\tRefresh = *Off;\n\t\t\tReset AdminDash;\n```\n\n### 7. Processing Different Admin Operations\n- Depending on the input (`DADMININP`), different subprocedures are executed.\n\n#### 7.1 List All Airlines\n```rpgle\n\t\tWhen DADMININP = 1;\n\t\t\tClear DADMININP;\n\t\t\tAirSubfile();\n```\n- Clears the admin input (`DADMININP`).\n- Calls `AirSubfile()` to retrieve and display all airlines.\n\n#### 7.2 List All Customers\n```rpgle\n\t\tWhen DADMININP = 2;\n\t\t\tClear DADMININP;\n\t\t\tUserSubfile();\n```\n- Calls `UserSubfile()` to list all customers.\n\n#### 7.3 List All Bookings\n```rpgle\n\t\tWhen DADMININP = 3;\n\t\t\tClear DADMININP;\n\t\t\tBookingSubfile();\n```\n- Calls `BookingSubfile()` to retrieve all bookings.\n\n#### 7.4 List All Flights\n```rpgle\n\t\tWhen DADMININP = 4;\n\t\t\tClear DADMININP;\n\t\t\tFlightSubfile();\n```\n- Calls `FlightSubfile()` to list all flights.\n\n#### 7.5 List All Complaints\n```rpgle\n\t\tWhen DADMININP = 5;\n\t\t\tClear DADMININP;\n\t\t\tGriefSubfile();\n```\n- Calls `GriefSubfile()` to retrieve customer complaints.\n\n#### 7.6 Manage Control Table\n```rpgle\n\t\tWhen DADMININP = 6;\n\t\t\tClear DADMININP;\n\t\t\tControlSubfile();\n```\n- Calls `ControlSubfile()` to manage admin control settings.\n\n### 8. Handling Invalid Input\nIf the user enters an invalid operation, an error message is displayed.\n```rpgle\n\t\tOther;\n\t\t\tAdminError = 'Invalid Operation';\n\t\t\tClear DADMININP;\n```\n- Displays the error message (`'Invalid Operation'`).\n- Clears the input (`DADMININP`) so the user can try again.\n\n### 9. End the Loop and Procedure\n- Once the user decides to exit, the loop terminates.\n- `Enddo;` marks the end of the loop.\n- `End-Proc;` ends the procedure.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/ADMINM_AdminDashBoard/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"proc","depth":"how"}}
{"id":"AIRLINEM_Airdashboard_sum","input_data":"     PAirdashboard     B                   Export\n     DAirdashboard     PI\n     Dp_AirlineId                     5A\n     Dp_AIrlineName                  15A\n     C                   Clear                   AirError\n     C                   Eval      UserFld = p_AirlineName\n\n     ** Displaying The Screen AirDash\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Write     Header\n     C                   Exfmt     AirDash\n\n     ** Handling Screen Operations\n     C                   Select\n     ** If input for AirChInp is 1, then call subprocedure ScheduleFlight\n     C                   When      AirChInp = 1\n     C                   Clear                   AirChInp\n     ** Subprocedure to schedule flight\n     C                   Callp     ScheduleFlight(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 2, then call subprocedure MngFlightSfl\n     C                   When      AirChInp = 2\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle subfile for flights\n     C                   Callp     MngFlightSfl(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 3, then call subprocedure MngBookingSfl\n     C                   When      AirChInp = 3\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle subfile for bookings\n     C                   Callp     MngBookingSfl(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 4, then call subprocedure AirlineProfile\n     C                   When      AirChInp = 4\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle the airline profile\n     C                   Callp     AirlineProfile(p_AirlineId)\n     ** If input for AirChInp is 5, then call subprocedure ChangePassword\n     C                   When      AirChInp = 5\n     C                   Clear                   AirChInp\n     ** Subprocedure to change airline profile password\n     C                   Callp     ChangePassword(p_AirlineId)\n     ** If user presses F3 Or F12 then exit out of screen\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Leave\n     C                   Return\n     ** If user presses F5 then screen will be refreshed\n     C                   When      Refresh = *On\n     C                   Eval      Refresh = *Off\n     C                   Reset                   AirDash\n     C                   Endsl\n     C                   Enddo\n     PAirdashboard     E","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairlinem.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DCancel                          1N   Overlay(#IndicatorDs:12)","output":"This fixed-form RPGLE procedure `Airdashboard` procedure serves as the main dashboard for airline administrators. It allows them to manage flight schedules, view and update flight and booking details, manage airline profiles, and change passwords.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRLINEM_Airdashboard/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"sum"}}
{"id":"AIRLINEM_Airdashboard_api","input_data":"     PAirdashboard     B                   Export\n     DAirdashboard     PI\n     Dp_AirlineId                     5A\n     Dp_AIrlineName                  15A\n     C                   Clear                   AirError\n     C                   Eval      UserFld = p_AirlineName\n\n     ** Displaying The Screen AirDash\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Write     Header\n     C                   Exfmt     AirDash\n\n     ** Handling Screen Operations\n     C                   Select\n     ** If input for AirChInp is 1, then call subprocedure ScheduleFlight\n     C                   When      AirChInp = 1\n     C                   Clear                   AirChInp\n     ** Subprocedure to schedule flight\n     C                   Callp     ScheduleFlight(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 2, then call subprocedure MngFlightSfl\n     C                   When      AirChInp = 2\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle subfile for flights\n     C                   Callp     MngFlightSfl(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 3, then call subprocedure MngBookingSfl\n     C                   When      AirChInp = 3\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle subfile for bookings\n     C                   Callp     MngBookingSfl(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 4, then call subprocedure AirlineProfile\n     C                   When      AirChInp = 4\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle the airline profile\n     C                   Callp     AirlineProfile(p_AirlineId)\n     ** If input for AirChInp is 5, then call subprocedure ChangePassword\n     C                   When      AirChInp = 5\n     C                   Clear                   AirChInp\n     ** Subprocedure to change airline profile password\n     C                   Callp     ChangePassword(p_AirlineId)\n     ** If user presses F3 Or F12 then exit out of screen\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Leave\n     C                   Return\n     ** If user presses F5 then screen will be refreshed\n     C                   When      Refresh = *On\n     C                   Eval      Refresh = *Off\n     C                   Reset                   AirDash\n     C                   Endsl\n     C                   Enddo\n     PAirdashboard     E","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairlinem.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DCancel                          1N   Overlay(#IndicatorDs:12)","output":"## Purpose\n\n---\n\n- The fixed-form RPGLE procedure `AirDashBoard` defines a procedure that displays a screen for managing airline operations. \n- It waits for the user's input and performs specific actions based on their selection.\n\n## Parameters\n\n---\n\n- `p_AirlineId`: A 5-character alphanumeric input for airline's unique identifier.\n- `p_AirlineName`: A 15-character alphanumeric input for airline's name.\n\n## Impacts\n\n---\n\n### **Global Variables**  \n\n| Variable Name | Description |\n|---------------|-------------|\n| `AirError`    | Used to store errors |\n| `UserFld`     | Stores the airline name for display |\n| `Exit`        | Controls exit operation |\n| `Cancel`      | Controls cancel operation |\n| `AirChInp`    | Stores user input choice for operations |\n| `Refresh`     | Controls screen refresh |\n\n### **Subprocedures**  \n\n- The subprocedures mentioned below are used in the procedure `AirDashBoard`:\n\n| **Subprocedure Name** | **Purpose** |\n|----------------------|------------|\n| **`ScheduleFlight`** | Schedules a new flight for the airline. |\n| **`MngFlightSfl`** | Manages the subfile for flights, likely for viewing and modifying flight records. |\n| **`MngBookingSfl`** | Manages the subfile for bookings, likely for tracking and modifying bookings. |\n| **`AirlineProfile`** | Displays and allows modifications to the airlines profile information. |\n| **`ChangePassword`** | Allows the airline to change its account password. |\n\n### **Dependencies**  \n\n- The procedure `AirDashBoard` depends on the `AIRLINED` display file which contains the below record formats:\n\n| **Record Fomat Name** | **Purpose** |\n|----------------------|------------|\n| **`Header`** | Displays the header information on the dashboard screen. |\n| **`AirDash`** | The main screen format used in the airline dashboard interface. |","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRLINEM_Airdashboard/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"api"}}
{"id":"AIRLINEM_Airdashboard_how","input_data":"     PAirdashboard     B                   Export\n     DAirdashboard     PI\n     Dp_AirlineId                     5A\n     Dp_AIrlineName                  15A\n     C                   Clear                   AirError\n     C                   Eval      UserFld = p_AirlineName\n\n     ** Displaying The Screen AirDash\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Write     Header\n     C                   Exfmt     AirDash\n\n     ** Handling Screen Operations\n     C                   Select\n     ** If input for AirChInp is 1, then call subprocedure ScheduleFlight\n     C                   When      AirChInp = 1\n     C                   Clear                   AirChInp\n     ** Subprocedure to schedule flight\n     C                   Callp     ScheduleFlight(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 2, then call subprocedure MngFlightSfl\n     C                   When      AirChInp = 2\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle subfile for flights\n     C                   Callp     MngFlightSfl(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 3, then call subprocedure MngBookingSfl\n     C                   When      AirChInp = 3\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle subfile for bookings\n     C                   Callp     MngBookingSfl(p_AirlineId:p_AirlineName)\n     ** If input for AirChInp is 4, then call subprocedure AirlineProfile\n     C                   When      AirChInp = 4\n     C                   Clear                   AirChInp\n     ** Subprocedure to handle the airline profile\n     C                   Callp     AirlineProfile(p_AirlineId)\n     ** If input for AirChInp is 5, then call subprocedure ChangePassword\n     C                   When      AirChInp = 5\n     C                   Clear                   AirChInp\n     ** Subprocedure to change airline profile password\n     C                   Callp     ChangePassword(p_AirlineId)\n     ** If user presses F3 Or F12 then exit out of screen\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Leave\n     C                   Return\n     ** If user presses F5 then screen will be refreshed\n     C                   When      Refresh = *On\n     C                   Eval      Refresh = *Off\n     C                   Reset                   AirDash\n     C                   Endsl\n     C                   Enddo\n     PAirdashboard     E","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairlinem.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DCancel                          1N   Overlay(#IndicatorDs:12)","output":"The fixed-form RPGLE procedure `AirDashBoard` manages an airline dashboard, allowing users to perform various operations such as scheduling flights, managing flight and booking records, viewing airline profiles, and changing passwords.\n\nThe program continuously displays the `AirDash` screen until the user decides to exit.\n`PAirdashboard B Export`: Marks the beginning of the program and allows it to be called externally.\n`DAirdashboard PI`: Defines a procedure interface.\n`p_AirlineId` & `p_AirlineName`: Parameters representing the airline's unique ID and name, passed when the procedure is called.\n\nDisplaying the Screen\n```rpg\n        C                   Dow       Exit = *Off Or Cancel = *Off  \n        C                   Write     Header  \n        C                   Exfmt     AirDash  \n```\n- Ensures that the screen remains active until the user chooses to exit.\n- Display the header section of the screen.\n- Display the AirDash screen and waits for user input.\nHandling Screen Operations\n\nUser Input Processing\n- `Select`: Begins a conditional structure to process user inputs.\n\nSchedule a Flight (Option 1)\n- If the user selects option 1, schedule a flight.\n- Clears the selection to prevent reuse of the same value.\n- `p_AirlineId`:`p_AirlineName`: Calls the ScheduleFlight subprocedure with the airline ID and name.\n\nManage Flight Subfile (Option 2)\n- Calls the `MngFlightSfl` subprocedure for managing flight details.\n\nManage Booking Subfile (Option 3)\n- Calls the `MngBookingSfl` subprocedure for handling booking records.\n\nView Airline Profile (Option 4)\n- Calls the `AirlineProfile` subprocedure to display the airline's profile.\n\nChange Airline Password (Option 5)\n- Calls the `ChangePassword` subprocedure to update the airlines password.\n\nExit and Refresh Handling:\nExit the Screen\n```rpg\n        C                   When      Exit = *On Or Cancel = *On  \n        C                   Eval      Cancel = *Off  \n        C                   Leave  \n        C                   Return  \n```\n- If the user presses `F3` (Exit) or `F12` (Cancel), the screen exits.\n- `Cancel` = `*Off`: Resets the cancel flag.\n- `Leave`: Exits the Dow loop.\n- `Return`: Ends the procedure execution.\n\nRefresh the Screen\n```rpg\n        C                   When      Refresh = *On  \n        C                   Eval      Refresh = *Off  \n        C                   Reset                   AirDash  \n```\n- If the user presses `F5` (Refresh), the screen reloads with fresh data.\n- `Reset AirDash` - Clears previous screen content and reloads it.\n- `Endsl` - Ends the Select statement.\n- `Enddo` - Ends the loop.\n- `PAirdashboard` - Marks the end of the procedure.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRLINEM_Airdashboard/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"how"}}
{"id":"AIRPROFM_AirlineProfile_line1_sum","input_data":"     C                   If        AirStatus = 'A'\n     C                   Eval      AStatus = 'Active'\n     C                   Else\n     C                   Eval      AStatus = 'Deactivation'\n     C                   EndIf\n     C                   Eval      ViewAddress = *On\n     C                   Write     Header\n     C                   Exfmt     VwAirline","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     PAirlineProfile   B                   Export\n     DAirlineProfile   PI\n     Dp_AirlineId                     5A\n\n     ** Fetching data of airline from file AIRMASTER\n     C     p_AirlineId   Chain     Airmaster\n     C                   Eval      UserFld = AirName\n\n     ** Displaying screen VwAirline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Eval      AfSize = %Char(AirFleet)\n\n     ** Screen field ASTATUS Validation\n     C                   If        AirStatus = 'A'\n     C                   Eval      AStatus = 'Active'\n     C                   Else\n     C                   Eval      AStatus = 'Deactivation'\n     C                   EndIf\n     C                   Eval      ViewAddress = *On\n     C                   Write     Header\n     C                   Exfmt     VwAirline\n\n     ** Handle Screen Operation for VwAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Eval      ViewAddress = *Off\n     C                   Unlock    AirMaster\n     C                   Leave\n\n     ** Displaying screen Updairline if F6 is presses\n     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n\n     ** Fetching data of airline on screen Updairline\n     C     p_AirlineId   Chain     Airmaster\n     C     p_AirlineId   Chain     LoginPf\n\n     ** Display screen Updairline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Exfmt     Updairline\n\n     ** Handle Screen Operations For UpdAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Unlock    AirMaster\n     C                   Unlock    LoginPf\n     C                   Leave\n\n     ** Changing status of airline to Inactive\n     C                   When      Deactivation = *On\n     C                   Eval      Deactivation = *Off\n     C                   Dow       Cancel = *Off\n\n     ** Display screen CancelWdw\n     C                   Exfmt     CancelWdw\n\n     ** Handle Screen Operation for CancelWdw\n     C                   Select\n\n     ** Exit out of screen CancelWdw\n     C                   When      Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Leave\n\n     ** Deactivate airline\n     C                   Other\n     C                   Eval      AirRemark = %Trim(DReason)\n     C                   Eval      UserRemark = %Trim(DReason)\n     C                   Eval      AirStatus = 'R'\n     C                   Eval      UserStatus = 'R'\n     C                   Eval      AStatus = 'Deactivation'\n     C                   Eval      AirError = 'Profile Deactivation Request' +\n     C                             ' Submitted, Press F6 to Update'\n     C                   Leave\n     C                   Endsl\n     C                   Enddo\n\n     ** Update Airline\n     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n     C                   Update    Airmasterr\n     C                   Update    LoginPfr\n     C                   Eval      AirError = 'Profile Updated'\n     C                   Eval      AStatus = 'Deactivation'\n     C                   Leave\n     C                   Endsl\n     C                   Enddo\n     C                   Endsl\n     C                   Enddo\n     PAirlineProfile   E","output":"### Summary\nThis fixed-form ILE RPG line evaluates the status of an airline and sets appropriate display text. It then sets a flag for viewing the address, writes a header record to the display, and shows the `VwAirline` screen to the user for interaction.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_AirlineProfile_line1/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"line","depth":"sum"}}
{"id":"AIRPROFM_AirlineProfile_line1_how","input_data":"     C                   If        AirStatus = 'A'\n     C                   Eval      AStatus = 'Active'\n     C                   Else\n     C                   Eval      AStatus = 'Deactivation'\n     C                   EndIf\n     C                   Eval      ViewAddress = *On\n     C                   Write     Header\n     C                   Exfmt     VwAirline","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     PAirlineProfile   B                   Export\n     DAirlineProfile   PI\n     Dp_AirlineId                     5A\n\n     ** Fetching data of airline from file AIRMASTER\n     C     p_AirlineId   Chain     Airmaster\n     C                   Eval      UserFld = AirName\n\n     ** Displaying screen VwAirline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Eval      AfSize = %Char(AirFleet)\n\n     ** Screen field ASTATUS Validation\n     C                   If        AirStatus = 'A'\n     C                   Eval      AStatus = 'Active'\n     C                   Else\n     C                   Eval      AStatus = 'Deactivation'\n     C                   EndIf\n     C                   Eval      ViewAddress = *On\n     C                   Write     Header\n     C                   Exfmt     VwAirline\n\n     ** Handle Screen Operation for VwAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Eval      ViewAddress = *Off\n     C                   Unlock    AirMaster\n     C                   Leave\n\n     ** Displaying screen Updairline if F6 is presses\n     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n\n     ** Fetching data of airline on screen Updairline\n     C     p_AirlineId   Chain     Airmaster\n     C     p_AirlineId   Chain     LoginPf\n\n     ** Display screen Updairline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Exfmt     Updairline\n\n     ** Handle Screen Operations For UpdAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Unlock    AirMaster\n     C                   Unlock    LoginPf\n     C                   Leave\n\n     ** Changing status of airline to Inactive\n     C                   When      Deactivation = *On\n     C                   Eval      Deactivation = *Off\n     C                   Dow       Cancel = *Off\n\n     ** Display screen CancelWdw\n     C                   Exfmt     CancelWdw\n\n     ** Handle Screen Operation for CancelWdw\n     C                   Select\n\n     ** Exit out of screen CancelWdw\n     C                   When      Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Leave\n\n     ** Deactivate airline\n     C                   Other\n     C                   Eval      AirRemark = %Trim(DReason)\n     C                   Eval      UserRemark = %Trim(DReason)\n     C                   Eval      AirStatus = 'R'\n     C                   Eval      UserStatus = 'R'\n     C                   Eval      AStatus = 'Deactivation'\n     C                   Eval      AirError = 'Profile Deactivation Request' +\n     C                             ' Submitted, Press F6 to Update'\n     C                   Leave\n     C                   Endsl\n     C                   Enddo\n\n     ** Update Airline\n     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n     C                   Update    Airmasterr\n     C                   Update    LoginPfr\n     C                   Eval      AirError = 'Profile Updated'\n     C                   Eval      AStatus = 'Deactivation'\n     C                   Leave\n     C                   Endsl\n     C                   Enddo\n     C                   Endsl\n     C                   Enddo\n     PAirlineProfile   E","output":"### Purpose: \n- The fixed-form ILE RPG line evaluates the status of an airline and sets appropriate display text. It then sets a flag for viewing the address, writes a header record to the display, and shows the `VwAirline` screen to the user for interaction.\n\n### Code explanation:\n- This ILE RPG code is part of a display program for managing or viewing airline-related data. \n - Overall Code Logic Summary:\n   - Check the airline status. Set a readable status label (`Active` or `Deactivation`) for display.\n   - Turn on the flag to show address info.\n   - Display a header.\n   - Show the airline screen and wait for user action.\n\n```rpgle\n        C     If        AirStatus = 'A'\n        C     Eval      AStatus = 'Active'\n        C     Else\n        C     Eval      AStatus = 'Deactivation'\n        C     EndIf\n```\n- Checks if the airline status (`AirStatus`) is `'A'`.\n - If true, it sets `AStatus` to `'Active'`.\n - Otherwise, it sets `AStatus` to `'Deactivation'`.\n- This prepares a *human-readable status* (like for display on screen) based on a single-letter code.\n\n ```rpgle \n        C     Eval      ViewAddress = *On\n ```\n - Turns on a flag variable named `ViewAddress`, a logical (`*ON` = true). This flag might control whether address information should be displayed.\n- This is usually used to *control what appears on the screen*, e.g., whether to show address information.\n\n```rpgle\n        C     Write     Header\n```\n- Writes the `Header` record format to the display. This usually prints header information before showing detailed data.\n\n```rpgle\n        C     Exfmt     VwAirline\n```\n- Displays the `VwAirline` format and waits for user input (`EXFMT` = display and wait for input).","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_AirlineProfile_line1/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"line","depth":"how"}}
{"id":"AIRPROFM_AirlineProfile_line2_sum","input_data":"     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n\n     ** Fetching data of airline on screen Updairline\n     C     p_AirlineId   Chain     Airmaster\n     C     p_AirlineId   Chain     LoginPf\n\n     ** Display screen Updairline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Exfmt     Updairline\n\n     ** Handle Screen Operations For UpdAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Unlock    AirMaster\n     C                   Unlock    LoginPf\n     C                   Leave","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRMASTER UF A E           K Disk\n     FLOGINPF   UF A E           K Disk\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     Dp_AirlineId      S              5A\n     PAirlineProfile   B                   Export\n     DAirlineProfile   PI\n     Dp_AirlineId                     5A\n\n     ** Fetching data of airline from file AIRMASTER\n     C     p_AirlineId   Chain     Airmaster\n     C                   Eval      UserFld = AirName\n\n     ** Displaying screen VwAirline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Eval      AfSize = %Char(AirFleet)\n\n     ** Screen field ASTATUS Validation\n     C                   If        AirStatus = 'A'\n     C                   Eval      AStatus = 'Active'\n     C                   Else\n     C                   Eval      AStatus = 'Deactivation'\n     C                   EndIf\n     C                   Eval      ViewAddress = *On\n     C                   Write     Header\n     C                   Exfmt     VwAirline\n\n     ** Handle Screen Operation for VwAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Eval      ViewAddress = *Off\n     C                   Unlock    AirMaster\n     C                   Leave\n\n     ** Displaying screen Updairline if F6 is presses\n     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n\n     ** Fetching data of airline on screen Updairline\n     C     p_AirlineId   Chain     Airmaster\n     C     p_AirlineId   Chain     LoginPf\n\n     ** Display screen Updairline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Exfmt     Updairline\n\n     ** Handle Screen Operations For UpdAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Unlock    AirMaster\n     C                   Unlock    LoginPf\n     C                   Leave\n\n     ** Changing status of airline to Inactive\n     C                   When      Deactivation = *On\n     C                   Eval      Deactivation = *Off\n     C                   Dow       Cancel = *Off\n\n     ** Display screen CancelWdw\n     C                   Exfmt     CancelWdw\n\n     ** Handle Screen Operation for CancelWdw\n     C                   Select\n\n     ** Exit out of screen CancelWdw\n     C                   When      Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Leave\n\n     ** Deactivate airline\n     C                   Other\n     C                   Eval      AirRemark = %Trim(DReason)\n     C                   Eval      UserRemark = %Trim(DReason)\n     C                   Eval      AirStatus = 'R'\n     C                   Eval      UserStatus = 'R'\n     C                   Eval      AStatus = 'Deactivation'\n     C                   Eval      AirError = 'Profile Deactivation Request' +\n     C                             ' Submitted, Press F6 to Update'\n     C                   Leave\n     C                   Endsl\n     C                   Enddo\n\n     ** Update Airline\n     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n     C                   Update    Airmasterr\n     C                   Update    LoginPfr\n     C                   Eval      AirError = 'Profile Updated'\n     C                   Eval      AStatus = 'Deactivation'\n     C                   Leave\n     C                   Endsl\n     C                   Enddo\n     C                   Endsl\n     C                   Enddo\n     PAirlineProfile   E","output":"### Summary\nThis fixed-form ILE RPG line is used to load airline and login data using a provided airline ID.\nPresent the data on a display screen (`Updairline`) for user action. Allow users to either update or exit/cancel. Handle record locking and unlocking accordingly.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_AirlineProfile_line2/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"line","depth":"sum"}}
{"id":"AIRPROFM_AirlineProfile_line2_how","input_data":"     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n\n     ** Fetching data of airline on screen Updairline\n     C     p_AirlineId   Chain     Airmaster\n     C     p_AirlineId   Chain     LoginPf\n\n     ** Display screen Updairline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Exfmt     Updairline\n\n     ** Handle Screen Operations For UpdAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Unlock    AirMaster\n     C                   Unlock    LoginPf\n     C                   Leave","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRMASTER UF A E           K Disk\n     FLOGINPF   UF A E           K Disk\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     Dp_AirlineId      S              5A\n     PAirlineProfile   B                   Export\n     DAirlineProfile   PI\n     Dp_AirlineId                     5A\n\n     ** Fetching data of airline from file AIRMASTER\n     C     p_AirlineId   Chain     Airmaster\n     C                   Eval      UserFld = AirName\n\n     ** Displaying screen VwAirline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Eval      AfSize = %Char(AirFleet)\n\n     ** Screen field ASTATUS Validation\n     C                   If        AirStatus = 'A'\n     C                   Eval      AStatus = 'Active'\n     C                   Else\n     C                   Eval      AStatus = 'Deactivation'\n     C                   EndIf\n     C                   Eval      ViewAddress = *On\n     C                   Write     Header\n     C                   Exfmt     VwAirline\n\n     ** Handle Screen Operation for VwAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Eval      ViewAddress = *Off\n     C                   Unlock    AirMaster\n     C                   Leave\n\n     ** Displaying screen Updairline if F6 is presses\n     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n\n     ** Fetching data of airline on screen Updairline\n     C     p_AirlineId   Chain     Airmaster\n     C     p_AirlineId   Chain     LoginPf\n\n     ** Display screen Updairline\n     C                   Dow       Exit = *Off Or Cancel = *Off\n     C                   Exfmt     Updairline\n\n     ** Handle Screen Operations For UpdAirline\n     C                   Select\n     C                   When      Exit = *On Or Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Unlock    AirMaster\n     C                   Unlock    LoginPf\n     C                   Leave\n\n     ** Changing status of airline to Inactive\n     C                   When      Deactivation = *On\n     C                   Eval      Deactivation = *Off\n     C                   Dow       Cancel = *Off\n\n     ** Display screen CancelWdw\n     C                   Exfmt     CancelWdw\n\n     ** Handle Screen Operation for CancelWdw\n     C                   Select\n\n     ** Exit out of screen CancelWdw\n     C                   When      Cancel = *On\n     C                   Eval      Cancel = *Off\n     C                   Leave\n\n     ** Deactivate airline\n     C                   Other\n     C                   Eval      AirRemark = %Trim(DReason)\n     C                   Eval      UserRemark = %Trim(DReason)\n     C                   Eval      AirStatus = 'R'\n     C                   Eval      UserStatus = 'R'\n     C                   Eval      AStatus = 'Deactivation'\n     C                   Eval      AirError = 'Profile Deactivation Request' +\n     C                             ' Submitted, Press F6 to Update'\n     C                   Leave\n     C                   Endsl\n     C                   Enddo\n\n     ** Update Airline\n     C                   When      Confirm = *On\n     C                   Eval      Confirm = *Off\n     C                   Update    Airmasterr\n     C                   Update    LoginPfr\n     C                   Eval      AirError = 'Profile Updated'\n     C                   Eval      AStatus = 'Deactivation'\n     C                   Leave\n     C                   Endsl\n     C                   Enddo\n     C                   Endsl\n     C                   Enddo\n     PAirlineProfile   E","output":"### Purpose:\n - The fixed-form ILE RPG line is used to Load airline and login data using a provided airline ID.\nPresent the data on a display screen (Updairline) for user action. Allow users to either update or exit/cancel. Handle record locking and unlocking accordingly.\n\n### Code Explanation:\n1. Confirmation handling\n```rpgle\n        C                   When      Confirm = *On\n        C                   Eval      Confirm = *Off\n```\n- This ensures that the confirmation flag is reset to `*Off` if it was `*On`. This likely prevents accidental repeat actions if the user re-enters the screen.\n\n2. Reading data from files\n```rpgle \n        C     p_AirlineId   Chain     Airmaster\n        C     p_AirlineId   Chain     LoginPf\n```\n- `CHAIN` retrieves a specific record using `p_AirlineId` as the key.\n- If the record exists in `Airmaster` or `LoginPf`, it loads the data into memory.\n\n3. User Interface loop\n - This starts a loop where the screen `Updairline` is displayed using `EXFMT` (extended format).\n - `EXFMT` sends data to the screen and waits for the user to input something and press a function key (e.g., Enter, F3).\n - Loop continues until either `Exit` or `Cancel` becomes `*On`.\n```rpgle\n        C                   Dow       Exit = *Off Or Cancel = *Off\n        C                   Exfmt     Updairline\n```\n4. Handling User actions\n - `SELECT` chooses logic based on user input (e.g., exit, cancel, confirm).\n - If user sets `Exit` or `Cancel` to `*On`, the program:\n   - Resets `Cancel` to `*Off` to prevent reprocessing.\n   - Uses `UNLOCK` to release any record locks acquired earlier.\n   - `LEAVE` exits the loop, ending the screen interaction.\n```rpgle\n        C                   Select\n        C                   When      Exit = *On Or Cancel = *On\n        C                   Eval      Cancel = *Off\n        C                   Unlock    AirMaster\n        C                   Unlock    LoginPf\n        C                   Leave\n```\n5. Lock Management\n  - Files like `Airmaster` and `LoginPf` may have records locked when accessed (especially if updated).\n- `UNLOCK` releases those locks to avoid record contention with other users or jobs.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_AirlineProfile_line2/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4fx","scope":"line","depth":"how"}}
{"id":"AIRPROFM_PassInd_sum","input_data":"     PPassInd          B\n     C                   Eval      WrongOldPass  = *Off\n     C                   Eval      WrongNewPass  = *Off\n     C                   Eval      WrongCnfPass  = *Off\n     C                   Eval      v_FlagError = *Off\n     C                   Clear                   AirError\n     PPassInd          E","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     Dv_FlagError      S               N   Inz(*On)","output":"This fixed-form ILE RPG procedure `PassInd` resets password validation indicators, clearing error flags and messages to ensure a fresh validation state for password operations.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_PassInd/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"sum"}}
{"id":"AIRPROFM_PassInd_api","input_data":"     PPassInd          B\n     C                   Eval      WrongOldPass  = *Off\n     C                   Eval      WrongNewPass  = *Off\n     C                   Eval      WrongCnfPass  = *Off\n     C                   Eval      v_FlagError = *Off\n     C                   Clear                   AirError\n     PPassInd          E","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     Dv_FlagError      S               N   Inz(*On)","output":"## Purpose\n- The fixed-form ILE RPG procedure `PassInd` resets password validation indicators, clearing error flags and messages to ensure a fresh validation state for password operations.\n\n## Parameters  \nThe `PassInd` procedure does not take any input or output parameters.\n\n## Side Effects \n- Indicator Reset:  \n  - Clears password-related validation indicators (`WrongOldPass`, `WrongNewPass`, `WrongCnfPass`).  \n  - Resets the error flag (`v_FlagError`).  \n  - Clears any previously displayed error messages (`AirError`).  \n\n- Screen Behavior:\n  - Ensures that previous password errors do not persist when the user attempts another password change.    \n\n## Global Variables  \n| Variable Name      | Type       | Description |\n|--------------------|------------|-------------|\n| `WrongOldPass`    | `IND`       | Indicator for incorrect old password. |\n| `WrongNewPass`    | `IND`       | Indicator for incorrect new password. |\n| `WrongCnfPass`    | `IND`       | Indicator for mismatched confirm password. |\n| `v_FlagError`     | `IND`       | General error flag for password validation. |\n| `AirError`        | `CHAR(78)`  | Holds error messages for password validation. |\n\n## Usage Example \nCall `PassInd` before displaying the password change screen to ensure a fresh validation state:\n\n```rpgle\n    Callp PassInd();\n```\n\nThis ensures that any old validation errors do not interfere with the new password entry process.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_PassInd/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"api"}}
{"id":"AIRPROFM_PassInd_how","input_data":"     PPassInd          B\n     C                   Eval      WrongOldPass  = *Off\n     C                   Eval      WrongNewPass  = *Off\n     C                   Eval      WrongCnfPass  = *Off\n     C                   Eval      v_FlagError = *Off\n     C                   Clear                   AirError\n     PPassInd          E","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     Dv_FlagError      S               N   Inz(*On)","output":"- The fixed-form ILE RPG procedure  `PassInd` is responsible for resetting password validation indicators before displaying the password change screen. This ensures that previous errors do not persist when a user attempts to enter a new password.\n\n### Procedure Declaration & Initialization\n\n```rpgle\n\tP PassInd B\n```\n\n- Declares `PassInd` as a procedure.\n- It does not take any parameters.\n- Used to reset password validation flags before displaying the password change screen.\n\n### Resetting Password Validation Indicators\n\n```rpgle\n\tC Eval WrongOldPass  = *Off\n\tC Eval WrongNewPass  = *Off\n\tC Eval WrongCnfPass  = *Off\n\tC Eval v_FlagError   = *Off\n\tC Clear              AirError\n```\n\n- `WrongOldPass`, `WrongNewPass`, and `WrongCnfPass` are set to `*Off` (false) to clear any previous password validation errors.\n- `v_FlagError` is reset to `*Off`, meaning no validation errors exist at the start.\n- `AirError`, which holds error messages displayed on the screen, is cleared.\n\n### Ending the Procedure\n\n```rpgle\n\tP PassInd E\n```\n\n- Ends the `PassInd` procedure.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_PassInd/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"how"}}
{"id":"AIRPROFM_ValidatePass_sum","input_data":"     PValidatePass     B\n\n     ** Variable Assignment for validation\n     Dv_AlphaLower     S             26A   Inz('abcdefghijklmnopqrstuvwxyz')\n     Dv_AlphaUpper     S             26A   Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n     Dv_AlphaSpecial   S             22A   Inz('!@#$%^&*()_-+=<>,.?/;:')\n     Dv_AlphaDigits    S             10A   Inz('1234567890')\n\n     ** Indicators for new password validation\n     Dv_HasLower       S               N   Inz(*Off)\n     Dv_HasUpper       S               N   Inz(*Off)\n     Dv_HasSpecial     S               N   Inz(*Off)\n     Dv_HasDigits      S               N   Inz(*Off)\n     DI                S              2S 0\n\n     ** Old Password cannot be blank\n     C                   If        DOldPass = *Blanks\n     C                   Eval      AirError = 'Current Password Cannot Be Blank'\n     C                   Eval      WrongOldPass  = *On\n     C                   Eval      v_FlagError = *On\n     C                   Return\n\n     ** Old Password should be matched\n     C                   ElseIf    DOldPass <> UserPass\n     C                   Eval      AirError = 'Current Password Is Wrong'\n     C                   Eval      WrongOldPass  = *On\n     C                   Eval      v_FlagError = *On\n     C                   Return\n     C                   EndIf\n\n     ** New Password cannot be blank\n     C                   If        DNewPass = *Blanks\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'New Password Cannot Be Blank'\n     C                   Return\n     C                   EndIf\n\n     ** Checking new password should have uppercase,lowercase,digit, and special char\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaLower) > 0\n     C                   Eval      v_HasLower = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaUpper) > 0\n     C                   Eval      v_HasUpper = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaSpecial)>0\n     C                   Eval      v_HasSpecial = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaDigits)>0\n     C                   Eval      v_HasDigits = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n\n     ** New Password should have atlest one lowercase char\n     C                   If        v_HasLower = *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Lowercase Character'\n     C                   Return\n\n     ** New Password should have atlest one uppercase char\n     C                   ElseIf    v_HasUpper = *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Uppercase Character'\n     C                   Return\n\n     ** New Password should have atlest one special char\n     C                   ElseIf    v_HasSpecial =  *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Special Character'\n     C                   Return\n\n     ** New Password should have atlest one numeric digit\n     C                   ElseIf    v_HasDigits =  *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Numeric Digit'\n     C                   Return\n     C                   EndIf\n\n     ** Confirm password should be equal to new password\n     C                   If        DCnfPass <> DNewPass\n     C                   Eval      WrongCNfPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Confirm Password Not Matched' +\n     C                             ' With New Password'\n     C                   Return\n     C                   EndIf\n     PValidatePass     E","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     Dv_AlphaLower     S             26A\n     Dv_AlphaUpper     S             26A\n     Dv_FlagError      S               N   Inz(*On)","output":"This RPG IV fixed form procedure `ValidatePass` will validate the password when the user enters new password or tries to change password on `AIRLINED` display file.\nIt returns to the caller after turning on related field-level error indicators and displaying the error message on the screen.  \nThis procedure is part of the `Flight Booking System` Module.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_ValidatePass/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"sum"}}
{"id":"AIRPROFM_ValidatePass_api","input_data":"     PValidatePass     B\n\n     ** Variable Assignment for validation\n     Dv_AlphaLower     S             26A   Inz('abcdefghijklmnopqrstuvwxyz')\n     Dv_AlphaUpper     S             26A   Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n     Dv_AlphaSpecial   S             22A   Inz('!@#$%^&*()_-+=<>,.?/;:')\n     Dv_AlphaDigits    S             10A   Inz('1234567890')\n\n     ** Indicators for new password validation\n     Dv_HasLower       S               N   Inz(*Off)\n     Dv_HasUpper       S               N   Inz(*Off)\n     Dv_HasSpecial     S               N   Inz(*Off)\n     Dv_HasDigits      S               N   Inz(*Off)\n     DI                S              2S 0\n\n     ** Old Password cannot be blank\n     C                   If        DOldPass = *Blanks\n     C                   Eval      AirError = 'Current Password Cannot Be Blank'\n     C                   Eval      WrongOldPass  = *On\n     C                   Eval      v_FlagError = *On\n     C                   Return\n\n     ** Old Password should be matched\n     C                   ElseIf    DOldPass <> UserPass\n     C                   Eval      AirError = 'Current Password Is Wrong'\n     C                   Eval      WrongOldPass  = *On\n     C                   Eval      v_FlagError = *On\n     C                   Return\n     C                   EndIf\n\n     ** New Password cannot be blank\n     C                   If        DNewPass = *Blanks\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'New Password Cannot Be Blank'\n     C                   Return\n     C                   EndIf\n\n     ** Checking new password should have uppercase,lowercase,digit, and special char\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaLower) > 0\n     C                   Eval      v_HasLower = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaUpper) > 0\n     C                   Eval      v_HasUpper = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaSpecial)>0\n     C                   Eval      v_HasSpecial = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaDigits)>0\n     C                   Eval      v_HasDigits = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n\n     ** New Password should have atlest one lowercase char\n     C                   If        v_HasLower = *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Lowercase Character'\n     C                   Return\n\n     ** New Password should have atlest one uppercase char\n     C                   ElseIf    v_HasUpper = *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Uppercase Character'\n     C                   Return\n\n     ** New Password should have atlest one special char\n     C                   ElseIf    v_HasSpecial =  *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Special Character'\n     C                   Return\n\n     ** New Password should have atlest one numeric digit\n     C                   ElseIf    v_HasDigits =  *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Numeric Digit'\n     C                   Return\n     C                   EndIf\n\n     ** Confirm password should be equal to new password\n     C                   If        DCnfPass <> DNewPass\n     C                   Eval      WrongCNfPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Confirm Password Not Matched' +\n     C                             ' With New Password'\n     C                   Return\n     C                   EndIf\n     PValidatePass     E","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     Dv_AlphaLower     S             26A\n     Dv_AlphaUpper     S             26A\n     Dv_FlagError      S               N   Inz(*On)","output":"## Purpose \n\nThis RPG IV fixed form procedure `ValidatePass` will Validate password when the user enters new password or tries to change password.\n\n\n## Parameters\nNo parameters are there in this procedure\n\n### Input\n`DOldPass ` - Old Password\n`DNewPass` - New Password\n`DCnfPass` - Confirm New Password\n\n#### Screen\n\nScreen fields validated under record format `CHGPASS` of display file `AIRLINED` are listed below.\n\n- `DOldPass ` - Old Password\n- `DNewPass` - New Password\n- `DCnfPass` - Confirm New Password\n\n### Output\n\n\n#### Indicators\n\nThe following indicators are turned on which cause the field in error to be highlighted when the `CHGPASS` is rewritten to the display.\n\n| Indicator Name | Indicator Number  | DSPF Field to Highlight | Description |\n| -------------- |-------------------|-------------------------|-------------|\n| `WrongOldPass` | `84` | DOldPass | Old Password|\n| `WrongNewPass` | `85` | DNewPass | New Password |\n| `WrongCnfPass` | `86` | DCnfPass | Confirm New Password |\n \n\n#### Error messages\n\nIn screen field `AIRERROR` will be assigned one of the error messages below if the input fields of record format `CHGPASS` fail validation.\n\n- `Current Password Cannot Be Blank`\n- `Current Password Is Wrong`\n- `New Password Cannot Be Blank`\n- `Password Must Contain Atleast`\n- `Password Must Contain Atleast One Uppercase Character`\n- `Password Must Contain Atleast One Special Character`\n- `Password Must Contain Atleast One Numeric Digit`\n- `Confirm Password Not Matched With New Password`\n\n  ## Dependencies\n\n  No dependencies","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_ValidatePass/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"api"}}
{"id":"AIRPROFM_ValidatePass_how","input_data":"     PValidatePass     B\n\n     ** Variable Assignment for validation\n     Dv_AlphaLower     S             26A   Inz('abcdefghijklmnopqrstuvwxyz')\n     Dv_AlphaUpper     S             26A   Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n     Dv_AlphaSpecial   S             22A   Inz('!@#$%^&*()_-+=<>,.?/;:')\n     Dv_AlphaDigits    S             10A   Inz('1234567890')\n\n     ** Indicators for new password validation\n     Dv_HasLower       S               N   Inz(*Off)\n     Dv_HasUpper       S               N   Inz(*Off)\n     Dv_HasSpecial     S               N   Inz(*Off)\n     Dv_HasDigits      S               N   Inz(*Off)\n     DI                S              2S 0\n\n     ** Old Password cannot be blank\n     C                   If        DOldPass = *Blanks\n     C                   Eval      AirError = 'Current Password Cannot Be Blank'\n     C                   Eval      WrongOldPass  = *On\n     C                   Eval      v_FlagError = *On\n     C                   Return\n\n     ** Old Password should be matched\n     C                   ElseIf    DOldPass <> UserPass\n     C                   Eval      AirError = 'Current Password Is Wrong'\n     C                   Eval      WrongOldPass  = *On\n     C                   Eval      v_FlagError = *On\n     C                   Return\n     C                   EndIf\n\n     ** New Password cannot be blank\n     C                   If        DNewPass = *Blanks\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'New Password Cannot Be Blank'\n     C                   Return\n     C                   EndIf\n\n     ** Checking new password should have uppercase,lowercase,digit, and special char\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaLower) > 0\n     C                   Eval      v_HasLower = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaUpper) > 0\n     C                   Eval      v_HasUpper = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaSpecial)>0\n     C                   Eval      v_HasSpecial = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n     **\n     C                   For       I = 1 To %Len(%Trim(DNewPass))\n     C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaDigits)>0\n     C                   Eval      v_HasDigits = *On\n     C                   Leave\n     C                   EndIf\n     C                   EndFor\n\n     ** New Password should have atlest one lowercase char\n     C                   If        v_HasLower = *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Lowercase Character'\n     C                   Return\n\n     ** New Password should have atlest one uppercase char\n     C                   ElseIf    v_HasUpper = *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Uppercase Character'\n     C                   Return\n\n     ** New Password should have atlest one special char\n     C                   ElseIf    v_HasSpecial =  *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Special Character'\n     C                   Return\n\n     ** New Password should have atlest one numeric digit\n     C                   ElseIf    v_HasDigits =  *Off\n     C                   Eval      WrongNewPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Password Must Contain Atleast' +\n     C                             ' One Numeric Digit'\n     C                   Return\n     C                   EndIf\n\n     ** Confirm password should be equal to new password\n     C                   If        DCnfPass <> DNewPass\n     C                   Eval      WrongCNfPass = *On\n     C                   Eval      v_FlagError = *On\n     C                   Eval      AirError = 'Confirm Password Not Matched' +\n     C                             ' With New Password'\n     C                   Return\n     C                   EndIf\n     PValidatePass     E","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n\n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15   O  1  8COLOR(WHT)\n     A          R SFLFOOTER\nairprofm.rpgle:\n     FAIRLINED  CF   E             WORKSTN INDDS(#IndicatorDs)\n     D#IndicatorDs     DS\n\n     ** Subfile Indicators\n     DExit                            1N   Overlay(#IndicatorDs:03)\n     DPrompt                          1N   Overlay(#IndicatorDs:04)\n     DRefresh                         1N   Overlay(#IndicatorDs:05)\n     DConfirm                         1N   Overlay(#IndicatorDs:06)\n     DDeactivation                    1N   Overlay(#IndicatorDs:11)\n     DCancel                          1N   Overlay(#IndicatorDs:12)\n\n     ** Field Indicators\n     DViewAddress                     1N   Overlay(#IndicatorDs:80)\n     DViewOldPassword                 1N   Overlay(#IndicatorDs:81)\n     DViewNewPassword                 1N   Overlay(#IndicatorDs:82)\n     DViewCnfPassword                 1N   Overlay(#IndicatorDs:83)\n     DWrongOldPass                    1N   Overlay(#IndicatorDs:84)\n     DWrongNewPass                    1N   Overlay(#IndicatorDs:85)\n     DWrongCnfPass                    1N   Overlay(#IndicatorDs:86)\n     Dv_AlphaLower     S             26A\n     Dv_AlphaUpper     S             26A\n     Dv_FlagError      S               N   Inz(*On)","output":"This RPG IV fixed form procedure `ValidatePass` will Validate password when the user enters new password or tries to change password on `AIRLINED` display file.\n\n## Explanation:\n\n## 1. Procedure Declaration \n      * `PValidatePass B` - `PValidatePass` is the name of the procedure and `B` signifies beginning of the procedure \n## 2. Variable declaration and Intialization \n* `v_AlphaLower` - The variable is initialized with all lowercase letters from a till z\n* `v_AlphaUpper` - The variable is initialized with all uppercase letters from A till Z\n* `v_AlphaSpecial` - The variable is initialized special characters \n* `v_AlphaDigits` - The variable is initialized with numeric digits\n* `I` - The variable to hold the iteration value in a loop\n\n      ```rpg\n\t     Dv_AlphaLower     S             26A   Inz('abcdefghijklmnopqrstuvwxyz')\n         Dv_AlphaUpper     S             26A   Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n         Dv_AlphaSpecial   S             22A   Inz('!@#$%^&*()_-+=<>,.?/;:')\n         Dv_AlphaDigits    S             10A   Inz('1234567890')\n\t\t DI                S              2S 0\n\t  ```\n## 3. Indicator Initialization \n* The variables `v_HasLower`, `v_HasUpper`, `v_HasSpecial`,`v_HasDigits` are declared as Booleans and set to `*off`   \n* The variable `I` is declared\n      ```rpg         \n         Dv_HasLower       S               N   Inz(*Off)\n         Dv_HasUpper       S               N   Inz(*Off)\n         Dv_HasSpecial     S               N   Inz(*Off)\n         Dv_HasDigits      S               N   Inz(*Off)\n        \n\t  ```\n## 4. Password Validation  \n## 4.1 Old password Validation \n* The old password `DOldPass` field of record format `CHGPASS` from display file `AIRLINED` is being checked, if it is blank then `AirError` field from record format `CHGPASS` from display file `AIRLINED` is populated with error message(refer the code below) and returned.\n* `WrongOldPass` the error indicator is set `*On` and the stand alone indicator `v_FlagError` is also set `*On`\n\n      ```rpg\n\t     C                   If        DOldPass = *Blanks\n         C                   Eval      AirError = 'Current Password Cannot Be Blank'\n         C                   Eval      WrongOldPass  = *On\n         C                   Eval      v_FlagError = *On\n         C                   Return\n\t  ```\n* The old password `DOldPass` field from record format `CHGPASS` from display file `AIRLINED` is being checked, if it doesnt matches with \n  the field value `UserPass` of file `LOGINPF` then `AirError` field from record format `CHGPASS` is populated with error message(refer the code below) and returned.\n* `WrongOldPass` the error indicator is set `*On` and the stand alone indicator `v_FlagError` is also set `*On`\n      ```rpg\n\t     C                   ElseIf    DOldPass <> UserPass\n         C                   Eval      AirError = 'Current Password Is Wrong'\n         C                   Eval      WrongOldPass  = *On\n         C                   Eval      v_FlagError = *On\n         C                   Return\n         C                   EndIf\n\t  ```\n## 4.2 New password Validation \n* The new password `DNewPass` field of record format `CHGPASS` from display file `AIRLINED` is being checked, if it is blank then `AirError` field from record format `CHGPASS` from display file `AIRLINED` is populated with error message(refer the code below) and returned.\n* `WrongNewPass` the error indicator is set `*On` and the stand alone indicator `v_FlagError` is also set `*On`\n\n      ```rpg\n\t     C                   If        DNewPass = *Blanks\n         C                   Eval      WrongNewPass = *On\n         C                   Eval      v_FlagError = *On\n         C                   Eval      AirError = 'New Password Cannot Be Blank'\n         C                   Return\n         C                   EndIf\n\t  ```\n## 4.3 Password Standards validation\n* The program loops through checking each character for the following cases:\n  * Lower Case - The `%Scan` built in function is used for scanning lower case letters in the input field `DNewPass`, if yes then the indicator\n    `v_HasLower` is set `*On`\n\t ```rpg\n\t    C                   For       I = 1 To %Len(%Trim(DNewPass))\n        C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaLower) > 0\n        C                   Eval      v_HasLower = *On\n        C                   Leave\n        C                   EndIf\n        C                   EndFor\n\t ```\n  * Upper Case - The `%Scan` built in function is used for scanning Upper case letters in the input field `DNewPass`, if yes then the indicator\n    `v_HasUpper` is set `*On`\n\t ```rpg\n\t    C                   For       I = 1 To %Len(%Trim(DNewPass))\n        C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaUpper) > 0\n        C                   Eval      v_HasUpper = *On\n        C                   Leave\n        C                   EndIf\n        C                   EndFor\n\t ```\n\t\n  * Special Character - The `%Scan` built in function is used for scanning special characters in the input field `DNewPass`, if yes then \n    the indicator `v_HasSpecial` is set `*On`\n\t ```rpg\n\t    C                   For       I = 1 To %Len(%Trim(DNewPass))\n        C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaSpecial)>0\n        C                   Eval      v_HasSpecial = *On\n        C                   Leave\n        C                   EndIf\n        C                   EndFor\n\t ```\n  * Numeric Digits - The `%Scan` built in function is used for scanning numeric digits in the input field `DNewPass`, if yes then \n    the indicator `v_HasDigits` is set `*On`\n\t ```rpg\n\t    C                   For       I = 1 To %Len(%Trim(DNewPass))\n        C                   If        %Scan(%Subst(DnewPass:I:1):v_AlphaDigits)>0\n        C                   Eval      v_HasDigits = *On\n        C                   Leave\n        C                   EndIf\n        C                   EndFor\n\t ```\n  * If indicator `v_HasLower` is set `*Off` that means the `DnewPass` doesnt contain atleast one lower case character, hence the \n    error message is populated and the specific error indicator `WrongNewPass` and `v_FlagError` are set to `*On` and then returns to the caller.\n     ```rpg\n\t     C                   If        v_HasLower = *Off\n         C                   Eval      WrongNewPass = *On\n         C                   Eval      v_FlagError = *On\n         C                   Eval      AirError = 'Password Must Contain Atleast' +\n         C                             ' One Lowercase Character'\n         C                   Return\n\t ```\n  * If indicator `v_HasUpper` is set `*Off` that means the `DnewPass` doesnt contain atleast one upper case character, hence the \n    error message is populated and the specific error indicator `WrongNewPass` and `v_FlagError` are set to `*On` and then returns to the caller.\n     ```rpg\n\t    C                   ElseIf    v_HasUpper = *Off\n        C                   Eval      WrongNewPass = *On\n        C                   Eval      v_FlagError = *On\n        C                   Eval      AirError = 'Password Must Contain Atleast' +\n        C                             ' One Uppercase Character'\n        C                   Return\n\t ```\n  * If indicator `v_HasSpecial` is set off that means the `DnewPass` doesnt contain atleast one special case character, hence the \n    error message is populated and the specific error indicator `WrongNewPass` and `v_FlagError` are set to `*On` and then returns to the caller.\n     ```rpg\n\t     C                   ElseIf    v_HasSpecial =  *Off\n         C                   Eval      WrongNewPass = *On\n         C                   Eval      v_FlagError = *On\n         C                   Eval      AirError = 'Password Must Contain Atleast' +\n         C                             ' One Special Character'\n         C                   Return\n\t ```\n  * If indicator `v_HasDigits` is set off that means the `DnewPass` doesnt contain atleast one numeric digit, hence the \n    error message is populated and the specific error indicator `WrongNewPass` and `v_FlagError` are set to `*On` and then returns to the caller.\n     ```rpg\n\t    C                   ElseIf    v_HasDigits =  *Off\n        C                   Eval      WrongNewPass = *On\n        C                   Eval      v_FlagError = *On\n        C                   Eval      AirError = 'Password Must Contain Atleast' +\n        C                             ' One Numeric Digit'\n        C                   Return\n        C                   EndIf\n\t ```\n## 4.4 Confirm password Validation\n  * If new password `DNewPass` and the confirm password `DCnfPass` values doesnt match, the error message is populated and the specific \n    error indicator `WrongCNfPass ` and `v_FlagError` are set to `*On` and then returns to the caller.\n     ```rpg\n\t    C                   If        DCnfPass <> DNewPass\n        C                   Eval      WrongCNfPass = *On\n        C                   Eval      v_FlagError = *On\n        C                   Eval      AirError = 'Confirm Password Not Matched' +\n        C                             ' With New Password'\n        C                   Return\n        C                   EndIf\n\t ```\n## 5. End of procedure\n* `PValidatePass E` - `PValidatePass` is the name of the procedure and `E` signifies end of the procedure","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/AIRPROFM_ValidatePass/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"proc","depth":"how"}}
{"id":"CSTDSHBRDM_sum","input_data":"     ** Control option\n      /Title CstDshBrdM - Driver module for the customer\n     HOption(*Nodebugio : *SrcStmt)\n     HNomain\n\n     ** File declartion\n     FCUSTDSBD  CF   E             WorkStn Indds(IndctrDs)\n     FAccPf     IF   E           K Disk\n\n     ** Data structure declaration\n     DIndctrDs         Ds\n     DIndExit                          N   Overlay(IndctrDs : 03)\n     DIndCancel                        N   Overlay(IndctrDs : 12)\n\n     ** Copy book declaration\n     C/Copy KartikCS/Qrpglesrc,Copy_Book\n\n     ** Variable declaration\n     DPAccNo           S             11S 0\n\n     ** Main code\n     PCustDshBrd       B                   Export\n     DCustDshBrd       PI\n     DP_UserId                       10A\n\n     C                   Eval      IndExit = *Off\n     C                   DoW       IndExit = *Off or IndCancel = *Off\n\n     C                   Eval      CustHeadng = '           Customer Main Menu'\n     C                                          +'          '\n     C                   Eval      CustFtrL1  = 'F3=Exit   F12=Cancel'\n\n     C                   Write     CustHeader\n     C                   Write     CustFooter\n     C                   Exfmt     CustMains\n\n     C                   Select\n\n     C                   When      IndExit = *On or IndCancel = *On\n     C                   Eval      IndCancel = *Off\n     C                   Clear                   CustError\n     C                   Clear                   CustChoice\n     C                   Leave\n\n     C                   When      CustChoice = 1\n     C                   CallP     DisplayCust(P_UserID)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 2\n     C                   CallP     DisplayAcc(P_UserID)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 3\n     C                   CallP     GetAccountNo(P_UserID)\n     C                   CallP     TransferAmt(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 4\n     C                   CallP     GetAccountNo(P_UserId)\n     C                   CallP     DisplayTr(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 5\n     C                   CallP     NewLoan()\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 6\n     C                   CallP     GetAccountNo(P_UserId)\n     C                   CallP     DisplayCLoan(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 7\n     C                   CallP     ChangPswd()\n     C                   Clear                   CustChoice\n\n     C                   EndSl\n\n     C                   EndDo\n     PCustDshBrd       E\n\n     ** ------------------------------------------------------------------------------------\n     ** Procedure Name: GetAccountNo\n     ** Description   : Procedure to get customer account number\n     ** ------------------------------------------------------------------------------------\n\n     PGetAccountNo     B\n     DGetAccountNo     PI\n     DP_UserId                       10A\n     C     *Loval        Setll     AccPf\n     C                   Read      AccPf\n     C                   DoW       Not %Eof(AccPf)\n     C                   If        CustId  = P_UserId\n     C                   Eval      PAccNo = AccNo\n     C                   Leave\n     C                   EndIf\n     C                   Read      AccPf\n     C                   EndDo\n     PGetAccountNo     E","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A          R CUSTHEADER\n\n     A                                  1  3'User:'\n     A                                  1  9USER\n     A                                  1 32'Capital Trust Bank'\n     A                                      DSPATR(HI)\n     A                                  1 64'Date:'\n     A                                  2 64'Time:'\n     A                                  1 70DATE\n     A                                      EDTCDE(Y)\n     A                                  2 70TIME\n     A            CUSTHEADNG    40A  O  2 21COLOR(YLW)\n     A                                  3  3'__________________________________-\n     A                                      ___________________________________-\n     A                                      _______'\n     A                                      COLOR(BLU)\n     A          R CUSTFOOTER\naccpf.pfsql:\nCreate or Replace table Account_Table(\n    Acc_No      For Column AccNO        Numeric(11) Not Null,\n    Cust_Id     For Column CustId       Char(10) Not Null,\n    Acc_Type    For Column AccType      Char(10) With Default ' ',\n    Acc_Blnce   For Column AccBlnce     Numeric(15) With Default 0,\n    Br_Code     For Column BrCode       Char(11) With Default ' ',\n    Acc_OpnDt   For Column AccOpnDt     Date,\n    I_Rate      For Column IRate        Decimal(5,2) With Default 0.0,\n    Acc_Stauts  For Column AccStatus    Char(10) With Default ' ',\nPrimary Key(AccNO),\nForeign key(CustID) REFERENCES CustPF(CId)\n)\nRcdFmt AccPFR;\n\nRename Table Account_Table to System Name AccPF;\n\nLabel On Table Account_Table Is 'Account pf for Account Details';\n\nLabel On Column Account_Table(\n    Acc_No      Is 'Account Number',\n    Cust_Id     Is 'Customer Id',\n    Acc_Type    Is 'Account type',\n    Acc_Blnce   Is 'Account Balance',\n    Br_Code     Is 'Branch Code',\n    Acc_OpnDt   Is 'Account Opening Date',\n    I_Rate      Is 'Interest Rate',\n    Acc_Stauts  Is 'Account Status'\n);\n\nLabel On Column Account_Table(\n    Acc_No      Text Is 'Account Number',\n    Cust_Id     Text Is 'Customer Id',\n    Acc_Type    Text Is 'Account type',\n    Acc_Blnce   Text Is 'Account Balance',\n    Br_Code     Text Is 'Branch Code',\n    Acc_OpnDt   Text Is 'Account Opening Date',\n    I_Rate      Text Is 'Interest Rate',\n    Acc_Stauts  Text Is 'Account Status'\n);\n\ncstdshbrdm.rpgle:\n     FCUSTDSBD  CF   E             WorkStn Indds(IndctrDs)\n     FAccPf     IF   E           K Disk\n     DIndctrDs         Ds\n     DIndExit                          N   Overlay(IndctrDs : 03)\n     DIndCancel                        N   Overlay(IndctrDs : 12)\n     DPAccNo           S             11S 0","output":"This fixed-form RPGLE module `CstDshBrdM` has one exported procedure `CustDshBrd` it acts as a navigation hub for customer-related operations, serves as a driver for customer operations via a menu-driven workstation display. It presents a user interface to the user (presumably a customer or staff member), handles menu selections, and delegates tasks to various procedures.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CSTDSHBRDM/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"module","depth":"sum"}}
{"id":"CSTDSHBRDM_api","input_data":"     ** Control option\n      /Title CstDshBrdM - Driver module for the customer\n     HOption(*Nodebugio : *SrcStmt)\n     HNomain\n\n     ** File declartion\n     FCUSTDSBD  CF   E             WorkStn Indds(IndctrDs)\n     FAccPf     IF   E           K Disk\n\n     ** Data structure declaration\n     DIndctrDs         Ds\n     DIndExit                          N   Overlay(IndctrDs : 03)\n     DIndCancel                        N   Overlay(IndctrDs : 12)\n\n     ** Copy book declaration\n     C/Copy KartikCS/Qrpglesrc,Copy_Book\n\n     ** Variable declaration\n     DPAccNo           S             11S 0\n\n     ** Main code\n     PCustDshBrd       B                   Export\n     DCustDshBrd       PI\n     DP_UserId                       10A\n\n     C                   Eval      IndExit = *Off\n     C                   DoW       IndExit = *Off or IndCancel = *Off\n\n     C                   Eval      CustHeadng = '           Customer Main Menu'\n     C                                          +'          '\n     C                   Eval      CustFtrL1  = 'F3=Exit   F12=Cancel'\n\n     C                   Write     CustHeader\n     C                   Write     CustFooter\n     C                   Exfmt     CustMains\n\n     C                   Select\n\n     C                   When      IndExit = *On or IndCancel = *On\n     C                   Eval      IndCancel = *Off\n     C                   Clear                   CustError\n     C                   Clear                   CustChoice\n     C                   Leave\n\n     C                   When      CustChoice = 1\n     C                   CallP     DisplayCust(P_UserID)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 2\n     C                   CallP     DisplayAcc(P_UserID)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 3\n     C                   CallP     GetAccountNo(P_UserID)\n     C                   CallP     TransferAmt(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 4\n     C                   CallP     GetAccountNo(P_UserId)\n     C                   CallP     DisplayTr(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 5\n     C                   CallP     NewLoan()\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 6\n     C                   CallP     GetAccountNo(P_UserId)\n     C                   CallP     DisplayCLoan(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 7\n     C                   CallP     ChangPswd()\n     C                   Clear                   CustChoice\n\n     C                   EndSl\n\n     C                   EndDo\n     PCustDshBrd       E\n\n     ** ------------------------------------------------------------------------------------\n     ** Procedure Name: GetAccountNo\n     ** Description   : Procedure to get customer account number\n     ** ------------------------------------------------------------------------------------\n\n     PGetAccountNo     B\n     DGetAccountNo     PI\n     DP_UserId                       10A\n     C     *Loval        Setll     AccPf\n     C                   Read      AccPf\n     C                   DoW       Not %Eof(AccPf)\n     C                   If        CustId  = P_UserId\n     C                   Eval      PAccNo = AccNo\n     C                   Leave\n     C                   EndIf\n     C                   Read      AccPf\n     C                   EndDo\n     PGetAccountNo     E","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A          R CUSTHEADER\n\n     A                                  1  3'User:'\n     A                                  1  9USER\n     A                                  1 32'Capital Trust Bank'\n     A                                      DSPATR(HI)\n     A                                  1 64'Date:'\n     A                                  2 64'Time:'\n     A                                  1 70DATE\n     A                                      EDTCDE(Y)\n     A                                  2 70TIME\n     A            CUSTHEADNG    40A  O  2 21COLOR(YLW)\n     A                                  3  3'__________________________________-\n     A                                      ___________________________________-\n     A                                      _______'\n     A                                      COLOR(BLU)\n     A          R CUSTFOOTER\naccpf.pfsql:\nCreate or Replace table Account_Table(\n    Acc_No      For Column AccNO        Numeric(11) Not Null,\n    Cust_Id     For Column CustId       Char(10) Not Null,\n    Acc_Type    For Column AccType      Char(10) With Default ' ',\n    Acc_Blnce   For Column AccBlnce     Numeric(15) With Default 0,\n    Br_Code     For Column BrCode       Char(11) With Default ' ',\n    Acc_OpnDt   For Column AccOpnDt     Date,\n    I_Rate      For Column IRate        Decimal(5,2) With Default 0.0,\n    Acc_Stauts  For Column AccStatus    Char(10) With Default ' ',\nPrimary Key(AccNO),\nForeign key(CustID) REFERENCES CustPF(CId)\n)\nRcdFmt AccPFR;\n\nRename Table Account_Table to System Name AccPF;\n\nLabel On Table Account_Table Is 'Account pf for Account Details';\n\nLabel On Column Account_Table(\n    Acc_No      Is 'Account Number',\n    Cust_Id     Is 'Customer Id',\n    Acc_Type    Is 'Account type',\n    Acc_Blnce   Is 'Account Balance',\n    Br_Code     Is 'Branch Code',\n    Acc_OpnDt   Is 'Account Opening Date',\n    I_Rate      Is 'Interest Rate',\n    Acc_Stauts  Is 'Account Status'\n);\n\nLabel On Column Account_Table(\n    Acc_No      Text Is 'Account Number',\n    Cust_Id     Text Is 'Customer Id',\n    Acc_Type    Text Is 'Account type',\n    Acc_Blnce   Text Is 'Account Balance',\n    Br_Code     Text Is 'Branch Code',\n    Acc_OpnDt   Text Is 'Account Opening Date',\n    I_Rate      Text Is 'Interest Rate',\n    Acc_Stauts  Text Is 'Account Status'\n);\n\ncstdshbrdm.rpgle:\n     FCUSTDSBD  CF   E             WorkStn Indds(IndctrDs)\n     FAccPf     IF   E           K Disk\n     DIndctrDs         Ds\n     DIndExit                          N   Overlay(IndctrDs : 03)\n     DIndCancel                        N   Overlay(IndctrDs : 12)\n     DPAccNo           S             11S 0","output":"#### Purpose\nThis free-form RPGLE module `Cstdshbrdm` having one exported procedure `CustDshBrd` acts as the driver for the Customer Dashboard interface. \n\n#### Exported procedure `CustDshBrd` \nTo provide an interactive menu-based interface where a customer (or staff user) can:\n- View customer and account information\n- Perform transactions (like money transfers)\n- Check transaction history\n- Apply for loans or view existing ones\n- Change passwords\n- Exit or cancel the session\n\n##### Parameters\nIt accepts one input parameter customer user id -  `P_UserId` of length 10 character.  \n\n##### Dependencies\nBelow mentioned objects needs to be in the library list. \n- `AccPf`    - Database file for Account details \n- `CUSTDSBD` - Display file for Customer main menu\n\n##### Usage example\nCall procedure `CustDshBrd` to drive customer dashboard menu\n```rpgle\n        CustDshBrd(w1_UserId);\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CSTDSHBRDM/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"module","depth":"api"}}
{"id":"CSTDSHBRDM_how","input_data":"     ** Control option\n      /Title CstDshBrdM - Driver module for the customer\n     HOption(*Nodebugio : *SrcStmt)\n     HNomain\n\n     ** File declartion\n     FCUSTDSBD  CF   E             WorkStn Indds(IndctrDs)\n     FAccPf     IF   E           K Disk\n\n     ** Data structure declaration\n     DIndctrDs         Ds\n     DIndExit                          N   Overlay(IndctrDs : 03)\n     DIndCancel                        N   Overlay(IndctrDs : 12)\n\n     ** Copy book declaration\n     C/Copy KartikCS/Qrpglesrc,Copy_Book\n\n     ** Variable declaration\n     DPAccNo           S             11S 0\n\n     ** Main code\n     PCustDshBrd       B                   Export\n     DCustDshBrd       PI\n     DP_UserId                       10A\n\n     C                   Eval      IndExit = *Off\n     C                   DoW       IndExit = *Off or IndCancel = *Off\n\n     C                   Eval      CustHeadng = '           Customer Main Menu'\n     C                                          +'          '\n     C                   Eval      CustFtrL1  = 'F3=Exit   F12=Cancel'\n\n     C                   Write     CustHeader\n     C                   Write     CustFooter\n     C                   Exfmt     CustMains\n\n     C                   Select\n\n     C                   When      IndExit = *On or IndCancel = *On\n     C                   Eval      IndCancel = *Off\n     C                   Clear                   CustError\n     C                   Clear                   CustChoice\n     C                   Leave\n\n     C                   When      CustChoice = 1\n     C                   CallP     DisplayCust(P_UserID)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 2\n     C                   CallP     DisplayAcc(P_UserID)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 3\n     C                   CallP     GetAccountNo(P_UserID)\n     C                   CallP     TransferAmt(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 4\n     C                   CallP     GetAccountNo(P_UserId)\n     C                   CallP     DisplayTr(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 5\n     C                   CallP     NewLoan()\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 6\n     C                   CallP     GetAccountNo(P_UserId)\n     C                   CallP     DisplayCLoan(PAccNo)\n     C                   Clear                   CustChoice\n\n     C                   When      CustChoice = 7\n     C                   CallP     ChangPswd()\n     C                   Clear                   CustChoice\n\n     C                   EndSl\n\n     C                   EndDo\n     PCustDshBrd       E\n\n     ** ------------------------------------------------------------------------------------\n     ** Procedure Name: GetAccountNo\n     ** Description   : Procedure to get customer account number\n     ** ------------------------------------------------------------------------------------\n\n     PGetAccountNo     B\n     DGetAccountNo     PI\n     DP_UserId                       10A\n     C     *Loval        Setll     AccPf\n     C                   Read      AccPf\n     C                   DoW       Not %Eof(AccPf)\n     C                   If        CustId  = P_UserId\n     C                   Eval      PAccNo = AccNo\n     C                   Leave\n     C                   EndIf\n     C                   Read      AccPf\n     C                   EndDo\n     PGetAccountNo     E","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A          R CUSTHEADER\n\n     A                                  1  3'User:'\n     A                                  1  9USER\n     A                                  1 32'Capital Trust Bank'\n     A                                      DSPATR(HI)\n     A                                  1 64'Date:'\n     A                                  2 64'Time:'\n     A                                  1 70DATE\n     A                                      EDTCDE(Y)\n     A                                  2 70TIME\n     A            CUSTHEADNG    40A  O  2 21COLOR(YLW)\n     A                                  3  3'__________________________________-\n     A                                      ___________________________________-\n     A                                      _______'\n     A                                      COLOR(BLU)\n     A          R CUSTFOOTER\naccpf.pfsql:\nCreate or Replace table Account_Table(\n    Acc_No      For Column AccNO        Numeric(11) Not Null,\n    Cust_Id     For Column CustId       Char(10) Not Null,\n    Acc_Type    For Column AccType      Char(10) With Default ' ',\n    Acc_Blnce   For Column AccBlnce     Numeric(15) With Default 0,\n    Br_Code     For Column BrCode       Char(11) With Default ' ',\n    Acc_OpnDt   For Column AccOpnDt     Date,\n    I_Rate      For Column IRate        Decimal(5,2) With Default 0.0,\n    Acc_Stauts  For Column AccStatus    Char(10) With Default ' ',\nPrimary Key(AccNO),\nForeign key(CustID) REFERENCES CustPF(CId)\n)\nRcdFmt AccPFR;\n\nRename Table Account_Table to System Name AccPF;\n\nLabel On Table Account_Table Is 'Account pf for Account Details';\n\nLabel On Column Account_Table(\n    Acc_No      Is 'Account Number',\n    Cust_Id     Is 'Customer Id',\n    Acc_Type    Is 'Account type',\n    Acc_Blnce   Is 'Account Balance',\n    Br_Code     Is 'Branch Code',\n    Acc_OpnDt   Is 'Account Opening Date',\n    I_Rate      Is 'Interest Rate',\n    Acc_Stauts  Is 'Account Status'\n);\n\nLabel On Column Account_Table(\n    Acc_No      Text Is 'Account Number',\n    Cust_Id     Text Is 'Customer Id',\n    Acc_Type    Text Is 'Account type',\n    Acc_Blnce   Text Is 'Account Balance',\n    Br_Code     Text Is 'Branch Code',\n    Acc_OpnDt   Text Is 'Account Opening Date',\n    I_Rate      Text Is 'Interest Rate',\n    Acc_Stauts  Text Is 'Account Status'\n);\n\ncstdshbrdm.rpgle:\n     FCUSTDSBD  CF   E             WorkStn Indds(IndctrDs)\n     FAccPf     IF   E           K Disk\n     DIndctrDs         Ds\n     DIndExit                          N   Overlay(IndctrDs : 03)\n     DIndCancel                        N   Overlay(IndctrDs : 12)\n     DPAccNo           S             11S 0","output":"Module Name - CstDshBrdM\n\nDescription - Driver Module for the bank customer   \n\nThis fixed-format RPGLE module `CstDshBrdM` having one exported procedure `CustDshBrd` acts as the driver for the Customer Dashboard interface in an IBM i (AS/400) application.\nTo provide an interactive menu-based interface where a customer (or staff user) can:\n- View customer and account information\n- Perform transactions (like money transfers)\n- Check transaction history\n- Apply for loans or view existing ones\n- Change passwords\n- Exit or cancel the session\n\n- Key Functions:\n - Manages screen I/O through a workstation file (CUSTDSBD)\n - Reads user input and navigates to the corresponding function\n - Delegates business logic to specific procedures (like DisplayCust, TransferAmt, etc.)\n - Uses indicators to handle exit/cancel events\n\n 1. Export Procedure: `CustDshBrd`\n  - This is the main entry point for the customer dashboard logic within the module.\n```rpgle \n        PCustDshBrd       B                   Export\n        DCustDshBrd       PI\n        DP_UserId                       10A\n```\n- Purpose:\n - To control the menu navigation loop and direct the user to the correct functionality based on their choice.\n - Controls the interactive dashboard loop for the customer menu. \n\n- Detailed Function:\n - Displays the customer main menu screen repeatedly until:\n- User presses F3 (Exit) or F12 (Cancel)\n\nHandles Menu Options:\n- Executes logic based on CustChoice (17)\n- Calls procedures for customer/account info, transfers, loans, etc.\n- Clears choice after each action\n\nEnsures Clean Exit:\n - Handles exit indicators (IndExit, IndCancel)\n- Clears footer and error messages on exit\n\nParameter:\n- `P_UserId` (input): The user ID (probably of the logged-in customer) used to fetch account or customer-specific information.\n\n2. Subprocedure: `GetAccountNo`\n - This is a local (non-exported) procedure, used only within the same module.\n purpose \n  - To retrieve the account number (`PAccNo`) for the user ID provided. It reads through the `AccPf` file and matches the `CustId` field.\nCalled By\n - This subprocedure is invoked inside `CustDshBrd`, specifically when the user selects options 3, 4, or 6  all of which require the account number before performing an action.\n\n- Summary of Validations Performed in `CstDshBrdM` module\n  - Here's a concise summary of all the validations implemented:\n\n1. Exit and Cancel Key Detection\nValidation: Checks if the user pressed F3 (Exit) or F12 (Cancel).\nHow: Using indicator variables `IndExit` and `IndCancel`.\nPurpose: To exit the menu loop gracefully.\n\n2. Menu Choice Handling\nValidation: Verifies if the menu option selected (`CustChoice`) is one of the valid options (1 to 7).\nHow: `SELECT / WHEN` structure based on `CustChoice`.\nPurpose: To trigger appropriate procedures based on user selection.\nNote: No handling for invalid inputs outside 17.\n\n3. User ID Matching in Account file\nValidation: Checks if the user ID (`P_UserId`) exists in the `AccPf` file.\nHow: Loop reads the file and compares `CustId` with `P_UserId`.\nPurpose: To find and assign the matching account number (`PAccNo`).\n\n- *Missing / Not Implemented Validations* \n  - No error shown if an *invalid menu option* is entered.\n  - No validation if *account number isn't found* (i.e., `PAccNo` remains empty).\n  - No input validation on the format/length of `P_UserId`.\n\nKey Functions:\n- Manages screen I/O through a workstation file (`CUSTDSBD`)\n- Reads user input and navigates to the corresponding function\n- Delegates business logic to specific procedures (like `DisplayCust`, `TransferAmt`, etc.)\n- Uses indicators to handle exit/cancel events\n\nSummary view of all Export Procedures and Subprocedures in `CstDshBrdM` RPGLE module:\n- procedure type - Main procedure \n  - procedure name - `CustDshBrd` \n  - exported - Yes\n  - purpose - Controls the customer dashboard menu\n\n- procedure type - Helper Subprocedure\t\n  - procedure name - `GetAccountNo` \n  - exported - No\n  - purpose - Looks up account number based on user ID.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CSTDSHBRDM/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4fx","scope":"module","depth":"how"}}
{"id":"CUSTMRFLTM_sum","input_data":"**Free\n\n // Control Specification\n  /Title CUSTMRFLTM - Program to handle flight search and booking operation\n  Ctl-Opt Option(*Nodebugio:*Srcstmt) Nomain;\n\n // Physical File Declaration\n  Dcl-F Flightpf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F PsngrPf    Disk Usage(*Input:*Output) Keyed;\n  Dcl-F BookingPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F TicketPf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F FltSeatPf  Disk Usage(*Input:*Output) Keyed;\n\n // Display File Declaration\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n\n // Data Structure Declaration\n\n // Indicator Data Structure\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n\n // #Output3 - Stores output from sub-procedure WindowPrompt\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n\n // FlightDs - Stores data of a flight\n  Dcl-Ds FlightDs Qualified;\n    v_FltId   Char(5);\n    v_AirName Char(20);\n    v_TotDur  Time;\n    v_BPrice  Packed(6);\n    v_PPrice  Packed(6);\n    v_EPrice  Packed(6);\n    v_Rating  Packed(2:1);\n  End-Ds;\n\n // Copy Book Stores Procedure Prototypes\n  /Copy CpyBookPr\n\n // Standalone Variable\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_FlagFltId    Char(5);\n  Dcl-S v_PassengerId  Char(5);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n\n // Standalone Indicators\n  Dcl-S v_FlagError    Ind Inz(*On);\n  Dcl-S v_IndTktBooked Ind Inz(*Off);\n\n //------------------------------------------------------------------------------------------\n // Procedure Name.: SearchFlight\n // Description....: Procedure to handle flight searching\n //------------------------------------------------------------------------------------------\n  Dcl-Proc SearchFlight Export;\n    Dcl-Pi SearchFlight;\n      p_UserId Char(5);\n      p_UserName Char(20);\n    End-Pi;\n    Reset SEARCHFLT;\n    UserFld = p_UserName;\n    v_CustomerId = p_UserId;\n\n   // Display screen SEARCHFLT\n    Dow Exit = *Off Or Cancel = *Off;\n      Write Header;\n      Exfmt SEARCHFLT;\n\n     // Handle Screen Operations for SEARCHFLT\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Refresh screen\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset SEARCHFLT;\n\n     // Prompt for Origin City\n      When FLD = 'DORIGIN' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Origin';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DORIGIN = #Output3.v_KeyDesc;\n\n     // Prompt for destination city\n      When FLD = 'DDEST' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Destination';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DDEST = #Output3.v_KeyDesc;\n\n     // Validate the data on screen SEARCHFLT\n      Other;\n\n       // Reset Field and standalone Indicators\n        ResetIndicator();\n\n       // Validate data\n        ValidateSearch();\n\n       // Showing Search Results\n        If v_FlagError = *Off;\n\n         // Seat Category\n          If DSEATCHC = 1;\n            v_SeatCatg = 'B';\n          ElseIf DSEATCHC = 2;\n            v_SeatCatg = 'P';\n          ElseIf DSEATCHC = 3;\n            v_SeatCatg = 'E';\n          EndIf;\n\n         // Subfile for Search Results\n          FltSubfile(DORIGIN:DDEST:DDATE:DNUMPSNGR:v_SeatCatg);\n          Reset SEARCHFLT;\n          v_FlagError = *On;\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name.:  ValidateSearch\n // Description........:  Sub Procedure to Validate Flight Search Data\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ValidateSearch;\n\n   // Origin City should not be blank\n    If DORIGIN = *Blanks;\n      v_WrongOrigin = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Origin: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Destination city should not be blank\n    If DDEST = *Blanks;\n      v_WrongDest = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Destination: Mandatory Field';\n      Return;\n\n   // Destination should not match with origin\n    ElseIf DDEST = DORIGIN;\n      v_WrongDest = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Destination: Origin And Destination Cannot Be Same';\n      Return;\n    EndIf;\n\n   // Departure Date should not be blank\n    If %Char(DDATE) = '0001-01-01';\n      v_WrongDate = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Date: Mandatory Field';\n      Return;\n\n   // Departure date should not be past date\n    ElseIf DDATE < %date();\n      v_WrongDate = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Date: Departure Date Should Be Upcoming Date';\n      Return;\n    EndIf;\n\n   // Number of passenger should not be zero\n    If DNUMPSNGR = *Zeros;\n      v_WrongNumPsngr = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Number Of Passengers: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Seat Category should not be blank\n    If DSEATCHC = *Zeros;\n      v_WrongSeatChc = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Seat Category: Mandatory Field';\n      Return;\n    EndIf;\n\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ResetIndicator\n // Description.......:  Sub Procedure to Reset All Field and Standalone indicators\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ResetIndicator;\n    v_FlagError = *Off;\n    Reset v_WrongDate;\n    Reset v_WrongDest;\n    Reset v_WrongOrigin;\n    Reset v_WrongNumPsngr;\n    Reset v_WrongSeatChc;\n    Reset v_WrongPsgAge;\n    Reset v_WrongPsgGender;\n    Reset v_WrongPsgName;\n    Clear DCUSTMRERR;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  FltSubfile\n // Description.......:  Sub Procedure to Handle Subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc FltSubfile;\n    Dcl-Pi FltSubfile;\n      p_Origin        Char(20);\n      p_Destination   Char(20);\n      p_DepartureDate Date;\n      p_NumOfPsngr    Packed(2);\n      p_SeatCatg      Char(1);\n    End-Pi;\n\n   // Clear, load, and display subfile FLTLISTSFL\n    Dow Exit = *Off Or Cancel = *Off;\n\n     // Clear subfile FLTLISTSFL\n      ClearFlightSfl();\n\n     // Load Subfile FLTLISTSFL\n      LoadFlightSfl(p_Origin:p_Destination:p_SeatCatg);\n\n     // Display subfile FLTLISTSFL\n      DisplayFlightSfl();\n\n     // Handle screen operations\n      Select;\n\n       // Exit out of screen\n        When Exit = *On Or Cancel = *On;\n          Cancel = *Off;\n          Reset SFLERROR;\n          v_OverlayInd = *Off;\n          Leave;\n\n       // Refresh screen\n        When Refresh = *On;\n          Refresh = *Off;\n          Reset FLTLISTCTL;\n\n       // Read Subfile FLTLISTSFL\n        Other;\n          ReadFlightSfl(p_NumOfPsngr:p_DepartureDate:p_SeatCatg);\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ClearFlightSfl\n // Description.......:  Sub Procedure to clear subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ClearFlightSfl;\n    FltSflClr = *On;\n    v_Rrn = 0;\n    Write FLTLISTCTL;\n    FltSflClr = *Off;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  LoadFlightSfl\n // Description.......: Procedure to Load subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc LoadFlightSfl;\n    Dcl-Pi LoadFlightSfl;\n      p_Origin Char(20);\n      p_Destination Char(20);\n      p_SeatCatg Char(1);\n    End-Pi;\n\n    DSRCORIGIN = p_Origin;\n    DSRCDEST   = p_Destination;\n\n   // position to\n    If DFLTPOSTO <> *Blanks;\n\n     // Fetching position to data from file FLIGHTPF and AIRMASTER\n      Exec Sql\n        Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n        FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n        AIR.AIRRATING,FLT.FLTID\n        Into :FLIGHTDS,:v_FlagFltId\n        FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n        ON FLT.AIRID = AIR.AIRID\n        Where (FLT.FLTID = :DFLTPOSTO Or AIR.AIRNAME = :DFLTPOSTO) And\n        (FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n        And FLT.FLTSTATUS = 'A');\n\n     // Successfull execution of sql query\n      If Sqlcod = 0;\n\n       // Assigning data from FLIGHTDS to Subfile Fields\n        DFLTID    = FLIGHTDS.v_FltId;\n        DAIRLINE  = FLIGHTDS.v_AirName;\n        DTOTALDUR = FLIGHTDS.v_TotDur;\n\n       // Validating data for subfile fields\n        If p_SeatCatg = 'B';\n          DPRICE = %Char(FLIGHTDS.v_BPrice);\n        ElseIf p_SeatCatg = 'P';\n          DPRICE = %Char(FLIGHTDS.v_PPrice);\n        ElseIf p_SeatCatg = 'E';\n          DPRICE = %Char(FLIGHTDS.v_EPrice);\n        EndIf;\n        DRATING = FLIGHTDS.v_Rating;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write FLTLISTSFL;\n      EndIf;\n\n     // Declare cursor to Fetch data from file FLIGHTPF and AIRMASTER\n      Exec Sql\n        Declare DataCursorPos Cursor For\n        Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n        FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n        AIR.AIRRATING\n        FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n        ON FLT.AIRID = AIR.AIRID\n        Where (FLT.FLTID != :v_FlagFltId) And\n        (FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n        And FLT.FLTSTATUS = 'A');\n\n     // Open cursor\n      Exec Sql\n        Open DataCursorPos;\n\n     // Fetching data from Cursor to FLIGHTDS\n      Exec Sql\n        Fetch From DataCursorPos Into :FlightDs;\n\n      Dow SQLCOD = 0;\n\n       // Assigning data to subfile fields from FLIGHTDS\n        DFLTID    = FLIGHTDS.v_FltId;\n        DAIRLINE  = FLIGHTDS.v_AirName;\n        DTOTALDUR = FLIGHTDS.v_TotDur;\n\n       // Validation for subfile field\n        If p_SeatCatg = 'B';\n          DPRICE = %Char(FLIGHTDS.v_BPrice);\n        ElseIf p_SeatCatg = 'P';\n          DPRICE = %Char(FLIGHTDS.v_PPrice);\n        ElseIf p_SeatCatg = 'E';\n          DPRICE = %Char(FLIGHTDS.v_EPrice);\n        EndIf;\n        DRATING = FLIGHTDS.v_Rating;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write FLTLISTSFL;\n\n       // Fetching next record from cursor\n        Exec Sql\n          Fetch Next From DataCursorPos Into :FlightDs;\n\n      Enddo;\n\n     // Close cursor\n      Exec Sql\n        Close DataCursorPos;\n\n      Return;\n    EndIf;\n\n   // Declare cursor to fetch data from file FLIGHTPF and AIRMASTER\n    Exec Sql\n      Declare DataCursor Cursor For\n      Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n      FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n      AIR.AIRRATING\n      FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n      ON FLT.AIRID = AIR.AIRID\n      Where FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n      And FLT.FLTSTATUS = 'A';\n\n   // Open cursor\n    Exec Sql\n      Open DataCursor;\n\n   // Fetch data from cursor to FLIGHTDS\n    Exec Sql\n      Fetch From DataCursor Into :FLIGHTDS;\n\n   // Fetching records till the end of files\n    Dow SQLCOD = 0;\n\n     // Assigning data to subfile fields from FLIGHTDS\n      DFLTID    = FLIGHTDS.v_FltId;\n      DAIRLINE  = FLIGHTDS.v_AirName;\n      DTOTALDUR = FLIGHTDS.v_TotDur;\n\n     // Validation  for Subfile fields\n      If p_SeatCatg = 'B';\n        DPRICE = %Char(FLIGHTDS.v_BPrice);\n      ElseIf p_SeatCatg = 'P';\n        DPRICE = %Char(FLIGHTDS.v_PPrice);\n      ElseIf p_SeatCatg = 'E';\n        DPRICE = %Char(FLIGHTDS.v_EPrice);\n      EndIf;\n      DRATING = FLIGHTDS.v_Rating;\n      v_Rrn = v_Rrn + 1;\n\n     // Rrn cannot be greater than 9999\n      If v_Rrn > 9999;\n        Leave;\n      EndIf;\n      Write FLTLISTSFL;\n\n     // Fetch next record from cursor\n      Exec Sql\n        Fetch Next From DataCursor Into :FLIGHTDS;\n    Enddo;\n\n   // CLose cursor\n    Exec Sql\n      Close DataCursor;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  DisplayFlightSfl\n // Description.......:  Sub Procedure to Display subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc DisplayFlightSfl;\n    v_OverlayInd = *On;\n    FltSflDsp = *On;\n    FltSflCtl = *On;\n    FltSflEnd = *On;\n\n   // Cannot display if Rrn < 1\n    If v_Rrn < 1;\n      FltSflDsp = *Off;\n      SFLERROR = 'Sorry, No Flights Are There As Per Your Requirement';\n    EndIf;\n    SflFtr = 'F3=Exit  F5=Refresh  F12=Cancel';\n    Write Header;\n    Write SFLFOOTER;\n    Exfmt FLTLISTCTL;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // SUb Procedure Name:  ReadFlightSfl\n // Description.......:  Sub Procedure to Read subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ReadFlightSfl;\n    Dcl-Pi ReadFlightSfl;\n      p_NumberOfPsngr Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg Char(1);\n    End-Pi;\n\n   // Cannot read empty subfile\n    Monitor;\n      Chain DFLTCHC FLTLISTSFL;\n      Readc FLTLISTSFL;\n\n     // Reading till end of subfile\n      Dow Not %EOF();\n\n       // Operations to perform\n        Select;\n\n       // View Flight\n        When DFLTCHC = 5;\n          Clear DFLTCHC;\n          ViewFlightProc(p_NumberOfPsngr:p_DepartureDate:p_SeatCatg);\n\n       // Clear DFLTCHC\n        Other;\n          Clear DFLTCHC;\n        Endsl;\n        Readc FLTLISTSFL;\n      Enddo;\n\n     // Error Handle\n      On-Error;\n        SFLERROR = 'Sorry, No Flights Are There As Per Your Requirement';\n    EndMon;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ViewFlightProc\n // Description.......:  Sub Procedure to View Flight details\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ViewFlightProc;\n    Dcl-Pi ViewFlightProc;\n      p_NumberOfPsngr Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg Char(1);\n    End-Pi;\n\n   // Fetching data from file FLIGHTPF to screen VIEWFLIGHT\n    Chain DFLTID FLightPf;\n\n   // Fetching data from file AIRMASTER to screen VIEWFLIGHT\n    Chain AirId Airmaster;\n    DFLTHEADER = %Trim(AirName) + ' ' + FLTID;\n\n   // Display screen VIEWFLIGHT\n    Dow Exit = *Off Or Cancel = *Off;\n      DFLTAIRLIN = AIRNAME;\n\n     // Setting ticket price according to seat category\n      If p_SeatCatg = 'B';\n        DTKTPRICE = FLTBPRICE;\n      ElseIf p_SeatCatg = 'P';\n        DTKTPRICE = FLTPPRICE;\n      ElseIf p_SeatCatg = 'E';\n        DTKTPRICE = FLTEPRICE;\n      EndIf;\n\n      Write Header;\n      Exfmt VIEWFLIGHT;\n\n     // Handle Screen Operation for ViewFlight\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Book Tickets\n      When Confirm = *On;\n        Confirm = *Off;\n        BookTicketProc(DFLTID:p_NumberOfPsngr:p_DepartureDate:p_SeatCatg:\n        DTKTPRICE);\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: BookTicket\n // Description.......: Procedure to handle ticket booking\n //------------------------------------------------------------------------------------------\n  Dcl-Proc BookTicketProc;\n    Dcl-Pi BookTicketProc;\n      p_FltId         Char(5);\n      p_NumPsngr      Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg      Char(1);\n      p_SeatPrice     Packed(6);\n    End-Pi;\n\n   // Local Variable\n    Dcl-S v_Counter        Packed(2);\n    Dcl-S v_AvailableSeats Packed(3);\n    Dcl-s v_TotalSeats     Packed(3);\n    Dcl-S v_IdType         Char(1);\n    Dcl-S v_AirlineId      Char(5);\n    Dcl-S v_DepTime        Time;\n    Dcl-S v_BkDate         Date;\n\n\n    v_IdType = 'B';\n\n   // Incremnting Booking Id\n    BKID     = AutoInc(v_IdType);\n    FLTID    = p_FltId;\n    DDEPDATE = p_DepartureDate;\n\n   // Fetching Flight Data from file FLIGHTPF\n    Exec Sql\n      Select FLTORIGIN,FLTDEST,FLTDEPTIME,AIRID\n      Into :FLTORIGIN,:FLTDEST,:FLTDEPTIME,:v_AirlineId\n      From FlightPf Where FLTID = :p_FLtId;\n\n   // Fetching Airline name from file AIRMASTER\n    Exec Sql\n      Select AIRNAME Into :AIRNAME\n      From Airmaster Where AIRID = :v_AirlineId;\n\n    v_BkDate = %Date();\n\n   // Inserting booking data into file BOOKINGPF\n    Exec Sql\n      Insert Into Bookingpf (BKID,USRID,FLTID,TOTTKT,BKSEATCAT,\n      BKPRICE,BKDATE,BKDEPDATE,BKDEPTIME,BKSTATUS,BKREMARK)\n      Values (:BKID,:v_CustomerId,:p_FltId,:p_NumPsngr,:p_SeatCatg,\n      (:p_NumPsngr * :p_SeatPrice),:v_BkDate,:p_DepartureDate,\n      :FLTDEPTIME,'U','Upcoming');\n\n    Exec Sql\n      Commit;\n\n   // Fetching Departure Time from file BOOKINGPF\n    Exec Sql\n        Select BKDEPTIME Into :v_DepTime\n        From Dheeraj/BookingPf Where BKID = :BKID;\n\n    v_Counter = 1;\n\n   // Booking tickets\n    Dow v_Counter <= p_NumPsngr;\n      v_IdType = 'T';\n\n     // Incrementing Ticket Id\n      TKTID    = AutoInc(v_IdType);\n\n     // Fetching number of seats in flight according to seat category from file FLIGHTPF\n      If p_SeatCatg = 'B';\n\n       // Fetching number of business class seats\n        Exec Sql\n          Select FLTBCLASS Into :v_TotalSeats\n          From FLIGHTPF Where FLTID = :p_FltId;\n      ElseIf p_SeatCatg = 'P';\n\n         // Fetching number of premium class seats\n          Exec Sql\n            Select FLTPCLASS Into :v_TotalSeats\n            From FLIGHTPF Where FLTID = :p_FltId;\n      ElseIf p_SeatCatg = 'E';\n\n         // Fetching number of economy class seats\n          Exec Sql\n            Select FLTECLASS Into :v_TotalSeats\n            From FLIGHTPF Where FLTID = :p_FltId;\n      EndIf;\n\n     // Calculating total seats available in flight\n      v_AvailableSeats = SeatCnt(p_FltId:p_DepartureDate:p_SeatCatg);\n      DAVAILSEAT = v_TotalSeats - v_AvailableSeats;\n      DPSGHEADER = 'Passenger ' + %Char(v_Counter);\n\n     // Display screen BOOKTICKET\n      Write Header;\n      Exfmt BOOKTICKET;\n\n     // Handle screen operations\n      Select;\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        If v_IndTktBooked = *Off;\n          Exec Sql\n            Delete From DHEERAJ/BOOKINGPF\n            Where BKID = :BKID;\n          Leave;\n        EndIf;\n        v_Counter -= 1;\n        Exec Sql\n          Update DHEERAJ/BOOKINGPF Set TOTTKT = :v_Counter,\n          BKPRICE = (:v_Counter * :p_SeatPrice)\n          Where BKID = :BKID;\n        Exec Sql Commit;\n        Leave;\n\n     // Prompt for passenger gender\n      When FLD = 'DPSGGENDER' And Prompt = *On;\n        Prompt = *Off;\n        v_Key1 = 'GENDER';\n        v_Key2 = 'GENDER';\n        v_PHeader = 'Select Gender';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DPSGGENDER = #Output3.v_KeyDesc;\n\n     // Booking ticket if validation passes\n      When Confirm = *On and v_FlagError = *Off;\n        Confirm = *Off;\n        v_Flagerror = *On;\n        v_IdType = 'T';\n        TKTID = AutoInc(v_IdType);\n\n       // Generate seat number\n        TKSEATNUM = GnrtSeat(p_FltId:p_SeatCatg:v_AvailableSeats);\n\n       // incrementing passenger id if it is empty\n        If v_PassengerId = *Blanks;\n          v_IdType = 'P';\n          v_PassengerId = AutoInc(v_IdType);\n\n         // Inserting passenger info in file PSNGRPF\n          Exec Sql\n            Insert Into PsngrPf (PSGID,USRID,PSGNAME,PSGGENDER\n            ,PSGAGE)\n            Values (:v_PassengerId, :v_CustomerId, :DPSGNAME,\n            :DPSGGENDER, :DPSGAGE);\n        EndIf;\n\n       // Inserting new ticket info in file TICKETPF\n        Exec Sql\n          Insert Into TicketPf (TKTID,BKID,PSGID,TKSEATNUM,\n          TKTPRICE,TKSTATUS,TKREMARK)\n          Values (:TKTID,:BKID,:v_PassengerId,:TKSEATNUM,\n          :p_SeatPrice,'U','Upcoming');\n\n       // Inserting seat number in file FLTSEATPF\n        If SQLCOD = 0;\n          DCUSTMRERR = 'Ticket Booked For Passenger ' + DPSGNAME;\n          Clear DPSGNAME;\n          Clear DPSGAGE;\n          Clear DPSGGENDER;\n          Clear TKTID;\n          Clear v_PassengerId;\n          v_Counter += 1;\n          Exec Sql\n            Insert Into FLTSEATPF (SEATNUMBER,FLTID,SEATCATG,TRAVELDATE,\n            TRAVELTIME)\n            Values (:TKSEATNUM,:p_FltId,:p_SeatCatg,:p_DepartureDate,\n            :v_DepTime);\n          Clear TKSEATNUM;\n          v_IndTktBooked = *On;\n        EndIf;\n\n     // Validation for passenger data\n      Other;\n\n       // reset indicator\n        ResetIndicator();\n\n       // validation\n        ValidateTicket();\n\n        If v_FlagError = *Off;\n          DCUSTMRERR = 'Press F6 to book ticket';\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;\n\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: AutoInc\n // Description.......: Sub Procedure to autoincrement booking id, ticket id,\n // and passenger id\n //------------------------------------------------------------------------------------------\n  Dcl-proc AutoInc;\n    Dcl-pi AutoInc Char(5);\n      p_IdType Char(1);\n    End-Pi;\n\n   // Local variable\n    Dcl-S v_IntId Packed(4);\n    Dcl-S v_Id    Char(5);\n\n   // Auto Increment Booking Id\n    If p_IdType = 'B';\n\n     // Fetching maximum id from file BOOKINGPF\n      Exec Sql\n        Select Max(BkId) Into :v_Id\n        From DHEERAJ/BOOKINGPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'B0001';\n        Return v_Id;\n\n     // Id Increment by 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'B' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n   // Auto Increment Ticket Id\n    ElseIf p_IdType = 'T';\n\n     // Fetching maximum id from file TICKETPF\n      Exec Sql\n        Select Max(TKTID) Into :v_Id\n        From DHEERAJ/TICKETPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'T0001';\n        Return v_Id;\n\n     // Increment Id by 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'T' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n   // Auto Increment Passenger Id\n    ElseIf p_IdType = 'P';\n\n     // Fetching maximum id from file PSNGRPF\n      Exec Sql\n        Select Max(PSGID) Into :v_Id\n        From DHEERAJ/PSNGRPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'P0001';\n        Return v_Id;\n\n     // Increment Id By 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'P' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n    EndIf;\n  End-proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: ValidateTicket\n // Description.......: Procedure to handle validation for ticket\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ValidateTicket;\n\n   // Passenger Name Cannot be blank\n    If DPSGNAME = *Blanks;\n      v_WrongPsgName = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Passenger Name: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Passenger gender cannot be blank\n    If DPSGGENDER = *Blanks;\n      v_WrongPsgGender = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Gender: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Passenger age cannot be blank\n    If DPSGAGE = *Zeros;\n      v_WrongPsgAge = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Age: Mandatory Field';\n      Return;\n    EndIf;\n  End-Proc;","context":"flightpf.table:\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\npsngrpf.table:\nCreate Or Replace Table Passenger_Table(\n Psg_Id             For Column PSGID      Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Psg_Name           For Column PSGNAME    Char(20) With Default ' ',\n Psg_Gender         For Column PSGGENDER  Char(1) With Default ' ',\n Psg_Age            For Column PSGAGE     Numeric(2) With Default 0,\nPRIMARY KEY (PSGID),\nFOREIGN KEY (USRID) References USRMASTER(USRID)\n )\nRcdfmt PSNGRPFR;\n\n\nRename table Passenger_Table To System Name PSNGRPF;\n\nLabel On Table Passenger_Table Is 'Passenger Details';\n\nLabel On Column Passenger_Table(\n PSGID       Is 'Passenger Id',\n USRID       Is 'User Id',\n PSGNAME     Is 'Name',\n PSGGENDER   Is 'Gender',\n PSGAGE      Is 'Age');\n\nLabel On Column Passenger_Table(\n PSGID       Text Is 'Passenger Id',\n USRID       Text Is 'User Id',\n PSGNAME     Text Is 'Name',\n PSGGENDER   Text Is 'Gender',\n PSGAGE      Text Is 'Age');\n\n\nbookingpf.table:\nCreate Or Replace Table Booking_Table(\n Bk_Id              For Column BKID       Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Tot_Tickets        For Column TOTTKT     Numeric(2) Not Null With Default 0,\n Bk_SeatCat         For Column BKSEATCAT  Char(1) Not Null With Default ' ',\n Bk_Price           For Column BKPRICE    Numeric(6) Not Null With Default 0,\n Bk_Date            For Column BKDATE     Date,\n Bk_Dep_Date        For Column BKDEPDATE  Date,\n Bk_Dep_Time        For Column BKDEPTIME  Time,\n Bk_Status          For Column BKSTATUS   Char(1) With Default 'U',\n Bk_Remark          For Column BKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (BKID)\n )\nRcdfmt BOOKINGPFR;\n\n\nRename table Booking_Table To System Name BOOKINGPF;\n\nLabel On Table Booking_Table Is 'Booking Details';\n\nLabel On Column Booking_Table(\n BKID        Is 'Booking Id',\n USRID       Is 'User Id',\n FLTID       Is 'Flight Id',\n BKDATE      Is 'Booking Date',\n BKDEPDATE   Is 'Departure Date',\n BKDEPTIME   Is 'Departure Time',\n TOTTKT      Is 'Total Tickets',\n BKSEATCAT   Is 'Seat Category',\n BKPRICE     Is 'Booking Price',\n BKSTATUS    Is 'Booking Status',\n BKREMARK    Is 'Remark');\n\nLabel On Column Booking_Table(\n BKID        Text Is 'Booking Id',\n USRID       Text Is 'User Id',\n FLTID       Text Is 'Flight Id',\n BKDATE      Text Is 'Booking Date',\n BKDEPDATE   Text Is 'Departure Date',\n BKDEPTIME   Text Is 'Departure Time',\n TOTTKT      Text Is 'Total Tickets',\n BKSEATCAT   Text Is 'Seat Category',\n BKPRICE     Text Is 'Booking Price',\n BKSTATUS    Text Is 'Booking Status',\n BKREMARK    Text Is 'Remark');\n\n\nticketpf.table:\nCreate Or Replace Table Ticket_Table(\n Tkt_Id             For Column TKTID      Char(5) Not Null,\n Bk_Id              For Column BKID       Char(5) Not Null,\n Psg_Id             For Column PSGID      Char(5) Not Null,\n Tkt_Price          For Column TKTPRICE   Numeric(6) Not Null With Default 0,\n Tkt_Seat_Number    For Column TKSEATNUM  Char(10) With Default ' ',\n Tkt_Status         For Column TKSTATUS   Char(1) With Default 'U',\n Tkt_Remark         For Column TKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (TKTID),\nFOREIGN KEY (PSGID) References PSNGRPF(PSGID),\nFOREIGN KEY (BKID)  References BOOKINGPF(BKID)\n )\nRcdfmt TICKETPFR;\n\n\nRename table Ticket_Table To System Name TICKETPF;\n\nLabel On Table Ticket_Table Is 'Ticket Details';\n\nLabel On Column Ticket_Table(\n TKTID       Is 'Ticket Id',\n BKID        Is 'Booking Id',\n PSGID       Is 'Passenger Id',\n TKTPRICE    Is 'Ticket Price',\n TKSEATNUM   Is 'Seat Number',\n TKSTATUS    Is 'Ticket Status',\n TKREMARK    Is 'Remark');\n\nLabel On Column Ticket_Table(\n TKTID       Text Is 'Ticket Id',\n BKID        Text Is 'Booking Id',\n PSGID       Text Is 'Passenger Id',\n TKTPRICE    Text Is 'Ticket Price',\n TKSEATNUM   Text Is 'Seat Number',\n TKSTATUS    Text Is 'Ticket Status',\n TKREMARK    Text Is 'Remark');\n\n\n \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\ncustmrfltm.sqlrpgle:\n  Dcl-F Flightpf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F PsngrPf    Disk Usage(*Input:*Output) Keyed;\n  Dcl-F BookingPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F TicketPf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F FltSeatPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n  Dcl-Ds FlightDs Qualified;\n    v_FltId   Char(5);\n    v_AirName Char(20);\n    v_TotDur  Time;\n    v_BPrice  Packed(6);\n    v_PPrice  Packed(6);\n    v_EPrice  Packed(6);\n    v_Rating  Packed(2:1);\n  End-Ds;\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_FlagFltId    Char(5);\n  Dcl-S v_PassengerId  Char(5);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n  Dcl-S v_FlagError    Ind Inz(*On);\n  Dcl-S v_IndTktBooked Ind Inz(*Off);","output":"This fully-free SQLRPGLE module `Custmrfltm` having one exported procedure `SearchFlight` allows a customer to Search for available flights based on input criteria, view ticket details, book tickets for one or more passengers, validate input and manage booking and ticketing information.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CUSTMRFLTM/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"module","depth":"sum"}}
{"id":"CUSTMRFLTM_api","input_data":"**Free\n\n // Control Specification\n  /Title CUSTMRFLTM - Program to handle flight search and booking operation\n  Ctl-Opt Option(*Nodebugio:*Srcstmt) Nomain;\n\n // Physical File Declaration\n  Dcl-F Flightpf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F PsngrPf    Disk Usage(*Input:*Output) Keyed;\n  Dcl-F BookingPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F TicketPf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F FltSeatPf  Disk Usage(*Input:*Output) Keyed;\n\n // Display File Declaration\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n\n // Data Structure Declaration\n\n // Indicator Data Structure\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n\n // #Output3 - Stores output from sub-procedure WindowPrompt\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n\n // FlightDs - Stores data of a flight\n  Dcl-Ds FlightDs Qualified;\n    v_FltId   Char(5);\n    v_AirName Char(20);\n    v_TotDur  Time;\n    v_BPrice  Packed(6);\n    v_PPrice  Packed(6);\n    v_EPrice  Packed(6);\n    v_Rating  Packed(2:1);\n  End-Ds;\n\n // Copy Book Stores Procedure Prototypes\n  /Copy CpyBookPr\n\n // Standalone Variable\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_FlagFltId    Char(5);\n  Dcl-S v_PassengerId  Char(5);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n\n // Standalone Indicators\n  Dcl-S v_FlagError    Ind Inz(*On);\n  Dcl-S v_IndTktBooked Ind Inz(*Off);\n\n //------------------------------------------------------------------------------------------\n // Procedure Name.: SearchFlight\n // Description....: Procedure to handle flight searching\n //------------------------------------------------------------------------------------------\n  Dcl-Proc SearchFlight Export;\n    Dcl-Pi SearchFlight;\n      p_UserId Char(5);\n      p_UserName Char(20);\n    End-Pi;\n    Reset SEARCHFLT;\n    UserFld = p_UserName;\n    v_CustomerId = p_UserId;\n\n   // Display screen SEARCHFLT\n    Dow Exit = *Off Or Cancel = *Off;\n      Write Header;\n      Exfmt SEARCHFLT;\n\n     // Handle Screen Operations for SEARCHFLT\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Refresh screen\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset SEARCHFLT;\n\n     // Prompt for Origin City\n      When FLD = 'DORIGIN' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Origin';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DORIGIN = #Output3.v_KeyDesc;\n\n     // Prompt for destination city\n      When FLD = 'DDEST' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Destination';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DDEST = #Output3.v_KeyDesc;\n\n     // Validate the data on screen SEARCHFLT\n      Other;\n\n       // Reset Field and standalone Indicators\n        ResetIndicator();\n\n       // Validate data\n        ValidateSearch();\n\n       // Showing Search Results\n        If v_FlagError = *Off;\n\n         // Seat Category\n          If DSEATCHC = 1;\n            v_SeatCatg = 'B';\n          ElseIf DSEATCHC = 2;\n            v_SeatCatg = 'P';\n          ElseIf DSEATCHC = 3;\n            v_SeatCatg = 'E';\n          EndIf;\n\n         // Subfile for Search Results\n          FltSubfile(DORIGIN:DDEST:DDATE:DNUMPSNGR:v_SeatCatg);\n          Reset SEARCHFLT;\n          v_FlagError = *On;\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name.:  ValidateSearch\n // Description........:  Sub Procedure to Validate Flight Search Data\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ValidateSearch;\n\n   // Origin City should not be blank\n    If DORIGIN = *Blanks;\n      v_WrongOrigin = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Origin: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Destination city should not be blank\n    If DDEST = *Blanks;\n      v_WrongDest = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Destination: Mandatory Field';\n      Return;\n\n   // Destination should not match with origin\n    ElseIf DDEST = DORIGIN;\n      v_WrongDest = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Destination: Origin And Destination Cannot Be Same';\n      Return;\n    EndIf;\n\n   // Departure Date should not be blank\n    If %Char(DDATE) = '0001-01-01';\n      v_WrongDate = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Date: Mandatory Field';\n      Return;\n\n   // Departure date should not be past date\n    ElseIf DDATE < %date();\n      v_WrongDate = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Date: Departure Date Should Be Upcoming Date';\n      Return;\n    EndIf;\n\n   // Number of passenger should not be zero\n    If DNUMPSNGR = *Zeros;\n      v_WrongNumPsngr = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Number Of Passengers: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Seat Category should not be blank\n    If DSEATCHC = *Zeros;\n      v_WrongSeatChc = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Seat Category: Mandatory Field';\n      Return;\n    EndIf;\n\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ResetIndicator\n // Description.......:  Sub Procedure to Reset All Field and Standalone indicators\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ResetIndicator;\n    v_FlagError = *Off;\n    Reset v_WrongDate;\n    Reset v_WrongDest;\n    Reset v_WrongOrigin;\n    Reset v_WrongNumPsngr;\n    Reset v_WrongSeatChc;\n    Reset v_WrongPsgAge;\n    Reset v_WrongPsgGender;\n    Reset v_WrongPsgName;\n    Clear DCUSTMRERR;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  FltSubfile\n // Description.......:  Sub Procedure to Handle Subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc FltSubfile;\n    Dcl-Pi FltSubfile;\n      p_Origin        Char(20);\n      p_Destination   Char(20);\n      p_DepartureDate Date;\n      p_NumOfPsngr    Packed(2);\n      p_SeatCatg      Char(1);\n    End-Pi;\n\n   // Clear, load, and display subfile FLTLISTSFL\n    Dow Exit = *Off Or Cancel = *Off;\n\n     // Clear subfile FLTLISTSFL\n      ClearFlightSfl();\n\n     // Load Subfile FLTLISTSFL\n      LoadFlightSfl(p_Origin:p_Destination:p_SeatCatg);\n\n     // Display subfile FLTLISTSFL\n      DisplayFlightSfl();\n\n     // Handle screen operations\n      Select;\n\n       // Exit out of screen\n        When Exit = *On Or Cancel = *On;\n          Cancel = *Off;\n          Reset SFLERROR;\n          v_OverlayInd = *Off;\n          Leave;\n\n       // Refresh screen\n        When Refresh = *On;\n          Refresh = *Off;\n          Reset FLTLISTCTL;\n\n       // Read Subfile FLTLISTSFL\n        Other;\n          ReadFlightSfl(p_NumOfPsngr:p_DepartureDate:p_SeatCatg);\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ClearFlightSfl\n // Description.......:  Sub Procedure to clear subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ClearFlightSfl;\n    FltSflClr = *On;\n    v_Rrn = 0;\n    Write FLTLISTCTL;\n    FltSflClr = *Off;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  LoadFlightSfl\n // Description.......: Procedure to Load subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc LoadFlightSfl;\n    Dcl-Pi LoadFlightSfl;\n      p_Origin Char(20);\n      p_Destination Char(20);\n      p_SeatCatg Char(1);\n    End-Pi;\n\n    DSRCORIGIN = p_Origin;\n    DSRCDEST   = p_Destination;\n\n   // position to\n    If DFLTPOSTO <> *Blanks;\n\n     // Fetching position to data from file FLIGHTPF and AIRMASTER\n      Exec Sql\n        Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n        FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n        AIR.AIRRATING,FLT.FLTID\n        Into :FLIGHTDS,:v_FlagFltId\n        FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n        ON FLT.AIRID = AIR.AIRID\n        Where (FLT.FLTID = :DFLTPOSTO Or AIR.AIRNAME = :DFLTPOSTO) And\n        (FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n        And FLT.FLTSTATUS = 'A');\n\n     // Successfull execution of sql query\n      If Sqlcod = 0;\n\n       // Assigning data from FLIGHTDS to Subfile Fields\n        DFLTID    = FLIGHTDS.v_FltId;\n        DAIRLINE  = FLIGHTDS.v_AirName;\n        DTOTALDUR = FLIGHTDS.v_TotDur;\n\n       // Validating data for subfile fields\n        If p_SeatCatg = 'B';\n          DPRICE = %Char(FLIGHTDS.v_BPrice);\n        ElseIf p_SeatCatg = 'P';\n          DPRICE = %Char(FLIGHTDS.v_PPrice);\n        ElseIf p_SeatCatg = 'E';\n          DPRICE = %Char(FLIGHTDS.v_EPrice);\n        EndIf;\n        DRATING = FLIGHTDS.v_Rating;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write FLTLISTSFL;\n      EndIf;\n\n     // Declare cursor to Fetch data from file FLIGHTPF and AIRMASTER\n      Exec Sql\n        Declare DataCursorPos Cursor For\n        Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n        FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n        AIR.AIRRATING\n        FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n        ON FLT.AIRID = AIR.AIRID\n        Where (FLT.FLTID != :v_FlagFltId) And\n        (FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n        And FLT.FLTSTATUS = 'A');\n\n     // Open cursor\n      Exec Sql\n        Open DataCursorPos;\n\n     // Fetching data from Cursor to FLIGHTDS\n      Exec Sql\n        Fetch From DataCursorPos Into :FlightDs;\n\n      Dow SQLCOD = 0;\n\n       // Assigning data to subfile fields from FLIGHTDS\n        DFLTID    = FLIGHTDS.v_FltId;\n        DAIRLINE  = FLIGHTDS.v_AirName;\n        DTOTALDUR = FLIGHTDS.v_TotDur;\n\n       // Validation for subfile field\n        If p_SeatCatg = 'B';\n          DPRICE = %Char(FLIGHTDS.v_BPrice);\n        ElseIf p_SeatCatg = 'P';\n          DPRICE = %Char(FLIGHTDS.v_PPrice);\n        ElseIf p_SeatCatg = 'E';\n          DPRICE = %Char(FLIGHTDS.v_EPrice);\n        EndIf;\n        DRATING = FLIGHTDS.v_Rating;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write FLTLISTSFL;\n\n       // Fetching next record from cursor\n        Exec Sql\n          Fetch Next From DataCursorPos Into :FlightDs;\n\n      Enddo;\n\n     // Close cursor\n      Exec Sql\n        Close DataCursorPos;\n\n      Return;\n    EndIf;\n\n   // Declare cursor to fetch data from file FLIGHTPF and AIRMASTER\n    Exec Sql\n      Declare DataCursor Cursor For\n      Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n      FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n      AIR.AIRRATING\n      FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n      ON FLT.AIRID = AIR.AIRID\n      Where FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n      And FLT.FLTSTATUS = 'A';\n\n   // Open cursor\n    Exec Sql\n      Open DataCursor;\n\n   // Fetch data from cursor to FLIGHTDS\n    Exec Sql\n      Fetch From DataCursor Into :FLIGHTDS;\n\n   // Fetching records till the end of files\n    Dow SQLCOD = 0;\n\n     // Assigning data to subfile fields from FLIGHTDS\n      DFLTID    = FLIGHTDS.v_FltId;\n      DAIRLINE  = FLIGHTDS.v_AirName;\n      DTOTALDUR = FLIGHTDS.v_TotDur;\n\n     // Validation  for Subfile fields\n      If p_SeatCatg = 'B';\n        DPRICE = %Char(FLIGHTDS.v_BPrice);\n      ElseIf p_SeatCatg = 'P';\n        DPRICE = %Char(FLIGHTDS.v_PPrice);\n      ElseIf p_SeatCatg = 'E';\n        DPRICE = %Char(FLIGHTDS.v_EPrice);\n      EndIf;\n      DRATING = FLIGHTDS.v_Rating;\n      v_Rrn = v_Rrn + 1;\n\n     // Rrn cannot be greater than 9999\n      If v_Rrn > 9999;\n        Leave;\n      EndIf;\n      Write FLTLISTSFL;\n\n     // Fetch next record from cursor\n      Exec Sql\n        Fetch Next From DataCursor Into :FLIGHTDS;\n    Enddo;\n\n   // CLose cursor\n    Exec Sql\n      Close DataCursor;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  DisplayFlightSfl\n // Description.......:  Sub Procedure to Display subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc DisplayFlightSfl;\n    v_OverlayInd = *On;\n    FltSflDsp = *On;\n    FltSflCtl = *On;\n    FltSflEnd = *On;\n\n   // Cannot display if Rrn < 1\n    If v_Rrn < 1;\n      FltSflDsp = *Off;\n      SFLERROR = 'Sorry, No Flights Are There As Per Your Requirement';\n    EndIf;\n    SflFtr = 'F3=Exit  F5=Refresh  F12=Cancel';\n    Write Header;\n    Write SFLFOOTER;\n    Exfmt FLTLISTCTL;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // SUb Procedure Name:  ReadFlightSfl\n // Description.......:  Sub Procedure to Read subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ReadFlightSfl;\n    Dcl-Pi ReadFlightSfl;\n      p_NumberOfPsngr Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg Char(1);\n    End-Pi;\n\n   // Cannot read empty subfile\n    Monitor;\n      Chain DFLTCHC FLTLISTSFL;\n      Readc FLTLISTSFL;\n\n     // Reading till end of subfile\n      Dow Not %EOF();\n\n       // Operations to perform\n        Select;\n\n       // View Flight\n        When DFLTCHC = 5;\n          Clear DFLTCHC;\n          ViewFlightProc(p_NumberOfPsngr:p_DepartureDate:p_SeatCatg);\n\n       // Clear DFLTCHC\n        Other;\n          Clear DFLTCHC;\n        Endsl;\n        Readc FLTLISTSFL;\n      Enddo;\n\n     // Error Handle\n      On-Error;\n        SFLERROR = 'Sorry, No Flights Are There As Per Your Requirement';\n    EndMon;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ViewFlightProc\n // Description.......:  Sub Procedure to View Flight details\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ViewFlightProc;\n    Dcl-Pi ViewFlightProc;\n      p_NumberOfPsngr Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg Char(1);\n    End-Pi;\n\n   // Fetching data from file FLIGHTPF to screen VIEWFLIGHT\n    Chain DFLTID FLightPf;\n\n   // Fetching data from file AIRMASTER to screen VIEWFLIGHT\n    Chain AirId Airmaster;\n    DFLTHEADER = %Trim(AirName) + ' ' + FLTID;\n\n   // Display screen VIEWFLIGHT\n    Dow Exit = *Off Or Cancel = *Off;\n      DFLTAIRLIN = AIRNAME;\n\n     // Setting ticket price according to seat category\n      If p_SeatCatg = 'B';\n        DTKTPRICE = FLTBPRICE;\n      ElseIf p_SeatCatg = 'P';\n        DTKTPRICE = FLTPPRICE;\n      ElseIf p_SeatCatg = 'E';\n        DTKTPRICE = FLTEPRICE;\n      EndIf;\n\n      Write Header;\n      Exfmt VIEWFLIGHT;\n\n     // Handle Screen Operation for ViewFlight\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Book Tickets\n      When Confirm = *On;\n        Confirm = *Off;\n        BookTicketProc(DFLTID:p_NumberOfPsngr:p_DepartureDate:p_SeatCatg:\n        DTKTPRICE);\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: BookTicket\n // Description.......: Procedure to handle ticket booking\n //------------------------------------------------------------------------------------------\n  Dcl-Proc BookTicketProc;\n    Dcl-Pi BookTicketProc;\n      p_FltId         Char(5);\n      p_NumPsngr      Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg      Char(1);\n      p_SeatPrice     Packed(6);\n    End-Pi;\n\n   // Local Variable\n    Dcl-S v_Counter        Packed(2);\n    Dcl-S v_AvailableSeats Packed(3);\n    Dcl-s v_TotalSeats     Packed(3);\n    Dcl-S v_IdType         Char(1);\n    Dcl-S v_AirlineId      Char(5);\n    Dcl-S v_DepTime        Time;\n    Dcl-S v_BkDate         Date;\n\n\n    v_IdType = 'B';\n\n   // Incremnting Booking Id\n    BKID     = AutoInc(v_IdType);\n    FLTID    = p_FltId;\n    DDEPDATE = p_DepartureDate;\n\n   // Fetching Flight Data from file FLIGHTPF\n    Exec Sql\n      Select FLTORIGIN,FLTDEST,FLTDEPTIME,AIRID\n      Into :FLTORIGIN,:FLTDEST,:FLTDEPTIME,:v_AirlineId\n      From FlightPf Where FLTID = :p_FLtId;\n\n   // Fetching Airline name from file AIRMASTER\n    Exec Sql\n      Select AIRNAME Into :AIRNAME\n      From Airmaster Where AIRID = :v_AirlineId;\n\n    v_BkDate = %Date();\n\n   // Inserting booking data into file BOOKINGPF\n    Exec Sql\n      Insert Into Bookingpf (BKID,USRID,FLTID,TOTTKT,BKSEATCAT,\n      BKPRICE,BKDATE,BKDEPDATE,BKDEPTIME,BKSTATUS,BKREMARK)\n      Values (:BKID,:v_CustomerId,:p_FltId,:p_NumPsngr,:p_SeatCatg,\n      (:p_NumPsngr * :p_SeatPrice),:v_BkDate,:p_DepartureDate,\n      :FLTDEPTIME,'U','Upcoming');\n\n    Exec Sql\n      Commit;\n\n   // Fetching Departure Time from file BOOKINGPF\n    Exec Sql\n        Select BKDEPTIME Into :v_DepTime\n        From Dheeraj/BookingPf Where BKID = :BKID;\n\n    v_Counter = 1;\n\n   // Booking tickets\n    Dow v_Counter <= p_NumPsngr;\n      v_IdType = 'T';\n\n     // Incrementing Ticket Id\n      TKTID    = AutoInc(v_IdType);\n\n     // Fetching number of seats in flight according to seat category from file FLIGHTPF\n      If p_SeatCatg = 'B';\n\n       // Fetching number of business class seats\n        Exec Sql\n          Select FLTBCLASS Into :v_TotalSeats\n          From FLIGHTPF Where FLTID = :p_FltId;\n      ElseIf p_SeatCatg = 'P';\n\n         // Fetching number of premium class seats\n          Exec Sql\n            Select FLTPCLASS Into :v_TotalSeats\n            From FLIGHTPF Where FLTID = :p_FltId;\n      ElseIf p_SeatCatg = 'E';\n\n         // Fetching number of economy class seats\n          Exec Sql\n            Select FLTECLASS Into :v_TotalSeats\n            From FLIGHTPF Where FLTID = :p_FltId;\n      EndIf;\n\n     // Calculating total seats available in flight\n      v_AvailableSeats = SeatCnt(p_FltId:p_DepartureDate:p_SeatCatg);\n      DAVAILSEAT = v_TotalSeats - v_AvailableSeats;\n      DPSGHEADER = 'Passenger ' + %Char(v_Counter);\n\n     // Display screen BOOKTICKET\n      Write Header;\n      Exfmt BOOKTICKET;\n\n     // Handle screen operations\n      Select;\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        If v_IndTktBooked = *Off;\n          Exec Sql\n            Delete From DHEERAJ/BOOKINGPF\n            Where BKID = :BKID;\n          Leave;\n        EndIf;\n        v_Counter -= 1;\n        Exec Sql\n          Update DHEERAJ/BOOKINGPF Set TOTTKT = :v_Counter,\n          BKPRICE = (:v_Counter * :p_SeatPrice)\n          Where BKID = :BKID;\n        Exec Sql Commit;\n        Leave;\n\n     // Prompt for passenger gender\n      When FLD = 'DPSGGENDER' And Prompt = *On;\n        Prompt = *Off;\n        v_Key1 = 'GENDER';\n        v_Key2 = 'GENDER';\n        v_PHeader = 'Select Gender';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DPSGGENDER = #Output3.v_KeyDesc;\n\n     // Booking ticket if validation passes\n      When Confirm = *On and v_FlagError = *Off;\n        Confirm = *Off;\n        v_Flagerror = *On;\n        v_IdType = 'T';\n        TKTID = AutoInc(v_IdType);\n\n       // Generate seat number\n        TKSEATNUM = GnrtSeat(p_FltId:p_SeatCatg:v_AvailableSeats);\n\n       // incrementing passenger id if it is empty\n        If v_PassengerId = *Blanks;\n          v_IdType = 'P';\n          v_PassengerId = AutoInc(v_IdType);\n\n         // Inserting passenger info in file PSNGRPF\n          Exec Sql\n            Insert Into PsngrPf (PSGID,USRID,PSGNAME,PSGGENDER\n            ,PSGAGE)\n            Values (:v_PassengerId, :v_CustomerId, :DPSGNAME,\n            :DPSGGENDER, :DPSGAGE);\n        EndIf;\n\n       // Inserting new ticket info in file TICKETPF\n        Exec Sql\n          Insert Into TicketPf (TKTID,BKID,PSGID,TKSEATNUM,\n          TKTPRICE,TKSTATUS,TKREMARK)\n          Values (:TKTID,:BKID,:v_PassengerId,:TKSEATNUM,\n          :p_SeatPrice,'U','Upcoming');\n\n       // Inserting seat number in file FLTSEATPF\n        If SQLCOD = 0;\n          DCUSTMRERR = 'Ticket Booked For Passenger ' + DPSGNAME;\n          Clear DPSGNAME;\n          Clear DPSGAGE;\n          Clear DPSGGENDER;\n          Clear TKTID;\n          Clear v_PassengerId;\n          v_Counter += 1;\n          Exec Sql\n            Insert Into FLTSEATPF (SEATNUMBER,FLTID,SEATCATG,TRAVELDATE,\n            TRAVELTIME)\n            Values (:TKSEATNUM,:p_FltId,:p_SeatCatg,:p_DepartureDate,\n            :v_DepTime);\n          Clear TKSEATNUM;\n          v_IndTktBooked = *On;\n        EndIf;\n\n     // Validation for passenger data\n      Other;\n\n       // reset indicator\n        ResetIndicator();\n\n       // validation\n        ValidateTicket();\n\n        If v_FlagError = *Off;\n          DCUSTMRERR = 'Press F6 to book ticket';\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;\n\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: AutoInc\n // Description.......: Sub Procedure to autoincrement booking id, ticket id,\n // and passenger id\n //------------------------------------------------------------------------------------------\n  Dcl-proc AutoInc;\n    Dcl-pi AutoInc Char(5);\n      p_IdType Char(1);\n    End-Pi;\n\n   // Local variable\n    Dcl-S v_IntId Packed(4);\n    Dcl-S v_Id    Char(5);\n\n   // Auto Increment Booking Id\n    If p_IdType = 'B';\n\n     // Fetching maximum id from file BOOKINGPF\n      Exec Sql\n        Select Max(BkId) Into :v_Id\n        From DHEERAJ/BOOKINGPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'B0001';\n        Return v_Id;\n\n     // Id Increment by 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'B' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n   // Auto Increment Ticket Id\n    ElseIf p_IdType = 'T';\n\n     // Fetching maximum id from file TICKETPF\n      Exec Sql\n        Select Max(TKTID) Into :v_Id\n        From DHEERAJ/TICKETPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'T0001';\n        Return v_Id;\n\n     // Increment Id by 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'T' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n   // Auto Increment Passenger Id\n    ElseIf p_IdType = 'P';\n\n     // Fetching maximum id from file PSNGRPF\n      Exec Sql\n        Select Max(PSGID) Into :v_Id\n        From DHEERAJ/PSNGRPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'P0001';\n        Return v_Id;\n\n     // Increment Id By 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'P' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n    EndIf;\n  End-proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: ValidateTicket\n // Description.......: Procedure to handle validation for ticket\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ValidateTicket;\n\n   // Passenger Name Cannot be blank\n    If DPSGNAME = *Blanks;\n      v_WrongPsgName = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Passenger Name: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Passenger gender cannot be blank\n    If DPSGGENDER = *Blanks;\n      v_WrongPsgGender = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Gender: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Passenger age cannot be blank\n    If DPSGAGE = *Zeros;\n      v_WrongPsgAge = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Age: Mandatory Field';\n      Return;\n    EndIf;\n  End-Proc;","context":"flightpf.table:\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\npsngrpf.table:\nCreate Or Replace Table Passenger_Table(\n Psg_Id             For Column PSGID      Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Psg_Name           For Column PSGNAME    Char(20) With Default ' ',\n Psg_Gender         For Column PSGGENDER  Char(1) With Default ' ',\n Psg_Age            For Column PSGAGE     Numeric(2) With Default 0,\nPRIMARY KEY (PSGID),\nFOREIGN KEY (USRID) References USRMASTER(USRID)\n )\nRcdfmt PSNGRPFR;\n\n\nRename table Passenger_Table To System Name PSNGRPF;\n\nLabel On Table Passenger_Table Is 'Passenger Details';\n\nLabel On Column Passenger_Table(\n PSGID       Is 'Passenger Id',\n USRID       Is 'User Id',\n PSGNAME     Is 'Name',\n PSGGENDER   Is 'Gender',\n PSGAGE      Is 'Age');\n\nLabel On Column Passenger_Table(\n PSGID       Text Is 'Passenger Id',\n USRID       Text Is 'User Id',\n PSGNAME     Text Is 'Name',\n PSGGENDER   Text Is 'Gender',\n PSGAGE      Text Is 'Age');\n\n\nbookingpf.table:\nCreate Or Replace Table Booking_Table(\n Bk_Id              For Column BKID       Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Tot_Tickets        For Column TOTTKT     Numeric(2) Not Null With Default 0,\n Bk_SeatCat         For Column BKSEATCAT  Char(1) Not Null With Default ' ',\n Bk_Price           For Column BKPRICE    Numeric(6) Not Null With Default 0,\n Bk_Date            For Column BKDATE     Date,\n Bk_Dep_Date        For Column BKDEPDATE  Date,\n Bk_Dep_Time        For Column BKDEPTIME  Time,\n Bk_Status          For Column BKSTATUS   Char(1) With Default 'U',\n Bk_Remark          For Column BKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (BKID)\n )\nRcdfmt BOOKINGPFR;\n\n\nRename table Booking_Table To System Name BOOKINGPF;\n\nLabel On Table Booking_Table Is 'Booking Details';\n\nLabel On Column Booking_Table(\n BKID        Is 'Booking Id',\n USRID       Is 'User Id',\n FLTID       Is 'Flight Id',\n BKDATE      Is 'Booking Date',\n BKDEPDATE   Is 'Departure Date',\n BKDEPTIME   Is 'Departure Time',\n TOTTKT      Is 'Total Tickets',\n BKSEATCAT   Is 'Seat Category',\n BKPRICE     Is 'Booking Price',\n BKSTATUS    Is 'Booking Status',\n BKREMARK    Is 'Remark');\n\nLabel On Column Booking_Table(\n BKID        Text Is 'Booking Id',\n USRID       Text Is 'User Id',\n FLTID       Text Is 'Flight Id',\n BKDATE      Text Is 'Booking Date',\n BKDEPDATE   Text Is 'Departure Date',\n BKDEPTIME   Text Is 'Departure Time',\n TOTTKT      Text Is 'Total Tickets',\n BKSEATCAT   Text Is 'Seat Category',\n BKPRICE     Text Is 'Booking Price',\n BKSTATUS    Text Is 'Booking Status',\n BKREMARK    Text Is 'Remark');\n\n\nticketpf.table:\nCreate Or Replace Table Ticket_Table(\n Tkt_Id             For Column TKTID      Char(5) Not Null,\n Bk_Id              For Column BKID       Char(5) Not Null,\n Psg_Id             For Column PSGID      Char(5) Not Null,\n Tkt_Price          For Column TKTPRICE   Numeric(6) Not Null With Default 0,\n Tkt_Seat_Number    For Column TKSEATNUM  Char(10) With Default ' ',\n Tkt_Status         For Column TKSTATUS   Char(1) With Default 'U',\n Tkt_Remark         For Column TKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (TKTID),\nFOREIGN KEY (PSGID) References PSNGRPF(PSGID),\nFOREIGN KEY (BKID)  References BOOKINGPF(BKID)\n )\nRcdfmt TICKETPFR;\n\n\nRename table Ticket_Table To System Name TICKETPF;\n\nLabel On Table Ticket_Table Is 'Ticket Details';\n\nLabel On Column Ticket_Table(\n TKTID       Is 'Ticket Id',\n BKID        Is 'Booking Id',\n PSGID       Is 'Passenger Id',\n TKTPRICE    Is 'Ticket Price',\n TKSEATNUM   Is 'Seat Number',\n TKSTATUS    Is 'Ticket Status',\n TKREMARK    Is 'Remark');\n\nLabel On Column Ticket_Table(\n TKTID       Text Is 'Ticket Id',\n BKID        Text Is 'Booking Id',\n PSGID       Text Is 'Passenger Id',\n TKTPRICE    Text Is 'Ticket Price',\n TKSEATNUM   Text Is 'Seat Number',\n TKSTATUS    Text Is 'Ticket Status',\n TKREMARK    Text Is 'Remark');\n\n\n \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\ncustmrfltm.sqlrpgle:\n  Dcl-F Flightpf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F PsngrPf    Disk Usage(*Input:*Output) Keyed;\n  Dcl-F BookingPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F TicketPf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F FltSeatPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n  Dcl-Ds FlightDs Qualified;\n    v_FltId   Char(5);\n    v_AirName Char(20);\n    v_TotDur  Time;\n    v_BPrice  Packed(6);\n    v_PPrice  Packed(6);\n    v_EPrice  Packed(6);\n    v_Rating  Packed(2:1);\n  End-Ds;\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_FlagFltId    Char(5);\n  Dcl-S v_PassengerId  Char(5);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n  Dcl-S v_FlagError    Ind Inz(*On);\n  Dcl-S v_IndTktBooked Ind Inz(*Off);","output":"#### Purpose\nThis fully-free SQLRPGLE module `CUSTMRFLTM` having one exported procedure `SearchFlight` provide a user interface and business logic for searching flights, viewing flight details, and booking tickets within an airline reservation system.  \n\n#### Exported procedure `SearchFlight` \n- `SearchFlight` - Main entry point to initiate a flight search operation.\n```rpgle\n        Dcl-Proc SearchFlight Export;\n```\n- The `Export` keyword means `SearchFlight` is intended to be called from outside this module, possibly by another ILE RPG program, CL program, or even as part of a service program (API-style use).\n\n##### Parameters\n- It accepts two input parameters.\n- `p_UserId` - Customer user ID - char(5). \n- `p_UserName` - User name - char(20).\n\n##### Dependencies \n- The following objects should be found in the library list\n- `Customerd` - Workstation Display file used in the `SearchFlight`, `ViewFlightProc`, and booking screens\n- `Bookingpf` - Stores booking info (user, flight, number of tickets, etc.)\n- `Flightpf`  - Stores flight data (ID, duration, prices, origin/destination, status)\n- `Airmaster` - Stores airline master data (ID, name, rating)\n- `PsngrPf`   - Stores passenger data (name, gender, age, etc.)\n- `TicketPf`  - Stores ticket info (seat, passenger, booking ID, price)\n- `FltSeatPf` - Stores seat allocation for a flight on a given date/time\n\n##### Usage example\n```rpgle \n        **free\n         dcl-s userId char(5) inz('U125');  // Set User ID\n         dcl-s userName char(20) inz('John Doe');  // Set User Name\n          SearchFlight(userId : userName);\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CUSTMRFLTM/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"module","depth":"api"}}
{"id":"CUSTMRFLTM_how","input_data":"**Free\n\n // Control Specification\n  /Title CUSTMRFLTM - Program to handle flight search and booking operation\n  Ctl-Opt Option(*Nodebugio:*Srcstmt) Nomain;\n\n // Physical File Declaration\n  Dcl-F Flightpf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F PsngrPf    Disk Usage(*Input:*Output) Keyed;\n  Dcl-F BookingPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F TicketPf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F FltSeatPf  Disk Usage(*Input:*Output) Keyed;\n\n // Display File Declaration\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n\n // Data Structure Declaration\n\n // Indicator Data Structure\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n\n // #Output3 - Stores output from sub-procedure WindowPrompt\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n\n // FlightDs - Stores data of a flight\n  Dcl-Ds FlightDs Qualified;\n    v_FltId   Char(5);\n    v_AirName Char(20);\n    v_TotDur  Time;\n    v_BPrice  Packed(6);\n    v_PPrice  Packed(6);\n    v_EPrice  Packed(6);\n    v_Rating  Packed(2:1);\n  End-Ds;\n\n // Copy Book Stores Procedure Prototypes\n  /Copy CpyBookPr\n\n // Standalone Variable\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_FlagFltId    Char(5);\n  Dcl-S v_PassengerId  Char(5);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n\n // Standalone Indicators\n  Dcl-S v_FlagError    Ind Inz(*On);\n  Dcl-S v_IndTktBooked Ind Inz(*Off);\n\n //------------------------------------------------------------------------------------------\n // Procedure Name.: SearchFlight\n // Description....: Procedure to handle flight searching\n //------------------------------------------------------------------------------------------\n  Dcl-Proc SearchFlight Export;\n    Dcl-Pi SearchFlight;\n      p_UserId Char(5);\n      p_UserName Char(20);\n    End-Pi;\n    Reset SEARCHFLT;\n    UserFld = p_UserName;\n    v_CustomerId = p_UserId;\n\n   // Display screen SEARCHFLT\n    Dow Exit = *Off Or Cancel = *Off;\n      Write Header;\n      Exfmt SEARCHFLT;\n\n     // Handle Screen Operations for SEARCHFLT\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Refresh screen\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset SEARCHFLT;\n\n     // Prompt for Origin City\n      When FLD = 'DORIGIN' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Origin';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DORIGIN = #Output3.v_KeyDesc;\n\n     // Prompt for destination city\n      When FLD = 'DDEST' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Destination';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DDEST = #Output3.v_KeyDesc;\n\n     // Validate the data on screen SEARCHFLT\n      Other;\n\n       // Reset Field and standalone Indicators\n        ResetIndicator();\n\n       // Validate data\n        ValidateSearch();\n\n       // Showing Search Results\n        If v_FlagError = *Off;\n\n         // Seat Category\n          If DSEATCHC = 1;\n            v_SeatCatg = 'B';\n          ElseIf DSEATCHC = 2;\n            v_SeatCatg = 'P';\n          ElseIf DSEATCHC = 3;\n            v_SeatCatg = 'E';\n          EndIf;\n\n         // Subfile for Search Results\n          FltSubfile(DORIGIN:DDEST:DDATE:DNUMPSNGR:v_SeatCatg);\n          Reset SEARCHFLT;\n          v_FlagError = *On;\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name.:  ValidateSearch\n // Description........:  Sub Procedure to Validate Flight Search Data\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ValidateSearch;\n\n   // Origin City should not be blank\n    If DORIGIN = *Blanks;\n      v_WrongOrigin = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Origin: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Destination city should not be blank\n    If DDEST = *Blanks;\n      v_WrongDest = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Destination: Mandatory Field';\n      Return;\n\n   // Destination should not match with origin\n    ElseIf DDEST = DORIGIN;\n      v_WrongDest = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Destination: Origin And Destination Cannot Be Same';\n      Return;\n    EndIf;\n\n   // Departure Date should not be blank\n    If %Char(DDATE) = '0001-01-01';\n      v_WrongDate = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Date: Mandatory Field';\n      Return;\n\n   // Departure date should not be past date\n    ElseIf DDATE < %date();\n      v_WrongDate = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Date: Departure Date Should Be Upcoming Date';\n      Return;\n    EndIf;\n\n   // Number of passenger should not be zero\n    If DNUMPSNGR = *Zeros;\n      v_WrongNumPsngr = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Number Of Passengers: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Seat Category should not be blank\n    If DSEATCHC = *Zeros;\n      v_WrongSeatChc = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Seat Category: Mandatory Field';\n      Return;\n    EndIf;\n\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ResetIndicator\n // Description.......:  Sub Procedure to Reset All Field and Standalone indicators\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ResetIndicator;\n    v_FlagError = *Off;\n    Reset v_WrongDate;\n    Reset v_WrongDest;\n    Reset v_WrongOrigin;\n    Reset v_WrongNumPsngr;\n    Reset v_WrongSeatChc;\n    Reset v_WrongPsgAge;\n    Reset v_WrongPsgGender;\n    Reset v_WrongPsgName;\n    Clear DCUSTMRERR;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  FltSubfile\n // Description.......:  Sub Procedure to Handle Subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc FltSubfile;\n    Dcl-Pi FltSubfile;\n      p_Origin        Char(20);\n      p_Destination   Char(20);\n      p_DepartureDate Date;\n      p_NumOfPsngr    Packed(2);\n      p_SeatCatg      Char(1);\n    End-Pi;\n\n   // Clear, load, and display subfile FLTLISTSFL\n    Dow Exit = *Off Or Cancel = *Off;\n\n     // Clear subfile FLTLISTSFL\n      ClearFlightSfl();\n\n     // Load Subfile FLTLISTSFL\n      LoadFlightSfl(p_Origin:p_Destination:p_SeatCatg);\n\n     // Display subfile FLTLISTSFL\n      DisplayFlightSfl();\n\n     // Handle screen operations\n      Select;\n\n       // Exit out of screen\n        When Exit = *On Or Cancel = *On;\n          Cancel = *Off;\n          Reset SFLERROR;\n          v_OverlayInd = *Off;\n          Leave;\n\n       // Refresh screen\n        When Refresh = *On;\n          Refresh = *Off;\n          Reset FLTLISTCTL;\n\n       // Read Subfile FLTLISTSFL\n        Other;\n          ReadFlightSfl(p_NumOfPsngr:p_DepartureDate:p_SeatCatg);\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ClearFlightSfl\n // Description.......:  Sub Procedure to clear subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ClearFlightSfl;\n    FltSflClr = *On;\n    v_Rrn = 0;\n    Write FLTLISTCTL;\n    FltSflClr = *Off;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  LoadFlightSfl\n // Description.......: Procedure to Load subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc LoadFlightSfl;\n    Dcl-Pi LoadFlightSfl;\n      p_Origin Char(20);\n      p_Destination Char(20);\n      p_SeatCatg Char(1);\n    End-Pi;\n\n    DSRCORIGIN = p_Origin;\n    DSRCDEST   = p_Destination;\n\n   // position to\n    If DFLTPOSTO <> *Blanks;\n\n     // Fetching position to data from file FLIGHTPF and AIRMASTER\n      Exec Sql\n        Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n        FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n        AIR.AIRRATING,FLT.FLTID\n        Into :FLIGHTDS,:v_FlagFltId\n        FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n        ON FLT.AIRID = AIR.AIRID\n        Where (FLT.FLTID = :DFLTPOSTO Or AIR.AIRNAME = :DFLTPOSTO) And\n        (FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n        And FLT.FLTSTATUS = 'A');\n\n     // Successfull execution of sql query\n      If Sqlcod = 0;\n\n       // Assigning data from FLIGHTDS to Subfile Fields\n        DFLTID    = FLIGHTDS.v_FltId;\n        DAIRLINE  = FLIGHTDS.v_AirName;\n        DTOTALDUR = FLIGHTDS.v_TotDur;\n\n       // Validating data for subfile fields\n        If p_SeatCatg = 'B';\n          DPRICE = %Char(FLIGHTDS.v_BPrice);\n        ElseIf p_SeatCatg = 'P';\n          DPRICE = %Char(FLIGHTDS.v_PPrice);\n        ElseIf p_SeatCatg = 'E';\n          DPRICE = %Char(FLIGHTDS.v_EPrice);\n        EndIf;\n        DRATING = FLIGHTDS.v_Rating;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write FLTLISTSFL;\n      EndIf;\n\n     // Declare cursor to Fetch data from file FLIGHTPF and AIRMASTER\n      Exec Sql\n        Declare DataCursorPos Cursor For\n        Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n        FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n        AIR.AIRRATING\n        FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n        ON FLT.AIRID = AIR.AIRID\n        Where (FLT.FLTID != :v_FlagFltId) And\n        (FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n        And FLT.FLTSTATUS = 'A');\n\n     // Open cursor\n      Exec Sql\n        Open DataCursorPos;\n\n     // Fetching data from Cursor to FLIGHTDS\n      Exec Sql\n        Fetch From DataCursorPos Into :FlightDs;\n\n      Dow SQLCOD = 0;\n\n       // Assigning data to subfile fields from FLIGHTDS\n        DFLTID    = FLIGHTDS.v_FltId;\n        DAIRLINE  = FLIGHTDS.v_AirName;\n        DTOTALDUR = FLIGHTDS.v_TotDur;\n\n       // Validation for subfile field\n        If p_SeatCatg = 'B';\n          DPRICE = %Char(FLIGHTDS.v_BPrice);\n        ElseIf p_SeatCatg = 'P';\n          DPRICE = %Char(FLIGHTDS.v_PPrice);\n        ElseIf p_SeatCatg = 'E';\n          DPRICE = %Char(FLIGHTDS.v_EPrice);\n        EndIf;\n        DRATING = FLIGHTDS.v_Rating;\n        v_Rrn = v_Rrn + 1;\n\n       // Rrn cannot be greater than 9999\n        If v_Rrn > 9999;\n          Return;\n        EndIf;\n        Write FLTLISTSFL;\n\n       // Fetching next record from cursor\n        Exec Sql\n          Fetch Next From DataCursorPos Into :FlightDs;\n\n      Enddo;\n\n     // Close cursor\n      Exec Sql\n        Close DataCursorPos;\n\n      Return;\n    EndIf;\n\n   // Declare cursor to fetch data from file FLIGHTPF and AIRMASTER\n    Exec Sql\n      Declare DataCursor Cursor For\n      Select FLT.FLTID,AIR.AIRNAME,FLT.FLTTOTDUR,\n      FLT.FLTBPRICE,FLT.FLTPPRICE,FLT.FLTEPRICE,\n      AIR.AIRRATING\n      FROM FLIGHTPF As FLT JOIN AIRMASTER As AIR\n      ON FLT.AIRID = AIR.AIRID\n      Where FLT.FLTORIGIN = :p_Origin And FLT.FLTDEST = :p_Destination\n      And FLT.FLTSTATUS = 'A';\n\n   // Open cursor\n    Exec Sql\n      Open DataCursor;\n\n   // Fetch data from cursor to FLIGHTDS\n    Exec Sql\n      Fetch From DataCursor Into :FLIGHTDS;\n\n   // Fetching records till the end of files\n    Dow SQLCOD = 0;\n\n     // Assigning data to subfile fields from FLIGHTDS\n      DFLTID    = FLIGHTDS.v_FltId;\n      DAIRLINE  = FLIGHTDS.v_AirName;\n      DTOTALDUR = FLIGHTDS.v_TotDur;\n\n     // Validation  for Subfile fields\n      If p_SeatCatg = 'B';\n        DPRICE = %Char(FLIGHTDS.v_BPrice);\n      ElseIf p_SeatCatg = 'P';\n        DPRICE = %Char(FLIGHTDS.v_PPrice);\n      ElseIf p_SeatCatg = 'E';\n        DPRICE = %Char(FLIGHTDS.v_EPrice);\n      EndIf;\n      DRATING = FLIGHTDS.v_Rating;\n      v_Rrn = v_Rrn + 1;\n\n     // Rrn cannot be greater than 9999\n      If v_Rrn > 9999;\n        Leave;\n      EndIf;\n      Write FLTLISTSFL;\n\n     // Fetch next record from cursor\n      Exec Sql\n        Fetch Next From DataCursor Into :FLIGHTDS;\n    Enddo;\n\n   // CLose cursor\n    Exec Sql\n      Close DataCursor;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  DisplayFlightSfl\n // Description.......:  Sub Procedure to Display subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc DisplayFlightSfl;\n    v_OverlayInd = *On;\n    FltSflDsp = *On;\n    FltSflCtl = *On;\n    FltSflEnd = *On;\n\n   // Cannot display if Rrn < 1\n    If v_Rrn < 1;\n      FltSflDsp = *Off;\n      SFLERROR = 'Sorry, No Flights Are There As Per Your Requirement';\n    EndIf;\n    SflFtr = 'F3=Exit  F5=Refresh  F12=Cancel';\n    Write Header;\n    Write SFLFOOTER;\n    Exfmt FLTLISTCTL;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // SUb Procedure Name:  ReadFlightSfl\n // Description.......:  Sub Procedure to Read subfile FLTLISTSFL\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ReadFlightSfl;\n    Dcl-Pi ReadFlightSfl;\n      p_NumberOfPsngr Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg Char(1);\n    End-Pi;\n\n   // Cannot read empty subfile\n    Monitor;\n      Chain DFLTCHC FLTLISTSFL;\n      Readc FLTLISTSFL;\n\n     // Reading till end of subfile\n      Dow Not %EOF();\n\n       // Operations to perform\n        Select;\n\n       // View Flight\n        When DFLTCHC = 5;\n          Clear DFLTCHC;\n          ViewFlightProc(p_NumberOfPsngr:p_DepartureDate:p_SeatCatg);\n\n       // Clear DFLTCHC\n        Other;\n          Clear DFLTCHC;\n        Endsl;\n        Readc FLTLISTSFL;\n      Enddo;\n\n     // Error Handle\n      On-Error;\n        SFLERROR = 'Sorry, No Flights Are There As Per Your Requirement';\n    EndMon;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name:  ViewFlightProc\n // Description.......:  Sub Procedure to View Flight details\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ViewFlightProc;\n    Dcl-Pi ViewFlightProc;\n      p_NumberOfPsngr Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg Char(1);\n    End-Pi;\n\n   // Fetching data from file FLIGHTPF to screen VIEWFLIGHT\n    Chain DFLTID FLightPf;\n\n   // Fetching data from file AIRMASTER to screen VIEWFLIGHT\n    Chain AirId Airmaster;\n    DFLTHEADER = %Trim(AirName) + ' ' + FLTID;\n\n   // Display screen VIEWFLIGHT\n    Dow Exit = *Off Or Cancel = *Off;\n      DFLTAIRLIN = AIRNAME;\n\n     // Setting ticket price according to seat category\n      If p_SeatCatg = 'B';\n        DTKTPRICE = FLTBPRICE;\n      ElseIf p_SeatCatg = 'P';\n        DTKTPRICE = FLTPPRICE;\n      ElseIf p_SeatCatg = 'E';\n        DTKTPRICE = FLTEPRICE;\n      EndIf;\n\n      Write Header;\n      Exfmt VIEWFLIGHT;\n\n     // Handle Screen Operation for ViewFlight\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Book Tickets\n      When Confirm = *On;\n        Confirm = *Off;\n        BookTicketProc(DFLTID:p_NumberOfPsngr:p_DepartureDate:p_SeatCatg:\n        DTKTPRICE);\n      Endsl;\n    Enddo;\n  End-Proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: BookTicket\n // Description.......: Procedure to handle ticket booking\n //------------------------------------------------------------------------------------------\n  Dcl-Proc BookTicketProc;\n    Dcl-Pi BookTicketProc;\n      p_FltId         Char(5);\n      p_NumPsngr      Packed(2);\n      p_DepartureDate Date;\n      p_SeatCatg      Char(1);\n      p_SeatPrice     Packed(6);\n    End-Pi;\n\n   // Local Variable\n    Dcl-S v_Counter        Packed(2);\n    Dcl-S v_AvailableSeats Packed(3);\n    Dcl-s v_TotalSeats     Packed(3);\n    Dcl-S v_IdType         Char(1);\n    Dcl-S v_AirlineId      Char(5);\n    Dcl-S v_DepTime        Time;\n    Dcl-S v_BkDate         Date;\n\n\n    v_IdType = 'B';\n\n   // Incremnting Booking Id\n    BKID     = AutoInc(v_IdType);\n    FLTID    = p_FltId;\n    DDEPDATE = p_DepartureDate;\n\n   // Fetching Flight Data from file FLIGHTPF\n    Exec Sql\n      Select FLTORIGIN,FLTDEST,FLTDEPTIME,AIRID\n      Into :FLTORIGIN,:FLTDEST,:FLTDEPTIME,:v_AirlineId\n      From FlightPf Where FLTID = :p_FLtId;\n\n   // Fetching Airline name from file AIRMASTER\n    Exec Sql\n      Select AIRNAME Into :AIRNAME\n      From Airmaster Where AIRID = :v_AirlineId;\n\n    v_BkDate = %Date();\n\n   // Inserting booking data into file BOOKINGPF\n    Exec Sql\n      Insert Into Bookingpf (BKID,USRID,FLTID,TOTTKT,BKSEATCAT,\n      BKPRICE,BKDATE,BKDEPDATE,BKDEPTIME,BKSTATUS,BKREMARK)\n      Values (:BKID,:v_CustomerId,:p_FltId,:p_NumPsngr,:p_SeatCatg,\n      (:p_NumPsngr * :p_SeatPrice),:v_BkDate,:p_DepartureDate,\n      :FLTDEPTIME,'U','Upcoming');\n\n    Exec Sql\n      Commit;\n\n   // Fetching Departure Time from file BOOKINGPF\n    Exec Sql\n        Select BKDEPTIME Into :v_DepTime\n        From Dheeraj/BookingPf Where BKID = :BKID;\n\n    v_Counter = 1;\n\n   // Booking tickets\n    Dow v_Counter <= p_NumPsngr;\n      v_IdType = 'T';\n\n     // Incrementing Ticket Id\n      TKTID    = AutoInc(v_IdType);\n\n     // Fetching number of seats in flight according to seat category from file FLIGHTPF\n      If p_SeatCatg = 'B';\n\n       // Fetching number of business class seats\n        Exec Sql\n          Select FLTBCLASS Into :v_TotalSeats\n          From FLIGHTPF Where FLTID = :p_FltId;\n      ElseIf p_SeatCatg = 'P';\n\n         // Fetching number of premium class seats\n          Exec Sql\n            Select FLTPCLASS Into :v_TotalSeats\n            From FLIGHTPF Where FLTID = :p_FltId;\n      ElseIf p_SeatCatg = 'E';\n\n         // Fetching number of economy class seats\n          Exec Sql\n            Select FLTECLASS Into :v_TotalSeats\n            From FLIGHTPF Where FLTID = :p_FltId;\n      EndIf;\n\n     // Calculating total seats available in flight\n      v_AvailableSeats = SeatCnt(p_FltId:p_DepartureDate:p_SeatCatg);\n      DAVAILSEAT = v_TotalSeats - v_AvailableSeats;\n      DPSGHEADER = 'Passenger ' + %Char(v_Counter);\n\n     // Display screen BOOKTICKET\n      Write Header;\n      Exfmt BOOKTICKET;\n\n     // Handle screen operations\n      Select;\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        If v_IndTktBooked = *Off;\n          Exec Sql\n            Delete From DHEERAJ/BOOKINGPF\n            Where BKID = :BKID;\n          Leave;\n        EndIf;\n        v_Counter -= 1;\n        Exec Sql\n          Update DHEERAJ/BOOKINGPF Set TOTTKT = :v_Counter,\n          BKPRICE = (:v_Counter * :p_SeatPrice)\n          Where BKID = :BKID;\n        Exec Sql Commit;\n        Leave;\n\n     // Prompt for passenger gender\n      When FLD = 'DPSGGENDER' And Prompt = *On;\n        Prompt = *Off;\n        v_Key1 = 'GENDER';\n        v_Key2 = 'GENDER';\n        v_PHeader = 'Select Gender';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DPSGGENDER = #Output3.v_KeyDesc;\n\n     // Booking ticket if validation passes\n      When Confirm = *On and v_FlagError = *Off;\n        Confirm = *Off;\n        v_Flagerror = *On;\n        v_IdType = 'T';\n        TKTID = AutoInc(v_IdType);\n\n       // Generate seat number\n        TKSEATNUM = GnrtSeat(p_FltId:p_SeatCatg:v_AvailableSeats);\n\n       // incrementing passenger id if it is empty\n        If v_PassengerId = *Blanks;\n          v_IdType = 'P';\n          v_PassengerId = AutoInc(v_IdType);\n\n         // Inserting passenger info in file PSNGRPF\n          Exec Sql\n            Insert Into PsngrPf (PSGID,USRID,PSGNAME,PSGGENDER\n            ,PSGAGE)\n            Values (:v_PassengerId, :v_CustomerId, :DPSGNAME,\n            :DPSGGENDER, :DPSGAGE);\n        EndIf;\n\n       // Inserting new ticket info in file TICKETPF\n        Exec Sql\n          Insert Into TicketPf (TKTID,BKID,PSGID,TKSEATNUM,\n          TKTPRICE,TKSTATUS,TKREMARK)\n          Values (:TKTID,:BKID,:v_PassengerId,:TKSEATNUM,\n          :p_SeatPrice,'U','Upcoming');\n\n       // Inserting seat number in file FLTSEATPF\n        If SQLCOD = 0;\n          DCUSTMRERR = 'Ticket Booked For Passenger ' + DPSGNAME;\n          Clear DPSGNAME;\n          Clear DPSGAGE;\n          Clear DPSGGENDER;\n          Clear TKTID;\n          Clear v_PassengerId;\n          v_Counter += 1;\n          Exec Sql\n            Insert Into FLTSEATPF (SEATNUMBER,FLTID,SEATCATG,TRAVELDATE,\n            TRAVELTIME)\n            Values (:TKSEATNUM,:p_FltId,:p_SeatCatg,:p_DepartureDate,\n            :v_DepTime);\n          Clear TKSEATNUM;\n          v_IndTktBooked = *On;\n        EndIf;\n\n     // Validation for passenger data\n      Other;\n\n       // reset indicator\n        ResetIndicator();\n\n       // validation\n        ValidateTicket();\n\n        If v_FlagError = *Off;\n          DCUSTMRERR = 'Press F6 to book ticket';\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;\n\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: AutoInc\n // Description.......: Sub Procedure to autoincrement booking id, ticket id,\n // and passenger id\n //------------------------------------------------------------------------------------------\n  Dcl-proc AutoInc;\n    Dcl-pi AutoInc Char(5);\n      p_IdType Char(1);\n    End-Pi;\n\n   // Local variable\n    Dcl-S v_IntId Packed(4);\n    Dcl-S v_Id    Char(5);\n\n   // Auto Increment Booking Id\n    If p_IdType = 'B';\n\n     // Fetching maximum id from file BOOKINGPF\n      Exec Sql\n        Select Max(BkId) Into :v_Id\n        From DHEERAJ/BOOKINGPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'B0001';\n        Return v_Id;\n\n     // Id Increment by 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'B' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n   // Auto Increment Ticket Id\n    ElseIf p_IdType = 'T';\n\n     // Fetching maximum id from file TICKETPF\n      Exec Sql\n        Select Max(TKTID) Into :v_Id\n        From DHEERAJ/TICKETPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'T0001';\n        Return v_Id;\n\n     // Increment Id by 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'T' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n   // Auto Increment Passenger Id\n    ElseIf p_IdType = 'P';\n\n     // Fetching maximum id from file PSNGRPF\n      Exec Sql\n        Select Max(PSGID) Into :v_Id\n        From DHEERAJ/PSNGRPF;\n\n     // Assigning Id\n      If v_Id = *Blanks ;\n        v_Id = 'P0001';\n        Return v_Id;\n\n     // Increment Id By 1\n      Else;\n        v_IntId = %Int(%Subst(v_Id:2:4)) + 1;\n        v_Id = 'P' + %editc(v_IntId:'X');\n        Return v_Id;\n      EndIf ;\n\n    EndIf;\n  End-proc;\n\n //------------------------------------------------------------------------------------------\n // Sub Procedure Name: ValidateTicket\n // Description.......: Procedure to handle validation for ticket\n //------------------------------------------------------------------------------------------\n  Dcl-Proc ValidateTicket;\n\n   // Passenger Name Cannot be blank\n    If DPSGNAME = *Blanks;\n      v_WrongPsgName = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Passenger Name: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Passenger gender cannot be blank\n    If DPSGGENDER = *Blanks;\n      v_WrongPsgGender = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Gender: Mandatory Field';\n      Return;\n    EndIf;\n\n   // Passenger age cannot be blank\n    If DPSGAGE = *Zeros;\n      v_WrongPsgAge = *On;\n      v_FlagError = *On;\n      DCUSTMRERR = 'Age: Mandatory Field';\n      Return;\n    EndIf;\n  End-Proc;","context":"flightpf.table:\nCreate Or Replace Table Flight_Table(\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Air_Id             For Column AIRID      Char(5) Not Null,\n Flt_Range          For Column FLTRANGE   Numeric(5) With Default 0,\n Flt_Fuel_Cap       For Column FLTFUELCAP Numeric(6) With Default 0,\n Flt_Model          For Column FLTMODEL   Char(20) With Default ' ',\n Flt_Origin         For Column FLTORIGIN  Char(15) With Default ' ',\n Flt_Destination    For Column FLTDEST    Char(15) With Default ' ',\n Flt_Arrival_Time   For Column FLTARRTIME Time,\n Flt_Departure_Time For Column FLTDEPTIME Time,\n Flt_End_Time       For Column FLTENDTIME Time,\n Flt_Total_Duration For Column FLTTOTDUR  Time,\n Flt_Cabin_Bag      For Column FLTCABBAG  Numeric(1) With Default 0,\n Flt_Main_Bag       For Column FLTMAINBAG Numeric(2) With Default 0,\n Flt_BusinessClass  For Column FLTBCLASS  Numeric(3) With Default 0,\n Flt_PremiumClass   For Column FLTPCLASS  Numeric(3) With Default 0,\n Flt_EconomyClass   For Column FLTECLASS  Numeric(3) With Default 0,\n Flt_BusinessPrice  For Column FLTBPRICE  Numeric(6) With Default 0,\n Flt_PremiumPrice   For Column FLTPPRICE  Numeric(6) With Default 0,\n Flt_EconomyPrice   For Column FLTEPRICE  Numeric(6) With Default 0,\n Flt_Status         For Column FLTSTATUS  Char(1) With Default 'A',\n Flt_Remark         For Column FLTREMARK  Char(15) With Default ' ',\nPRIMARY KEY (FLTID),\nFOREIGN KEY (AIRID) References AIRMASTER(AIRID)\n )\nRcdfmt FLIGHTPFR;\n\n\nRename table Flight_Table To System Name FLIGHTPF;\n\nLabel On Table Flight_Table Is 'Flight Details';\n\nLabel On Column Flight_Table(\n FLTID       Is 'Flight Id',\n AIRID       Is 'Airline Id',\n FLTRANGE    Is 'Flight Range',\n FLTFUELCAP  Is 'Fuel Capacity',\n FLTMODEL    Is 'Flight Model',\n FLTORIGIN   Is 'Flight Origin',\n FLTDEST     Is 'Flight Destination',\n FLTARRTIME  Is 'Flight Arrival Time',\n FLTDEPTIME  Is 'Flight Departure Time',\n FLTENDTIME  Is 'Flight End Time',\n FLTTOTDUR   Is 'Flight Total Duration',\n FLTCABBAG   Is 'Cabin Bag Weight',\n FLTMAINBAG  Is 'Main Bag Weight',\n FLTBCLASS   Is 'Total Business Class Seats',\n FLTPCLASS   Is 'Total Premium Class Seats',\n FLTECLASS   Is 'Total Economy Class Seats',\n FLTBPRICE   Is 'Price For Business Class',\n FLTPPRICE   Is 'Price For Premium Class',\n FLTEPRICE   Is 'Price For Economy Class',\n FLTSTATUS   Is 'Flight Status',\n FLTREMARK   Is 'Remark');\n\nLabel On Column Flight_Table(\n FLTID       Text Is 'Flight Id',\n AIRID       Text Is 'Airline Id',\n FLTRANGE    Text Is 'Flight Range',\n FLTFUELCAP  Text Is 'Fuel Capacity',\n FLTMODEL    Text Is 'Flight Model',\n FLTORIGIN   Text Is 'Flight Origin',\n FLTDEST     Text Is 'Flight Destination',\n FLTARRTIME  Text Is 'Flight Arrival Time',\n FLTDEPTIME  Text Is 'Flight Departure Time',\n FLTENDTIME  Text Is 'Flight End Time',\n FLTTOTDUR   Text Is 'Flight Total Duration',\n FLTCABBAG   Text Is 'Cabin Bag Weight',\n FLTMAINBAG  Text Is 'Main Bag Weight',\n FLTBCLASS   Text Is 'Total Business Class Seats',\n FLTPCLASS   Text Is 'Total Premium Class Seats',\n FLTECLASS   Text Is 'Total Economy Class Seats',\n FLTBPRICE   Text Is 'Price For Business Class',\n FLTPPRICE   Text Is 'Price For Premium Class',\n FLTEPRICE   Text Is 'Price For Economy Class',\n FLTSTATUS   Text Is 'Flight Status',\n FLTREMARK   Text Is 'Remark');\n\n\npsngrpf.table:\nCreate Or Replace Table Passenger_Table(\n Psg_Id             For Column PSGID      Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Psg_Name           For Column PSGNAME    Char(20) With Default ' ',\n Psg_Gender         For Column PSGGENDER  Char(1) With Default ' ',\n Psg_Age            For Column PSGAGE     Numeric(2) With Default 0,\nPRIMARY KEY (PSGID),\nFOREIGN KEY (USRID) References USRMASTER(USRID)\n )\nRcdfmt PSNGRPFR;\n\n\nRename table Passenger_Table To System Name PSNGRPF;\n\nLabel On Table Passenger_Table Is 'Passenger Details';\n\nLabel On Column Passenger_Table(\n PSGID       Is 'Passenger Id',\n USRID       Is 'User Id',\n PSGNAME     Is 'Name',\n PSGGENDER   Is 'Gender',\n PSGAGE      Is 'Age');\n\nLabel On Column Passenger_Table(\n PSGID       Text Is 'Passenger Id',\n USRID       Text Is 'User Id',\n PSGNAME     Text Is 'Name',\n PSGGENDER   Text Is 'Gender',\n PSGAGE      Text Is 'Age');\n\n\nbookingpf.table:\nCreate Or Replace Table Booking_Table(\n Bk_Id              For Column BKID       Char(5) Not Null,\n Usr_Id             For Column USRID      Char(5) Not Null,\n Flt_Id             For Column FLTID      Char(5) Not Null,\n Tot_Tickets        For Column TOTTKT     Numeric(2) Not Null With Default 0,\n Bk_SeatCat         For Column BKSEATCAT  Char(1) Not Null With Default ' ',\n Bk_Price           For Column BKPRICE    Numeric(6) Not Null With Default 0,\n Bk_Date            For Column BKDATE     Date,\n Bk_Dep_Date        For Column BKDEPDATE  Date,\n Bk_Dep_Time        For Column BKDEPTIME  Time,\n Bk_Status          For Column BKSTATUS   Char(1) With Default 'U',\n Bk_Remark          For Column BKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (BKID)\n )\nRcdfmt BOOKINGPFR;\n\n\nRename table Booking_Table To System Name BOOKINGPF;\n\nLabel On Table Booking_Table Is 'Booking Details';\n\nLabel On Column Booking_Table(\n BKID        Is 'Booking Id',\n USRID       Is 'User Id',\n FLTID       Is 'Flight Id',\n BKDATE      Is 'Booking Date',\n BKDEPDATE   Is 'Departure Date',\n BKDEPTIME   Is 'Departure Time',\n TOTTKT      Is 'Total Tickets',\n BKSEATCAT   Is 'Seat Category',\n BKPRICE     Is 'Booking Price',\n BKSTATUS    Is 'Booking Status',\n BKREMARK    Is 'Remark');\n\nLabel On Column Booking_Table(\n BKID        Text Is 'Booking Id',\n USRID       Text Is 'User Id',\n FLTID       Text Is 'Flight Id',\n BKDATE      Text Is 'Booking Date',\n BKDEPDATE   Text Is 'Departure Date',\n BKDEPTIME   Text Is 'Departure Time',\n TOTTKT      Text Is 'Total Tickets',\n BKSEATCAT   Text Is 'Seat Category',\n BKPRICE     Text Is 'Booking Price',\n BKSTATUS    Text Is 'Booking Status',\n BKREMARK    Text Is 'Remark');\n\n\nticketpf.table:\nCreate Or Replace Table Ticket_Table(\n Tkt_Id             For Column TKTID      Char(5) Not Null,\n Bk_Id              For Column BKID       Char(5) Not Null,\n Psg_Id             For Column PSGID      Char(5) Not Null,\n Tkt_Price          For Column TKTPRICE   Numeric(6) Not Null With Default 0,\n Tkt_Seat_Number    For Column TKSEATNUM  Char(10) With Default ' ',\n Tkt_Status         For Column TKSTATUS   Char(1) With Default 'U',\n Tkt_Remark         For Column TKREMARK   Char(15) With Default ' ',\nPRIMARY KEY (TKTID),\nFOREIGN KEY (PSGID) References PSNGRPF(PSGID),\nFOREIGN KEY (BKID)  References BOOKINGPF(BKID)\n )\nRcdfmt TICKETPFR;\n\n\nRename table Ticket_Table To System Name TICKETPF;\n\nLabel On Table Ticket_Table Is 'Ticket Details';\n\nLabel On Column Ticket_Table(\n TKTID       Is 'Ticket Id',\n BKID        Is 'Booking Id',\n PSGID       Is 'Passenger Id',\n TKTPRICE    Is 'Ticket Price',\n TKSEATNUM   Is 'Seat Number',\n TKSTATUS    Is 'Ticket Status',\n TKREMARK    Is 'Remark');\n\nLabel On Column Ticket_Table(\n TKTID       Text Is 'Ticket Id',\n BKID        Text Is 'Booking Id',\n PSGID       Text Is 'Passenger Id',\n TKTPRICE    Text Is 'Ticket Price',\n TKSEATNUM   Text Is 'Seat Number',\n TKSTATUS    Text Is 'Ticket Status',\n TKREMARK    Text Is 'Remark');\n\n\n \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\ncustmrfltm.sqlrpgle:\n  Dcl-F Flightpf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Airmaster  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F PsngrPf    Disk Usage(*Input:*Output) Keyed;\n  Dcl-F BookingPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F TicketPf   Disk Usage(*Input:*Output) Keyed;\n  Dcl-F FltSeatPf  Disk Usage(*Input:*Output) Keyed;\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n  Dcl-Ds FlightDs Qualified;\n    v_FltId   Char(5);\n    v_AirName Char(20);\n    v_TotDur  Time;\n    v_BPrice  Packed(6);\n    v_PPrice  Packed(6);\n    v_EPrice  Packed(6);\n    v_Rating  Packed(2:1);\n  End-Ds;\n  Dcl-S v_Rrn          Packed(4);\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_FlagFltId    Char(5);\n  Dcl-S v_PassengerId  Char(5);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n  Dcl-S v_FlagError    Ind Inz(*On);\n  Dcl-S v_IndTktBooked Ind Inz(*Off);","output":"Module Name: CUSTMRFLTM\n\nDescription: This fully-free SQLRPGLE module `CUSTMRFLTM` having one exported procedure `SearchFlight` provide a user interface and business logic for searching flights, viewing flight details, and booking tickets within an airline reservation system.  \n\n1. File Declarations:\n   - Physical files (`Flightpf`, `Airmaster`, `PsngrPf`, `BookingPf`, `TicketPf`, `FltSeatPf`) are declared to handle various data for flights, bookings, passengers, and tickets.\n\n   - A display file (`Customerd`) is declared for user interaction.\n\n2. Data Structure Declarations:\n\n   - Indicator Data Structure (`#IndicatorDs`): It holds flags that represent different UI indicators such as function keys (`Exit`, `Prompt`, `Refresh`, etc.) and field indicators (`v_WrongOrigin`, `v_WrongDest`, etc.).\n   - `#Output3`: Stores the result from the `WindowPrompt` procedure (seemingly used for selecting cities for origin and destination).\n   - `FlightDs`: Holds details about a flight (e.g., flight ID, airliner name, total duration, base price, etc.).\n\n3. Procedure: `SearchFlight`:\n   - This exported procedure handles the search functionality for flights, where the user inputs the origin, destination, date, and number of passengers.  \n   - It uses a loop (`Dow`) to continuously process screen operations (`Exfmt SEARCHFLT` for displaying the screen and handling input).\n\n     - Key Operations:\n       - Prompt for Origin/Destination: When prompted by the user, a search window is invoked to select an airport or city.\n       - Validate Inputs: Ensures all necessary fields are filled and correctly formatted.\n       - Subfile for Search Results: Displays available flights based on the search criteria.\n\nObservations and Points to Improve or Check:\n1. Screen Logic: The program uses the `Exit`, `Cancel`, `Refresh`, and `Prompt` flags to control the flow of user interactions. This makes the screen quite interactive.\n2. Data Validation: The program checks the users input and uses a validation procedure (`ValidateSearch`) to ensure correctness before proceeding to show the flight search results.\n3. Subfile Management: The search results are displayed in a subfile (`FltSubfile`), which would require additional logic elsewhere in the program to handle the actual data and UI rendering.\n\nPotential Enhancements:\n- Error Handling: The `v_FlagError` is used for flagging any input errors, but it might be useful to add more detailed error messages for users.\n- Performance Optimization: If this program grows, it may need optimization around how data is queried or managed in the physical files (especially considering multiple file accesses like `Flightpf`, `Airmaster`, etc.).\n\n Here's a summary and brief explanation of each of the major subprocedures:\n\n1. `ValidateSearch` \n   - Purpose: Validates the flight search data.\n\n   - Checks:\n     - Ensures origin and destination cities are not blank and are not the same.\n     - Validates the departure date is not in the past and is not blank.\n     - Ensures the number of passengers and seat category are not zero or blank.\n     - Error Handling: If any validation fails, it sets error flags and stores error messages.\n\n2. `ResetIndicator`\n\n      - Purpose: Resets all error flags and clears error messages.\n \n      - Operations: Turns off error flags and clears any error messages stored in `DCUSTMRERR`.\n\n3. `FltSubfile`\n\n    - Purpose: Manages the subfile `FLTLISTSFL`, which contains available flights based on search criteria.\n\n    - Operations:\n      - Clears the subfile, loads the flight data from a database, and displays it.\n      - Handles operations like refreshing the subfile and reading selected flight details.\n      - Uses a cursor to fetch data from the `FLIGHTPF` and `AIRMASTER` files.\n\n4. `ClearFlightSfl`\n\n     - Purpose: Clears the subfile FLTLISTSFL.\n     - Operations: Clears flags and resets the record number (`RRN`).\n\n5. `LoadFlightSfl`\n\n      - Purpose: Loads the flight details into the subfile `FLTLISTSFL`.\n      - Operations:\n        - Fetches data from the `FLIGHTPF` and `AIRMASTER` files based on the origin, destination, and seat category.\n         - Uses SQL queries to fetch flight details and display them in the subfile.\n         - Handles seat categories and assigns seat prices based on the category (business, premium, or economy).\n\n6. `DisplayFlightSfl`\n\n     - Purpose: Displays the subfile `FLTLISTSFL`.\n      - Operations:\n       - Checks if the subfile contains any data.\n       - Displays the subfile and handles screen options like refreshing or exiting.\n       - Writes footer and header for the subfile display.\n\n7. `ReadFlightSfl`\n\n    - Purpose: Reads the selected flight details from the subfile.\n     - Operations:\n       - Handles selection for viewing flight details or other operations.\n       - If a flight is selected (via the `DFLTCHC` field), it proceeds to display detailed information for that flight.\n\n8. `ViewFlightProc`\n\n     - Purpose: Displays detailed information about a selected flight.\n     - Operations:\n       - Fetches details about the flight and airline from the database.\n       - Handles screen display and input for passenger information (e.g., gender, seat selection).\n       - Allows booking tickets after viewing flight details.\n\n9. `BookTicketProc`\n\n      - Purpose: Handles the process of booking a ticket.\n      - Operations:\n        - Fetches flight and airline data.\n        - Inserts booking information into the `BOOKINGPF` file.\n        - Manages ticket booking for individual passengers.\n        - Increments the ticket ID and updates seat availability in the `FLTSEATPF` file.\n\n10. `AutoInc`\n\n     - Purpose: Generates auto-incremented IDs for bookings, tickets, and passengers.\n     - Operations:\n        - Fetches the maximum ID from the relevant file (e.g., `BOOKINGPF`, `TICKETPF`, `PSNGRPF`).\n        - Increments the ID by 1 and returns it in the desired format (e.g., 'B0001' for bookings).\n\n11. `ValidateTicket`\n\n     - Purpose: The primary purpose of this  procedure is to enforce business rules that require critical passenger details to be filled out correctly and completely. It ensures that the ticketing process only proceeds when all necessary information is present and valid, minimizing potential errors and ensuring data integrity.\n     - This procedure checks the passenger's name, gender, and age to ensure they are not blank or zero. Each of these fields is a mandatory field in the ticket booking process. \n\nModular and Maintainable:\n- Organized using *named procedures*\n- Clean separation of concerns (e.g., search vs booking)\n- Uses SQL for flexibility and modern data access\n\nLimitation:\n- Concurrency Issues\n  - No locking mechanisms to prevent race conditions:\n   - Multiple users booking at the same time could result in overbooking.\n   - There's no isolation or concurrency control on seat availability.\n\nKey Concepts in the Code:\n- Error Handling: Many of the procedures use flags (e.g., `v_FlagError`, `v_WrongOrigin`) to manage error conditions. When a validation fails, appropriate error messages are set in `DCUSTMRERR`, and the procedure returns early.\n- SQL Integration: SQL is used extensively to fetch and insert data from and to the database. Procedures like `LoadFlightSfl` and `BookTicketProc` leverage SQL for retrieving flight information and booking data.\n- Cursor Management: The code uses SQL cursors to fetch multiple records from the database (e.g., in `LoadFlightSfl` and `FltSubfile`).\n- Subfile Management: The `FLTLISTSFL` subfile is used to present a list of available flights. The code handles displaying, reading, and updating the subfile based on user input.\n- Ticket Booking Process: The `BookTicketProc` manages the entire booking lifecycle, including generating unique ticket IDs, updating seat availability, and inserting booking records into various files.\n- Seat Category Handling: The code differentiates between different seat categories (business, premium, and economy) and adjusts pricing accordingly.\n\nValidations List: \n - Here is a summary of the validation rules.\n\n1. Origin City Validation:\n   - Rule: The origin city (`DORIGIN`) must not be blank.\n   - Action: If the origin is blank, set `v_WrongOrigin = *On`, `v_FlagError = *On`, and return an error message `DCUSTMRERR = 'Origin: Mandatory Field'`.\n\n2. Destination City Validation:\n   - Rule: The destination city (`DDEST`) must not be blank.\n   - Action: If the destination is blank, set `v_WrongDest = *On`, `v_FlagError = *On`, and return an error message `DCUSTMRERR = 'Destination: Mandatory Field'`.\n\n   - Rule: The destination city should not be the same as the origin city.\n   - Action: If the destination is the same as the origin, set `v_WrongDest = *On`, `v_FlagError = *On`, and return an error message `DCUSTMRERR = 'Destination: Origin And Destination Cannot Be Same'`.\n\n3. Departure Date Validation:\n\n    -  Rule: The departure date (`DDATE`) must not be blank.\n    - Action: If the departure date is 0001-01-01 (a default blank date), set `v_WrongDate = *On`, `v_FlagError = *On`, and return an error message `DCUSTMRERR = 'Date: Mandatory Field'`.\n    - Rule: The departure date should not be a past date.\n    - Action: If the departure date is less than the current date (%date()), set `v_WrongDate = *On`, `v_FlagError = *On`, and return an error message `DCUSTMRERR = 'Date: Departure Date Should Be Upcoming Date'`.\n\n4. Number of Passengers Validation:\n\n   - Rule: The number of passengers (`DNUMPSNGR`) must not be zero.\n    - Action: If the number of passengers is zero, set `v_WrongNumPsngr = *On`, `v_FlagError = *On`, and return an error message `DCUSTMRERR = 'Number Of Passengers: Mandatory Field'`.\n\n5. Seat Category Validation:\n\n    -  Rule: The seat category (`DSEATCHC`) must not be zero.\n    - Action: If the seat category is zero, set `v_WrongSeatChc = *On`, `v_FlagError = *On`, and return an error message `DCUSTMRERR = 'Seat Category: Mandatory Field'`.\n\n6. Subfile Handling and Flight Listings:\n\n   - Rule: A subfile (`FLTLISTSFL`) of flights must be loaded and displayed based on the provided criteria (origin, destination, seat category).\n   - Action: Flights are fetched from the `FLIGHTPF` and `AIRMASTER` files using SQL queries and displayed in the subfile. Each flight can be selected and displayed with additional flight details.\n   - Rule: If no flights are available, display an error message: `SFLERROR = 'Sorry, No Flights Are There As Per Your Requirement'`.\n\n7. Flight Data Display:\n\n    - Rule: Flights are displayed on a screen (`VIEWFLIGHT`), showing details like airline, flight duration, and price based on seat category (Business, Premium, or Economy).\n8. Ticket Booking Validation:\n    -  Rule: When booking a ticket, the following are checked:\n    -  Validating if the passenger information (name, gender, age) is provided.\n    - Validating seat availability based on the selected flight, departure date, and seat category.\n    - Action: After successful validation, a ticket is booked and relevant records are inserted into `BOOKINGPF`, `PSNGRPF`, `TICKETPF`, and `FLTSEATPF` files. The process includes handling ticket IDs, seat numbers, and confirming booking details.\n\n9. Auto-Incrementing IDs:\n\n   - Rule: Automatically increment booking ID, ticket ID, and passenger ID.\n   - Action: The AutoInc procedure ensures that each new booking, ticket, and passenger gets a unique ID, based on the maximum current ID in the respective file.\n\n10. Error Handling:\n    - Rule: If any errors occur during the ticket booking process or while reading the subfile, the system handles them by displaying appropriate error messages and returning to the user interface.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CUSTMRFLTM/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"module","depth":"how"}}
{"id":"CUSTMRFLTM_SearchFlight_sum","input_data":"  Dcl-Proc SearchFlight Export;\n    Dcl-Pi SearchFlight;\n      p_UserId Char(5);\n      p_UserName Char(20);\n    End-Pi;\n    Reset SEARCHFLT;\n    UserFld = p_UserName;\n    v_CustomerId = p_UserId;\n\n   // Display screen SEARCHFLT\n    Dow Exit = *Off Or Cancel = *Off;\n      Write Header;\n      Exfmt SEARCHFLT;\n\n     // Handle Screen Operations for SEARCHFLT\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Refresh screen\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset SEARCHFLT;\n\n     // Prompt for Origin City\n      When FLD = 'DORIGIN' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Origin';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DORIGIN = #Output3.v_KeyDesc;\n\n     // Prompt for destination city\n      When FLD = 'DDEST' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Destination';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DDEST = #Output3.v_KeyDesc;\n\n     // Validate the data on screen SEARCHFLT\n      Other;\n\n       // Reset Field and standalone Indicators\n        ResetIndicator();\n\n       // Validate data\n        ValidateSearch();\n\n       // Showing Search Results\n        If v_FlagError = *Off;\n\n         // Seat Category\n          If DSEATCHC = 1;\n            v_SeatCatg = 'B';\n          ElseIf DSEATCHC = 2;\n            v_SeatCatg = 'P';\n          ElseIf DSEATCHC = 3;\n            v_SeatCatg = 'E';\n          EndIf;\n\n         // Subfile for Search Results\n          FltSubfile(DORIGIN:DDEST:DDATE:DNUMPSNGR:v_SeatCatg);\n          Reset SEARCHFLT;\n          v_FlagError = *On;\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\ncustmrfltm.sqlrpgle:\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n  Dcl-S v_FlagError    Ind Inz(*On);","output":"This fully-free ILE RPG procedure `SearchFlight` allows users to search for available flights by entering details such as origin, destination, travel date, and passengers.  It drives the event loop for displaying  the `SEARCHFLT` screen.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CUSTMRFLTM_SearchFlight/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"CUSTMRFLTM_SearchFlight_api","input_data":"  Dcl-Proc SearchFlight Export;\n    Dcl-Pi SearchFlight;\n      p_UserId Char(5);\n      p_UserName Char(20);\n    End-Pi;\n    Reset SEARCHFLT;\n    UserFld = p_UserName;\n    v_CustomerId = p_UserId;\n\n   // Display screen SEARCHFLT\n    Dow Exit = *Off Or Cancel = *Off;\n      Write Header;\n      Exfmt SEARCHFLT;\n\n     // Handle Screen Operations for SEARCHFLT\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Refresh screen\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset SEARCHFLT;\n\n     // Prompt for Origin City\n      When FLD = 'DORIGIN' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Origin';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DORIGIN = #Output3.v_KeyDesc;\n\n     // Prompt for destination city\n      When FLD = 'DDEST' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Destination';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DDEST = #Output3.v_KeyDesc;\n\n     // Validate the data on screen SEARCHFLT\n      Other;\n\n       // Reset Field and standalone Indicators\n        ResetIndicator();\n\n       // Validate data\n        ValidateSearch();\n\n       // Showing Search Results\n        If v_FlagError = *Off;\n\n         // Seat Category\n          If DSEATCHC = 1;\n            v_SeatCatg = 'B';\n          ElseIf DSEATCHC = 2;\n            v_SeatCatg = 'P';\n          ElseIf DSEATCHC = 3;\n            v_SeatCatg = 'E';\n          EndIf;\n\n         // Subfile for Search Results\n          FltSubfile(DORIGIN:DDEST:DDATE:DNUMPSNGR:v_SeatCatg);\n          Reset SEARCHFLT;\n          v_FlagError = *On;\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\ncustmrfltm.sqlrpgle:\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n  Dcl-S v_FlagError    Ind Inz(*On);","output":"## Purpose\n\nThis fully-free ILE RPG procedure `SearchFlight` enables users to search for available flights based on specific criteria.\n\n## Parameters\n\n### Input parameters\n\n- `p_UserId` - 5-character user ID passed by reference but not modified\n- `p_UserName` - 20-character username passed by reference but not modified\n\n## Global Variables\n\n- `UserFld` - User name.\n- `v_CustomerId` - User ID.\n- `DORIGIN` - Origin city.\n- `DDEST` - Destination city.\n- `DSEATCHC` - Seat category selection.\n- `v_SeatCatg` - Seat category (Business, Premium, or Economy).\n\n- Indicators from the `SEARCHFLT` screen\n    - `Cancel` - `*IN12` exits the search screen if `F12` is pressed.\n    - `Exit` - Leaves the procedure.\n    - `Refresh` - Resets the search screen.\n\n## Usage Example \n\n- Call the procedure `SearchFlight` with the parameters user ID and username:\n\n```rpgle\n        SearchFlight('12345' : 'JohnDoe');\n```\n\n### Dependencies\n\n- Below are the procedures referenced in the `SearchFlight`:\n\nThe search results are populated in a subfile `FltSubfile` after validating the users input.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CUSTMRFLTM_SearchFlight/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"CUSTMRFLTM_SearchFlight_how","input_data":"  Dcl-Proc SearchFlight Export;\n    Dcl-Pi SearchFlight;\n      p_UserId Char(5);\n      p_UserName Char(20);\n    End-Pi;\n    Reset SEARCHFLT;\n    UserFld = p_UserName;\n    v_CustomerId = p_UserId;\n\n   // Display screen SEARCHFLT\n    Dow Exit = *Off Or Cancel = *Off;\n      Write Header;\n      Exfmt SEARCHFLT;\n\n     // Handle Screen Operations for SEARCHFLT\n      Select;\n\n     // Exit out of screen\n      When Exit = *On Or Cancel = *On;\n        Cancel = *Off;\n        Leave;\n\n     // Refresh screen\n      When Refresh = *On;\n        Refresh = *Off;\n        Reset SEARCHFLT;\n\n     // Prompt for Origin City\n      When FLD = 'DORIGIN' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Origin';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DORIGIN = #Output3.v_KeyDesc;\n\n     // Prompt for destination city\n      When FLD = 'DDEST' And Prompt = *On;\n        v_Key1 = 'AIRPORT';\n        v_Key2 = 'CITY';\n        v_PHeader = 'Select Destination';\n        #Output3 = WindowPrompt(v_Key1:v_Key2:v_PHeader);\n        DDEST = #Output3.v_KeyDesc;\n\n     // Validate the data on screen SEARCHFLT\n      Other;\n\n       // Reset Field and standalone Indicators\n        ResetIndicator();\n\n       // Validate data\n        ValidateSearch();\n\n       // Showing Search Results\n        If v_FlagError = *Off;\n\n         // Seat Category\n          If DSEATCHC = 1;\n            v_SeatCatg = 'B';\n          ElseIf DSEATCHC = 2;\n            v_SeatCatg = 'P';\n          ElseIf DSEATCHC = 3;\n            v_SeatCatg = 'E';\n          EndIf;\n\n         // Subfile for Search Results\n          FltSubfile(DORIGIN:DDEST:DDATE:DNUMPSNGR:v_SeatCatg);\n          Reset SEARCHFLT;\n          v_FlagError = *On;\n        EndIf;\n      Endsl;\n    Enddo;\n  End-Proc;","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF05(05 'Refresh')\n     A                                      CF12(12 'Cancel')\n     A          R HEADER\n \n     A                                      OVERLAY\n     A                                  1 30'Flight Booking System'\n     A                                      COLOR(WHT)\n     A                                  1 66'Date:'\n     A                                      COLOR(WHT)\n     A                                  1 72DATE\n     A                                      EDTCDE(Y)\n     A                                      COLOR(WHT)\n     A                                  2 66'Time:'\n     A                                      COLOR(WHT)\n     A                                  2 72TIME\n     A                                      COLOR(WHT)\n     A                                  2 38'ARIANO'\n     A                                      COLOR(WHT)\n     A                                  1  2'User:'\n     A                                      COLOR(WHT)\n     A            USERFLD       15A  O  1  8COLOR(WHT)\n     A          R SFLFOOTER\ncustmrfltm.sqlrpgle:\n  Dcl-F Customerd Workstn Indds(#IndicatorDs) Sfile(FLTLISTSFL:v_Rrn);\n  Dcl-Ds #IndicatorDs;\n   // Function Key Indicators\n    Exit             Ind Pos(3);\n    Prompt           Ind Pos(04);\n    Refresh          Ind Pos(5);\n    Confirm          Ind Pos(06);\n    Cancel           Ind Pos(12);\n    // Subfile Indicator\n    FltSflDsp        Ind Pos(25);\n    FltSflCtl        Ind Pos(26);\n    FltSflClr        Ind Pos(27);\n    FltSflEnd        Ind Pos(28);\n    // Field Indicator\n    v_WrongOrigin    Ind Pos(40);\n    v_WrongDest      Ind Pos(41);\n    v_WrongDate      Ind Pos(42);\n    v_WrongNumPsngr  Ind Pos(43);\n    v_WrongSeatChc   Ind Pos(44);\n    v_WrongPsgName   Ind Pos(45);\n    v_WrongPsgGender Ind Pos(46);\n    v_WrongPsgAge    Ind Pos(47);\n    v_OverlayInd     Ind Pos(85);\n  End-Ds;\n  Dcl-Ds #Output3 Qualified;\n    v_KeyValue Char(10);\n    v_KeyDesc  Char(15);\n  End-Ds;\n  Dcl-S v_Key1         Char(10);\n  Dcl-S v_Key2         Char(10);\n  Dcl-S v_PHeader      Char(15);\n  Dcl-S v_CustomerId   Char(5);\n  Dcl-s v_SeatCatg     Char(1);\n  Dcl-S v_FlagError    Ind Inz(*On);","output":"This free-form RPGLE procedure `SearchFlight` displays a screen where a user can search for flights based on input criteria. The search is performed using the fields entered by the user, and the screen remains in a loop until the user presses an exit or cancel button.\n\nThe procedure takes two parameters as input\n\n- `p_UserId` which is a 5-character user ID passed by reference but not modified\n- `p_UserName` which is a 20-character username passed by reference but not modified \n\nThe `SearchFlight` procedure allows a user to search for available flights by entering details like:\n\n- Origin and Destination\n- Travel Date  \n- Number of Passengers  \n- Seat Category  \n\nThe procedure displays a form where users can input these details and fetch matching flights from the system.  \nInitializing the Search Screen\n\n- When the procedure starts, it resets the search form to clear any previous inputs. - Then, it enters a loop that continues until the user decides to exit or cancel.\n\n```rpgle\n        Dow Exit = *Off Or Cancel = *Off;\n         Write Header;\n         Exfmt SEARCHFLT;\n```\n\nWithin this loop:  \n   - The search form is displayed.  \n   - The program waits for the user to enter details or take an action\n\nHandling User Actions  \n   - Once the user interacts with the screen, the procedure determines what action to take.\n\nThe possible user actions would be:\nUser Chooses to Exit or Cancel  \n   - If the user presses Exit or Cancel, the procedure stops the loop and exits, returning control to the system.  \n\nUser Clicks Refresh  \n   - If the user presses Refresh, the form clears all fields so the user can enter new details.  \n\nUser Selects Origin or Destination  \n   - If the user clicks on the Origin or Destination field, a selection window appears.  \n   - The user can then choose an airport from the list.  \n\nUser Submits Search Request  \n   - The procedure first validates the input fields.\n   - If everything is correct, it determines the seat category based on user selection:\n      - `B` for Business Class  \n      - `P` for Premium Economy  \n      - `E` for Economy  \n\n```rpgle\n          If DSEATCHC = 1;\n            v_SeatCatg = 'B'; // Business Class\n          ElseIf DSEATCHC = 2;\n            v_SeatCatg = 'P'; // Premium Economy\n          ElseIf DSEATCHC = 3;\n            v_SeatCatg = 'E'; // Economy\n          EndIf;\n```\n\n- Once the seat category is set, the procedure retrieves available flights matching the criteria and updates the display.  \n\n```rpgle\n          FltSubfile(DORIGIN:DDEST:DDATE:DNUMPSNGR:v_SeatCatg);\n```\n\nLoop Execution and Resetting  \nOnce a search is performed:  \n\n- The results are displayed on the screen.  \n- The form is reset so the user can enter new details if needed.  \n- The loop continues until the user exits.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/CUSTMRFLTM_SearchFlight/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"MNGACCDTLM_sum","input_data":"**Free\n\n// Control Option\n/Title MngAccDtlm - Module to manage the customer bank accounts details\nCtl-Opt Option(*Nodebugio : *Srcstmt) NOMain;\n\n// File Declaration\nDcl-F MngDsbD WorkStn Indds(IndicatorDs) Sfile(AccSfl01   : #Rrn)\n                                         Sfile(AccDltSfl1 : #Rrn1);\n\n// Data Structure Declaration\n// Indicator data structure\nDcl-Ds IndicatorDs;\n   IndExit         Ind Pos(03);\n   IndPrompt       Ind Pos(04);\n   IndRefresh      Ind Pos(05);\n   IndConfirm      Ind Pos(07);\n   IndCancel       Ind Pos(12);\n   IndSflDsp       Ind Pos(21);\n   IndSflDspCtl    Ind Pos(22);\n   IndSflClr       Ind Pos(23);\n   IndSflEnd       Ind Pos(24);\n   IndOptRI        Ind Pos(25);\n   IndOptPC        Ind Pos(26);\n   IndBrCodeRI     Ind Pos(27);\n   IndAccOpnDtRI   Ind Pos(28);\n   IndAccStatusRI  Ind Pos(29);\n   IndChoiceRI     Ind Pos(30);\n   IndDltSflDsp    Ind Pos(42);\n   IndDltSflDspCtl Ind Pos(43);\n   IndDltSlfClr    Ind Pos(44);\n   IndDltSflEnd    Ind Pos(45);\n   IndFieldPR      Ind Pos(98);\nEnd-Ds;\n\n// Data structure to contain some fields of Screen\nDcl-Ds AccDetails;\n   S2BrCode    Char(11)   Inz;\n   S2AccOpnDt  Date       Inz;\n   S2IRate     Zoned(5:2) Inz;\n   S2AccStats  Char(10)   Inz;\nEnd-Ds;\n\n//Copy Book Declaration\n/Copy KartikCS/Qrpglesrc,Copy_Book\n\n// Variable Declaration\nDcl-S #Rrn         Zoned(4) Inz(*Zero);\nDcl-S Idx          Zoned(5) Inz(*Zero);\nDcl-S Idx1         Zoned(5) Inz(1);\nDcl-S PCustId      Char(10) Inz(*Zero);\nDcl-S ArrCustId    Char(20) Dim(9999);\nDcl-S Stmt         Char(200) Inz(*Blank);\nDcl-C QT           Const('''');\nDcl-S Deleteflag   Ind      Inz(*Off);\nDcl-S #Rrn1                 Like(#Rrn);\nDcl-C AlphaNum 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';\n\n// Main Code\nDcl-Proc CustAccSubFile Export;\n   IndExit = *Off;\n   Dow IndExit = *Off;\n      ClearSfl();\n      LoadSfl();\n      DisplaySfl();\n\n      Exec Sql\n          Set Option Commit = *None, DatFmt= *Iso;\n\n     // Control the flow of the program\n      Select;\n         When IndExit = *On Or IndCancel = *On;\n            IndCancel = *Off;\n            Clear MngErrMsg;\n            Clear MngMainScr;\n            IndOptRI = *Off;\n            IndOptPC = *Off;\n            Leave;\n\n         When IndRefresh = *On;\n            IndRefresh   = *Off;\n            Clear MngErrMsg;\n            Clear S1Option;\n            Clear S1Position;\n            IndOptRI = *Off;\n            IndOptPC = *Off;\n\n         Other;\n            OtherOption();\n      EndSl;\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ClearSfl                                                            //\n// Description   : Procedure to Clear Custome Representative Subfile                   //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ClearSfl;\n   IndSflClr = *On;\n   #Rrn      = 0;\n   Write ACCCTL01;\n   IndSflClr = *Off;\nEnd-proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: LoadSfl                                                             //\n// Description   : Procedure to Load Custome Representative Subfile                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc LoadSfl;\n   IndOptPC = *On;\n   Clear Stmt;\n   Stmt = 'Select A.CustId, A.AccType, A.AccStatus, C.CName ' +\n          'From Kartikcs/AccPf A Join Kartikcs/CustPf C On A.CustId = C.CId';\n   \n  // Load the subfile according to position to field\n   If S1Position <> *Blank;\n      Stmt = %Trim(Stmt) + ' Where A.CustId Like ' + QT + '%' + %Trim(S1Position) + '%' + QT +\n             ' Or C.CName Like ' + Qt + '%' + %Trim(S1Position) + '%' + QT +\n             ' Or A.AccStatus Like ' + QT + '%' + %Trim(S1Position) + '%' + QT;\n   EndIf;\n\n   Exec Sql\n      Prepare SqlStmt From :Stmt;\n\n   Exec Sql\n      Declare C01 Cursor for Sqlstmt;\n\n      Exec Sql\n         Open C01;\n\n      Exec Sql\n         Fetch from C01 Into :S1CustId, :S1AccType, :S1AccStats, :S1Cname2;\n\n      Dow SqlCode = 0;\n         #Rrn += 1;\n\n         If #Rrn > 9999;\n            Leave;\n         EndIF;\n\n         Write AccSfl01;\n\n         Exec Sql\n            Fetch From C01 Into :S1CustId, :S1AccType, :S1AccStats, :S1Cname2;\n      EndDo;\n\n      Exec Sql\n         Close C01;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplaySfl                                                          //\n// Description   : Procedure to Display Custome Subfile                                //\n//------------------------------------------------------------------------------------ //\nDcl-Proc DisplaySfl;\n   IndSflDsp    = *On;\n   IndSflDspCtl = *On;\n   IndSflEnd    = *On;\n\n   If #Rrn < 1;\n      IndSflDsp = *Off;\n   EndIf;\n\n   Clear S1Position;\n   MngHdr   = '        Work With Account Details        ';\n   MngFtrL2 = 'F3=Exit   F5=Refresh   F12=Cancel';\n   Write MngHeader;\n   Write MngFooter;\n   Exfmt AccCtl01;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: OtherOption                                                         //\n// Description   : Procedure to read sfl for other crud operation                      //\n//------------------------------------------------------------------------------------ //\nDcl-Proc OtherOption;\n   ReadC AccSfl01;\n   DoW S1Option <> 0;\n      Select;\n         When S1Option   = 2;\n            UpdateAcc();\n         When S1Option   = 4;\n            ArrCustId(Idx1) = S1CustId;\n            Idx1 += 1;\n            DeleteFlag   = *On;\n         When S1Option   = 5;\n            DisplayAcc();\n         Other;\n            Clear S1Option;\n      EndSl;\n      Clear S1Option;\n      ReadC AccSfl01;\n   EndDo;\n\n   If Deleteflag = *On;\n      DeleteAcc();\n   EndIf;\n\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: UpdateAcc                                                           //\n// Description   : Procedure to update account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc UpdateAcc;\n    \n  // Fetching data from PF\n   Exec Sql\n      Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n\n   If SqlCode = -305;\n   Exec Sql\n      Select A.CustId, A.AccNo, A.AccType, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2AccType, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n   EndIf;\n\n   MNGHDR   = '         Update Account Details         ';\n   MngFtrL2 = 'F3=Exit   F5=Refresh   F7=Confirm   F12=Cancel';\n\n   Dow IndExit = *Off Or IndCancel = *Off;\n      Write MngHeader;\n      Write MngFooter;\n      Exfmt AccOprtion;\n\n      Clear MngErrMsg;\n      ResetInd();\n\n     // Control the flow of the program  \n      Select;\n         When IndExit = *On Or IndCancel = *On;\n            IndCancel = *Off;\n            S1Option  = 0;\n            Clear MngErrMsg;\n            Leave;\n\n         When IndRefresh = *On;\n            IndRefresh   = *Off;\n            Clear MngErrMsg;\n            ResetInd();\n            \n           // Fetching value again from the PF\n            Exec Sql\n               Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n               Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n               From AccPf A\n               Join CustPf C\n               On A.CustId = C.CId;\n\n         When PrmtFld = 'S2ACCSTATS' And IndPrompt = *On;\n            IndPrompt = *Off;\n            GetAccStatus();\n\n         When IndConfirm = *On;\n            IndConfirm   = *Off;\n            AccValidation();\n            If MngErrMsg = *Blank;\n               UpdateRec();\n            EndIf;\n\n         Other;\n            AccValidation();\n      EndSl;\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ResetInd                                                            //\n// Description   : Procedure to turn off all field level indicators                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ResetInd;\n   IndOptRI        = *Off;\n   IndOptPC        = *Off;\n   IndBrCodeRI     = *Off;\n   IndAccOpnDtRI   = *Off;\n   IndAccStatusRI  = *Off;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: AccValidation                                                          //\n// Description   : Procedure to Validate Fields for Account Update Operation            //\n//------------------------------------------------------------------------------------ //\nDcl-Proc AccValidation;\n\n   // Validation for BranchCode\n   If S2BrCode    = *Blank;\n      IndBrCodeRI = *On;\n      MngErrMsg   = 'Branch Code field cannot be blank';\n      Return;\n   EndIf;\n   If %Check(AlphaNum : S2BrCode) <> 0;\n      IndBrCodeRI = *On;\n      MngErrMsg   = 'Branch Code field cannot contain special character';\n      Return;\n   EndIf;\n   // Validation for Account opening date\n   If %Char(S2AccOpnDt) = '0001-01-01';\n      IndAccOpnDtRI     = *On;\n      MngErrMsg         = 'Account Opening date cannot be blank';\n      Return;\n   EndIf;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: GetAccStatus                                                          //\n// Description   : Procedure to Select Account type                                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc GetAccStatus;\n   Dow IndCancel = *Off;\n      ExFmt AccStatsWn;\n\n      If IndCancel = *On;\n         IndCancel = *Off;\n         Clear W2Choice;\n         Clear W2ErrorMsg;\n         IndChoiceRI = *Off;\n         Leave;\n      Else;\n        // Update the account status\n         Select;\n            When W2Choice = '1';\n               S2AccStats = 'PENDING';\n               Clear W2ErrorMsg;\n            When W2Choice = '2';\n               S2AccStats  = 'APPROVED';\n               Clear W2ErrorMsg;\n             When W2Choice = '3';\n               S2AccStats  = 'Deny';\n               Clear W2ErrorMsg;\n            Other;\n              IndChoiceRI = *On;\n              W2ErrorMsg  = 'Invalid Opt';\n         EndSl;\n\n         If W2ErrorMsg  = *Blank;\n            IndChoiceRI = *Off;\n            Clear W2Choice;\n            Leave;\n         EndIf;\n\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name:  UpdateRec;                                                         //\n// Description   : Procedure to update account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc  UpdateRec;\n\n   If S2AccType  = 'SAVING';\n      S2Irate    = 2.70;\n   Else;\n      S2Irate  =   3.00;\n   EndIf;\n\n   Exec Sql\n      Update AccPf\n      Set BrCode=:S2BrCode, AccOpnDt=:S2AccOpnDt, IRate=:S2IRate, AccStatus=:S2AccStats\n      Where CustId = :S2CustId;\n   MngErrMsg  = 'Record Updated Successfully';\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplayCust                                                         //\n// Description   : Procedure to Display Custome Details                                //\n//------------------------------------------------------------------------------------ //\nDcl-Proc  DisplayAcc;\n   Exec Sql\n      Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n\n   MNGHDR     = '        Display Account Details        ';\n   MngFtrL2   = 'F3=Exit   F12=Cancel';\n   IndFieldPR = *On;\n\n   Dow IndExit = *Off Or IndCancel = *Off;\n      Write MngHeader;\n      Write MngFooter;\n      Exfmt AccOprtion;\n\n      If IndExit = *On Or IndCancel = *On;\n         IndCancel = *Off;\n         IndFieldPR = *Off;\n         Clear S1Option;\n         Leave;\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DeleteAcc                                                           //\n// Description   : Procedure to delete Account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc DeleteAcc;\n   Dow IndCancel = *Off;\n      ClearDltSfl();\n      LoadDltSfl();\n      DisplayDltSfl();\n\n      If IndCancel = *On;\n         IndCancel = *Off;\n         Reset Idx;\n         Reset Idx1;\n         Reset PCustId;\n         Clear ArrCustId;\n         DeleteFlag = *Off;\n         Clear S1Option;\n         Leave;\n      Else;\n         For Idx = 1 to Idx1-1;\n            PCustId = ArrCustId(Idx);\n\n            Exec Sql\n               Delete From LoginPf\n               Where UserId = :PCustId;\n\n            Exec Sql\n               Delete From AccPf\n               Where CustId = :PCustId;\n\n            Exec Sql\n               Delete From CustPF\n               Where CId = :PCustId;\n         EndFor;\n\n         MngErrMsg = 'Data deleted succuessfully';\n         Deleteflag = *Off;\n         Reset Idx;\n         Reset Idx1;\n         Reset PCustId;\n         Clear ArrCustId;\n         DeleteFlag = *Off;\n         Clear S1Option;\n         Leave;\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ClearDltSfl                                                         //\n// Description   : Procedure to Clear delete subfile                                   //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ClearDltSfl;\n   IndDltSlfClr = *On;\n   #Rrn1        = 0;\n   Write AccDltCtl1;\n   IndDltSlfClr = *Off;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: LoadDltSfl                                                         //\n// Description   : Procedure to load delete subfile                                   //\n//------------------------------------------------------------------------------------//\nDcl-Proc LoadDltSfl;\n\n   For Idx =1 to Idx1-1;\n      PCustId = ArrCustid(Idx);\n      Exec Sql\n         Select A.CustId, A.AccType, A.AccStatus, C.CName\n         Into :S3CustId, :S3AccType, :S3AccStats, :S3Cname1\n         From Kartikcs/AccPf A\n         Join Kartikcs/CustPf C\n         On A.CustId = C.CId\n         Where A.CustId = :PCustId;\n\n      #Rrn1 += 1;\n\n      If #Rrn1 >  9999;\n         Leave;\n      EndIf;\n\n      Write AccDltSfl1;\n   EndFor;\n\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplayDltSfl                                                       //\n// Description   : Procedure to display delete subfile                                 //\n//------------------------------------------------------------------------------------ //\n\nDcl-Proc DisplayDltSfl;\n   IndDltSflDsp    = *On;\n   IndDltSflDspCtl = *On;\n   IndDltSflEnd    = *On;\n\n   If #Rrn1 < 1;\n      IndDltSflDsp = *Off;\n   EndIf;\n\n   MngHdr = '        Delete Account Details        ';\n   MngFtrL2 = 'F12= Cancel';\n   Write MngHeader;\n   Write MngFooter;\n   Exfmt AccDltCtl1;\nEnd-Proc;","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A          R MNGHEADER\n\n     A                                  1  3'User:'\n     A                                  1  9USER\n     A                                  1 32'Capital Trust Bank'\n     A                                      DSPATR(HI)\n     A                                  1 64'Date:'\n     A                                  2 64'Time:'\n     A                                  1 70DATE\n     A                                      EDTCDE(Y)\n     A                                  2 70TIME\n     A            MNGHDR        40A  O  2 21COLOR(YLW)\n     A                                  3  3'__________________________________-\n     A                                      ___________________________________-\n     A                                      ______'\n     A                                      COLOR(BLU)\n     A          R MNGFOOTER\nmngaccdtlm.sqlrpgle:\nDcl-C QT           Const('''');\nDcl-C AlphaNum 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';\nDcl-F MngDsbD WorkStn Indds(IndicatorDs) Sfile(AccSfl01   : #Rrn)\nDcl-Ds IndicatorDs;\n   IndExit         Ind Pos(03);\n   IndPrompt       Ind Pos(04);\n   IndRefresh      Ind Pos(05);\n   IndConfirm      Ind Pos(07);\n   IndCancel       Ind Pos(12);\n   IndSflDsp       Ind Pos(21);\n   IndSflDspCtl    Ind Pos(22);\n   IndSflClr       Ind Pos(23);\n   IndSflEnd       Ind Pos(24);\n   IndOptRI        Ind Pos(25);\n   IndOptPC        Ind Pos(26);\n   IndBrCodeRI     Ind Pos(27);\n   IndAccOpnDtRI   Ind Pos(28);\n   IndAccStatusRI  Ind Pos(29);\n   IndChoiceRI     Ind Pos(30);\n   IndDltSflDsp    Ind Pos(42);\n   IndDltSflDspCtl Ind Pos(43);\n   IndDltSlfClr    Ind Pos(44);\n   IndDltSflEnd    Ind Pos(45);\n   IndFieldPR      Ind Pos(98);\nEnd-Ds;\nDcl-Ds AccDetails;\n   S2BrCode    Char(11)   Inz;\n   S2AccOpnDt  Date       Inz;\n   S2IRate     Zoned(5:2) Inz;\n   S2AccStats  Char(10)   Inz;\nEnd-Ds;\nDcl-S #Rrn         Zoned(4) Inz(*Zero);\nDcl-S Idx          Zoned(5) Inz(*Zero);\nDcl-S Idx1         Zoned(5) Inz(1);\nDcl-S PCustId      Char(10) Inz(*Zero);\nDcl-S ArrCustId    Char(20) Dim(9999);\nDcl-S Stmt         Char(200) Inz(*Blank);\nDcl-S Deleteflag   Ind      Inz(*Off);\nDcl-S #Rrn1                 Like(#Rrn);","output":"This fully free RPGLE module `MngAccdtlm` has one exported procedure `CustAccSubFile` and is designed to manage bank customer account details via a 5250 interactive display screen. It supports viewing, updating, and deleting account records using subfiles.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/MNGACCDTLM/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"module","depth":"sum"}}
{"id":"MNGACCDTLM_api","input_data":"**Free\n\n// Control Option\n/Title MngAccDtlm - Module to manage the customer bank accounts details\nCtl-Opt Option(*Nodebugio : *Srcstmt) NOMain;\n\n// File Declaration\nDcl-F MngDsbD WorkStn Indds(IndicatorDs) Sfile(AccSfl01   : #Rrn)\n                                         Sfile(AccDltSfl1 : #Rrn1);\n\n// Data Structure Declaration\n// Indicator data structure\nDcl-Ds IndicatorDs;\n   IndExit         Ind Pos(03);\n   IndPrompt       Ind Pos(04);\n   IndRefresh      Ind Pos(05);\n   IndConfirm      Ind Pos(07);\n   IndCancel       Ind Pos(12);\n   IndSflDsp       Ind Pos(21);\n   IndSflDspCtl    Ind Pos(22);\n   IndSflClr       Ind Pos(23);\n   IndSflEnd       Ind Pos(24);\n   IndOptRI        Ind Pos(25);\n   IndOptPC        Ind Pos(26);\n   IndBrCodeRI     Ind Pos(27);\n   IndAccOpnDtRI   Ind Pos(28);\n   IndAccStatusRI  Ind Pos(29);\n   IndChoiceRI     Ind Pos(30);\n   IndDltSflDsp    Ind Pos(42);\n   IndDltSflDspCtl Ind Pos(43);\n   IndDltSlfClr    Ind Pos(44);\n   IndDltSflEnd    Ind Pos(45);\n   IndFieldPR      Ind Pos(98);\nEnd-Ds;\n\n// Data structure to contain some fields of Screen\nDcl-Ds AccDetails;\n   S2BrCode    Char(11)   Inz;\n   S2AccOpnDt  Date       Inz;\n   S2IRate     Zoned(5:2) Inz;\n   S2AccStats  Char(10)   Inz;\nEnd-Ds;\n\n//Copy Book Declaration\n/Copy KartikCS/Qrpglesrc,Copy_Book\n\n// Variable Declaration\nDcl-S #Rrn         Zoned(4) Inz(*Zero);\nDcl-S Idx          Zoned(5) Inz(*Zero);\nDcl-S Idx1         Zoned(5) Inz(1);\nDcl-S PCustId      Char(10) Inz(*Zero);\nDcl-S ArrCustId    Char(20) Dim(9999);\nDcl-S Stmt         Char(200) Inz(*Blank);\nDcl-C QT           Const('''');\nDcl-S Deleteflag   Ind      Inz(*Off);\nDcl-S #Rrn1                 Like(#Rrn);\nDcl-C AlphaNum 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';\n\n// Main Code\nDcl-Proc CustAccSubFile Export;\n   IndExit = *Off;\n   Dow IndExit = *Off;\n      ClearSfl();\n      LoadSfl();\n      DisplaySfl();\n\n      Exec Sql\n          Set Option Commit = *None, DatFmt= *Iso;\n\n     // Control the flow of the program\n      Select;\n         When IndExit = *On Or IndCancel = *On;\n            IndCancel = *Off;\n            Clear MngErrMsg;\n            Clear MngMainScr;\n            IndOptRI = *Off;\n            IndOptPC = *Off;\n            Leave;\n\n         When IndRefresh = *On;\n            IndRefresh   = *Off;\n            Clear MngErrMsg;\n            Clear S1Option;\n            Clear S1Position;\n            IndOptRI = *Off;\n            IndOptPC = *Off;\n\n         Other;\n            OtherOption();\n      EndSl;\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ClearSfl                                                            //\n// Description   : Procedure to Clear Custome Representative Subfile                   //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ClearSfl;\n   IndSflClr = *On;\n   #Rrn      = 0;\n   Write ACCCTL01;\n   IndSflClr = *Off;\nEnd-proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: LoadSfl                                                             //\n// Description   : Procedure to Load Custome Representative Subfile                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc LoadSfl;\n   IndOptPC = *On;\n   Clear Stmt;\n   Stmt = 'Select A.CustId, A.AccType, A.AccStatus, C.CName ' +\n          'From Kartikcs/AccPf A Join Kartikcs/CustPf C On A.CustId = C.CId';\n   \n  // Load the subfile according to position to field\n   If S1Position <> *Blank;\n      Stmt = %Trim(Stmt) + ' Where A.CustId Like ' + QT + '%' + %Trim(S1Position) + '%' + QT +\n             ' Or C.CName Like ' + Qt + '%' + %Trim(S1Position) + '%' + QT +\n             ' Or A.AccStatus Like ' + QT + '%' + %Trim(S1Position) + '%' + QT;\n   EndIf;\n\n   Exec Sql\n      Prepare SqlStmt From :Stmt;\n\n   Exec Sql\n      Declare C01 Cursor for Sqlstmt;\n\n      Exec Sql\n         Open C01;\n\n      Exec Sql\n         Fetch from C01 Into :S1CustId, :S1AccType, :S1AccStats, :S1Cname2;\n\n      Dow SqlCode = 0;\n         #Rrn += 1;\n\n         If #Rrn > 9999;\n            Leave;\n         EndIF;\n\n         Write AccSfl01;\n\n         Exec Sql\n            Fetch From C01 Into :S1CustId, :S1AccType, :S1AccStats, :S1Cname2;\n      EndDo;\n\n      Exec Sql\n         Close C01;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplaySfl                                                          //\n// Description   : Procedure to Display Custome Subfile                                //\n//------------------------------------------------------------------------------------ //\nDcl-Proc DisplaySfl;\n   IndSflDsp    = *On;\n   IndSflDspCtl = *On;\n   IndSflEnd    = *On;\n\n   If #Rrn < 1;\n      IndSflDsp = *Off;\n   EndIf;\n\n   Clear S1Position;\n   MngHdr   = '        Work With Account Details        ';\n   MngFtrL2 = 'F3=Exit   F5=Refresh   F12=Cancel';\n   Write MngHeader;\n   Write MngFooter;\n   Exfmt AccCtl01;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: OtherOption                                                         //\n// Description   : Procedure to read sfl for other crud operation                      //\n//------------------------------------------------------------------------------------ //\nDcl-Proc OtherOption;\n   ReadC AccSfl01;\n   DoW S1Option <> 0;\n      Select;\n         When S1Option   = 2;\n            UpdateAcc();\n         When S1Option   = 4;\n            ArrCustId(Idx1) = S1CustId;\n            Idx1 += 1;\n            DeleteFlag   = *On;\n         When S1Option   = 5;\n            DisplayAcc();\n         Other;\n            Clear S1Option;\n      EndSl;\n      Clear S1Option;\n      ReadC AccSfl01;\n   EndDo;\n\n   If Deleteflag = *On;\n      DeleteAcc();\n   EndIf;\n\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: UpdateAcc                                                           //\n// Description   : Procedure to update account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc UpdateAcc;\n    \n  // Fetching data from PF\n   Exec Sql\n      Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n\n   If SqlCode = -305;\n   Exec Sql\n      Select A.CustId, A.AccNo, A.AccType, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2AccType, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n   EndIf;\n\n   MNGHDR   = '         Update Account Details         ';\n   MngFtrL2 = 'F3=Exit   F5=Refresh   F7=Confirm   F12=Cancel';\n\n   Dow IndExit = *Off Or IndCancel = *Off;\n      Write MngHeader;\n      Write MngFooter;\n      Exfmt AccOprtion;\n\n      Clear MngErrMsg;\n      ResetInd();\n\n     // Control the flow of the program  \n      Select;\n         When IndExit = *On Or IndCancel = *On;\n            IndCancel = *Off;\n            S1Option  = 0;\n            Clear MngErrMsg;\n            Leave;\n\n         When IndRefresh = *On;\n            IndRefresh   = *Off;\n            Clear MngErrMsg;\n            ResetInd();\n            \n           // Fetching value again from the PF\n            Exec Sql\n               Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n               Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n               From AccPf A\n               Join CustPf C\n               On A.CustId = C.CId;\n\n         When PrmtFld = 'S2ACCSTATS' And IndPrompt = *On;\n            IndPrompt = *Off;\n            GetAccStatus();\n\n         When IndConfirm = *On;\n            IndConfirm   = *Off;\n            AccValidation();\n            If MngErrMsg = *Blank;\n               UpdateRec();\n            EndIf;\n\n         Other;\n            AccValidation();\n      EndSl;\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ResetInd                                                            //\n// Description   : Procedure to turn off all field level indicators                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ResetInd;\n   IndOptRI        = *Off;\n   IndOptPC        = *Off;\n   IndBrCodeRI     = *Off;\n   IndAccOpnDtRI   = *Off;\n   IndAccStatusRI  = *Off;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: AccValidation                                                          //\n// Description   : Procedure to Validate Fields for Account Update Operation            //\n//------------------------------------------------------------------------------------ //\nDcl-Proc AccValidation;\n\n   // Validation for BranchCode\n   If S2BrCode    = *Blank;\n      IndBrCodeRI = *On;\n      MngErrMsg   = 'Branch Code field cannot be blank';\n      Return;\n   EndIf;\n   If %Check(AlphaNum : S2BrCode) <> 0;\n      IndBrCodeRI = *On;\n      MngErrMsg   = 'Branch Code field cannot contain special character';\n      Return;\n   EndIf;\n   // Validation for Account opening date\n   If %Char(S2AccOpnDt) = '0001-01-01';\n      IndAccOpnDtRI     = *On;\n      MngErrMsg         = 'Account Opening date cannot be blank';\n      Return;\n   EndIf;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: GetAccStatus                                                          //\n// Description   : Procedure to Select Account type                                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc GetAccStatus;\n   Dow IndCancel = *Off;\n      ExFmt AccStatsWn;\n\n      If IndCancel = *On;\n         IndCancel = *Off;\n         Clear W2Choice;\n         Clear W2ErrorMsg;\n         IndChoiceRI = *Off;\n         Leave;\n      Else;\n        // Update the account status\n         Select;\n            When W2Choice = '1';\n               S2AccStats = 'PENDING';\n               Clear W2ErrorMsg;\n            When W2Choice = '2';\n               S2AccStats  = 'APPROVED';\n               Clear W2ErrorMsg;\n             When W2Choice = '3';\n               S2AccStats  = 'Deny';\n               Clear W2ErrorMsg;\n            Other;\n              IndChoiceRI = *On;\n              W2ErrorMsg  = 'Invalid Opt';\n         EndSl;\n\n         If W2ErrorMsg  = *Blank;\n            IndChoiceRI = *Off;\n            Clear W2Choice;\n            Leave;\n         EndIf;\n\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name:  UpdateRec;                                                         //\n// Description   : Procedure to update account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc  UpdateRec;\n\n   If S2AccType  = 'SAVING';\n      S2Irate    = 2.70;\n   Else;\n      S2Irate  =   3.00;\n   EndIf;\n\n   Exec Sql\n      Update AccPf\n      Set BrCode=:S2BrCode, AccOpnDt=:S2AccOpnDt, IRate=:S2IRate, AccStatus=:S2AccStats\n      Where CustId = :S2CustId;\n   MngErrMsg  = 'Record Updated Successfully';\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplayCust                                                         //\n// Description   : Procedure to Display Custome Details                                //\n//------------------------------------------------------------------------------------ //\nDcl-Proc  DisplayAcc;\n   Exec Sql\n      Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n\n   MNGHDR     = '        Display Account Details        ';\n   MngFtrL2   = 'F3=Exit   F12=Cancel';\n   IndFieldPR = *On;\n\n   Dow IndExit = *Off Or IndCancel = *Off;\n      Write MngHeader;\n      Write MngFooter;\n      Exfmt AccOprtion;\n\n      If IndExit = *On Or IndCancel = *On;\n         IndCancel = *Off;\n         IndFieldPR = *Off;\n         Clear S1Option;\n         Leave;\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DeleteAcc                                                           //\n// Description   : Procedure to delete Account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc DeleteAcc;\n   Dow IndCancel = *Off;\n      ClearDltSfl();\n      LoadDltSfl();\n      DisplayDltSfl();\n\n      If IndCancel = *On;\n         IndCancel = *Off;\n         Reset Idx;\n         Reset Idx1;\n         Reset PCustId;\n         Clear ArrCustId;\n         DeleteFlag = *Off;\n         Clear S1Option;\n         Leave;\n      Else;\n         For Idx = 1 to Idx1-1;\n            PCustId = ArrCustId(Idx);\n\n            Exec Sql\n               Delete From LoginPf\n               Where UserId = :PCustId;\n\n            Exec Sql\n               Delete From AccPf\n               Where CustId = :PCustId;\n\n            Exec Sql\n               Delete From CustPF\n               Where CId = :PCustId;\n         EndFor;\n\n         MngErrMsg = 'Data deleted succuessfully';\n         Deleteflag = *Off;\n         Reset Idx;\n         Reset Idx1;\n         Reset PCustId;\n         Clear ArrCustId;\n         DeleteFlag = *Off;\n         Clear S1Option;\n         Leave;\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ClearDltSfl                                                         //\n// Description   : Procedure to Clear delete subfile                                   //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ClearDltSfl;\n   IndDltSlfClr = *On;\n   #Rrn1        = 0;\n   Write AccDltCtl1;\n   IndDltSlfClr = *Off;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: LoadDltSfl                                                         //\n// Description   : Procedure to load delete subfile                                   //\n//------------------------------------------------------------------------------------//\nDcl-Proc LoadDltSfl;\n\n   For Idx =1 to Idx1-1;\n      PCustId = ArrCustid(Idx);\n      Exec Sql\n         Select A.CustId, A.AccType, A.AccStatus, C.CName\n         Into :S3CustId, :S3AccType, :S3AccStats, :S3Cname1\n         From Kartikcs/AccPf A\n         Join Kartikcs/CustPf C\n         On A.CustId = C.CId\n         Where A.CustId = :PCustId;\n\n      #Rrn1 += 1;\n\n      If #Rrn1 >  9999;\n         Leave;\n      EndIf;\n\n      Write AccDltSfl1;\n   EndFor;\n\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplayDltSfl                                                       //\n// Description   : Procedure to display delete subfile                                 //\n//------------------------------------------------------------------------------------ //\n\nDcl-Proc DisplayDltSfl;\n   IndDltSflDsp    = *On;\n   IndDltSflDspCtl = *On;\n   IndDltSflEnd    = *On;\n\n   If #Rrn1 < 1;\n      IndDltSflDsp = *Off;\n   EndIf;\n\n   MngHdr = '        Delete Account Details        ';\n   MngFtrL2 = 'F12= Cancel';\n   Write MngHeader;\n   Write MngFooter;\n   Exfmt AccDltCtl1;\nEnd-Proc;","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A          R MNGHEADER\n\n     A                                  1  3'User:'\n     A                                  1  9USER\n     A                                  1 32'Capital Trust Bank'\n     A                                      DSPATR(HI)\n     A                                  1 64'Date:'\n     A                                  2 64'Time:'\n     A                                  1 70DATE\n     A                                      EDTCDE(Y)\n     A                                  2 70TIME\n     A            MNGHDR        40A  O  2 21COLOR(YLW)\n     A                                  3  3'__________________________________-\n     A                                      ___________________________________-\n     A                                      ______'\n     A                                      COLOR(BLU)\n     A          R MNGFOOTER\nmngaccdtlm.sqlrpgle:\nDcl-C QT           Const('''');\nDcl-C AlphaNum 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';\nDcl-F MngDsbD WorkStn Indds(IndicatorDs) Sfile(AccSfl01   : #Rrn)\nDcl-Ds IndicatorDs;\n   IndExit         Ind Pos(03);\n   IndPrompt       Ind Pos(04);\n   IndRefresh      Ind Pos(05);\n   IndConfirm      Ind Pos(07);\n   IndCancel       Ind Pos(12);\n   IndSflDsp       Ind Pos(21);\n   IndSflDspCtl    Ind Pos(22);\n   IndSflClr       Ind Pos(23);\n   IndSflEnd       Ind Pos(24);\n   IndOptRI        Ind Pos(25);\n   IndOptPC        Ind Pos(26);\n   IndBrCodeRI     Ind Pos(27);\n   IndAccOpnDtRI   Ind Pos(28);\n   IndAccStatusRI  Ind Pos(29);\n   IndChoiceRI     Ind Pos(30);\n   IndDltSflDsp    Ind Pos(42);\n   IndDltSflDspCtl Ind Pos(43);\n   IndDltSlfClr    Ind Pos(44);\n   IndDltSflEnd    Ind Pos(45);\n   IndFieldPR      Ind Pos(98);\nEnd-Ds;\nDcl-Ds AccDetails;\n   S2BrCode    Char(11)   Inz;\n   S2AccOpnDt  Date       Inz;\n   S2IRate     Zoned(5:2) Inz;\n   S2AccStats  Char(10)   Inz;\nEnd-Ds;\nDcl-S #Rrn         Zoned(4) Inz(*Zero);\nDcl-S Idx          Zoned(5) Inz(*Zero);\nDcl-S Idx1         Zoned(5) Inz(1);\nDcl-S PCustId      Char(10) Inz(*Zero);\nDcl-S ArrCustId    Char(20) Dim(9999);\nDcl-S Stmt         Char(200) Inz(*Blank);\nDcl-S Deleteflag   Ind      Inz(*Off);\nDcl-S #Rrn1                 Like(#Rrn);","output":"#### Purpose\nThis fully free RPGLE module `MngAccdtlm` has one exported procedure `CustAccSubFile` and is to manage customer bank account details through an interactive 5250 display screen. It acts as a complete account management tool for users.\n\n#### Exported procedure `CustAccSubfile`\n\n##### Parameters\n- none\n\n##### Core Functionalities:\n1. View Account Details\n - Display a list of customer accounts using a subfile.\n - Search/filter records by customer ID, name, or account status.\n\n2. Update Account Information\n - Select an account and update fields like:\n   - Branch code\n   - Account opening date\n   - Account status\n - Includes field-level validation to ensure data accuracy.\n - Updates are applied directly to the database.\n\n3. Delete Accounts\n - Mark multiple records for deletion.\n - Confirm deletion via a separate subfile screen.\n - Deletes customer, account, and login details from the respective tables.\n\n4. Display Read-Only Details\n - View complete account and customer details without modifying them.\n\n##### Dependencies\nThe following objects must exists in the library list. \n- `CustPf` - Customer profile \n- `AccPf`  - Account profile \n- `LoginPf` - Login credentials \n- `MngDsbD` - Display file containing user interface for subfile screens `AccSfl01` and `AccDltSfl1`.\n\n##### Usage example\nManaging bank customer Accounts. User can refresh, view, update or delete customer account records.\n```rpgle\n        CustAccSubFile();\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/MNGACCDTLM/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"module","depth":"api"}}
{"id":"MNGACCDTLM_how","input_data":"**Free\n\n// Control Option\n/Title MngAccDtlm - Module to manage the customer bank accounts details\nCtl-Opt Option(*Nodebugio : *Srcstmt) NOMain;\n\n// File Declaration\nDcl-F MngDsbD WorkStn Indds(IndicatorDs) Sfile(AccSfl01   : #Rrn)\n                                         Sfile(AccDltSfl1 : #Rrn1);\n\n// Data Structure Declaration\n// Indicator data structure\nDcl-Ds IndicatorDs;\n   IndExit         Ind Pos(03);\n   IndPrompt       Ind Pos(04);\n   IndRefresh      Ind Pos(05);\n   IndConfirm      Ind Pos(07);\n   IndCancel       Ind Pos(12);\n   IndSflDsp       Ind Pos(21);\n   IndSflDspCtl    Ind Pos(22);\n   IndSflClr       Ind Pos(23);\n   IndSflEnd       Ind Pos(24);\n   IndOptRI        Ind Pos(25);\n   IndOptPC        Ind Pos(26);\n   IndBrCodeRI     Ind Pos(27);\n   IndAccOpnDtRI   Ind Pos(28);\n   IndAccStatusRI  Ind Pos(29);\n   IndChoiceRI     Ind Pos(30);\n   IndDltSflDsp    Ind Pos(42);\n   IndDltSflDspCtl Ind Pos(43);\n   IndDltSlfClr    Ind Pos(44);\n   IndDltSflEnd    Ind Pos(45);\n   IndFieldPR      Ind Pos(98);\nEnd-Ds;\n\n// Data structure to contain some fields of Screen\nDcl-Ds AccDetails;\n   S2BrCode    Char(11)   Inz;\n   S2AccOpnDt  Date       Inz;\n   S2IRate     Zoned(5:2) Inz;\n   S2AccStats  Char(10)   Inz;\nEnd-Ds;\n\n//Copy Book Declaration\n/Copy KartikCS/Qrpglesrc,Copy_Book\n\n// Variable Declaration\nDcl-S #Rrn         Zoned(4) Inz(*Zero);\nDcl-S Idx          Zoned(5) Inz(*Zero);\nDcl-S Idx1         Zoned(5) Inz(1);\nDcl-S PCustId      Char(10) Inz(*Zero);\nDcl-S ArrCustId    Char(20) Dim(9999);\nDcl-S Stmt         Char(200) Inz(*Blank);\nDcl-C QT           Const('''');\nDcl-S Deleteflag   Ind      Inz(*Off);\nDcl-S #Rrn1                 Like(#Rrn);\nDcl-C AlphaNum 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';\n\n// Main Code\nDcl-Proc CustAccSubFile Export;\n   IndExit = *Off;\n   Dow IndExit = *Off;\n      ClearSfl();\n      LoadSfl();\n      DisplaySfl();\n\n      Exec Sql\n          Set Option Commit = *None, DatFmt= *Iso;\n\n     // Control the flow of the program\n      Select;\n         When IndExit = *On Or IndCancel = *On;\n            IndCancel = *Off;\n            Clear MngErrMsg;\n            Clear MngMainScr;\n            IndOptRI = *Off;\n            IndOptPC = *Off;\n            Leave;\n\n         When IndRefresh = *On;\n            IndRefresh   = *Off;\n            Clear MngErrMsg;\n            Clear S1Option;\n            Clear S1Position;\n            IndOptRI = *Off;\n            IndOptPC = *Off;\n\n         Other;\n            OtherOption();\n      EndSl;\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ClearSfl                                                            //\n// Description   : Procedure to Clear Custome Representative Subfile                   //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ClearSfl;\n   IndSflClr = *On;\n   #Rrn      = 0;\n   Write ACCCTL01;\n   IndSflClr = *Off;\nEnd-proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: LoadSfl                                                             //\n// Description   : Procedure to Load Custome Representative Subfile                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc LoadSfl;\n   IndOptPC = *On;\n   Clear Stmt;\n   Stmt = 'Select A.CustId, A.AccType, A.AccStatus, C.CName ' +\n          'From Kartikcs/AccPf A Join Kartikcs/CustPf C On A.CustId = C.CId';\n   \n  // Load the subfile according to position to field\n   If S1Position <> *Blank;\n      Stmt = %Trim(Stmt) + ' Where A.CustId Like ' + QT + '%' + %Trim(S1Position) + '%' + QT +\n             ' Or C.CName Like ' + Qt + '%' + %Trim(S1Position) + '%' + QT +\n             ' Or A.AccStatus Like ' + QT + '%' + %Trim(S1Position) + '%' + QT;\n   EndIf;\n\n   Exec Sql\n      Prepare SqlStmt From :Stmt;\n\n   Exec Sql\n      Declare C01 Cursor for Sqlstmt;\n\n      Exec Sql\n         Open C01;\n\n      Exec Sql\n         Fetch from C01 Into :S1CustId, :S1AccType, :S1AccStats, :S1Cname2;\n\n      Dow SqlCode = 0;\n         #Rrn += 1;\n\n         If #Rrn > 9999;\n            Leave;\n         EndIF;\n\n         Write AccSfl01;\n\n         Exec Sql\n            Fetch From C01 Into :S1CustId, :S1AccType, :S1AccStats, :S1Cname2;\n      EndDo;\n\n      Exec Sql\n         Close C01;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplaySfl                                                          //\n// Description   : Procedure to Display Custome Subfile                                //\n//------------------------------------------------------------------------------------ //\nDcl-Proc DisplaySfl;\n   IndSflDsp    = *On;\n   IndSflDspCtl = *On;\n   IndSflEnd    = *On;\n\n   If #Rrn < 1;\n      IndSflDsp = *Off;\n   EndIf;\n\n   Clear S1Position;\n   MngHdr   = '        Work With Account Details        ';\n   MngFtrL2 = 'F3=Exit   F5=Refresh   F12=Cancel';\n   Write MngHeader;\n   Write MngFooter;\n   Exfmt AccCtl01;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: OtherOption                                                         //\n// Description   : Procedure to read sfl for other crud operation                      //\n//------------------------------------------------------------------------------------ //\nDcl-Proc OtherOption;\n   ReadC AccSfl01;\n   DoW S1Option <> 0;\n      Select;\n         When S1Option   = 2;\n            UpdateAcc();\n         When S1Option   = 4;\n            ArrCustId(Idx1) = S1CustId;\n            Idx1 += 1;\n            DeleteFlag   = *On;\n         When S1Option   = 5;\n            DisplayAcc();\n         Other;\n            Clear S1Option;\n      EndSl;\n      Clear S1Option;\n      ReadC AccSfl01;\n   EndDo;\n\n   If Deleteflag = *On;\n      DeleteAcc();\n   EndIf;\n\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: UpdateAcc                                                           //\n// Description   : Procedure to update account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc UpdateAcc;\n    \n  // Fetching data from PF\n   Exec Sql\n      Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n\n   If SqlCode = -305;\n   Exec Sql\n      Select A.CustId, A.AccNo, A.AccType, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2AccType, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n   EndIf;\n\n   MNGHDR   = '         Update Account Details         ';\n   MngFtrL2 = 'F3=Exit   F5=Refresh   F7=Confirm   F12=Cancel';\n\n   Dow IndExit = *Off Or IndCancel = *Off;\n      Write MngHeader;\n      Write MngFooter;\n      Exfmt AccOprtion;\n\n      Clear MngErrMsg;\n      ResetInd();\n\n     // Control the flow of the program  \n      Select;\n         When IndExit = *On Or IndCancel = *On;\n            IndCancel = *Off;\n            S1Option  = 0;\n            Clear MngErrMsg;\n            Leave;\n\n         When IndRefresh = *On;\n            IndRefresh   = *Off;\n            Clear MngErrMsg;\n            ResetInd();\n            \n           // Fetching value again from the PF\n            Exec Sql\n               Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n               Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n               From AccPf A\n               Join CustPf C\n               On A.CustId = C.CId;\n\n         When PrmtFld = 'S2ACCSTATS' And IndPrompt = *On;\n            IndPrompt = *Off;\n            GetAccStatus();\n\n         When IndConfirm = *On;\n            IndConfirm   = *Off;\n            AccValidation();\n            If MngErrMsg = *Blank;\n               UpdateRec();\n            EndIf;\n\n         Other;\n            AccValidation();\n      EndSl;\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ResetInd                                                            //\n// Description   : Procedure to turn off all field level indicators                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ResetInd;\n   IndOptRI        = *Off;\n   IndOptPC        = *Off;\n   IndBrCodeRI     = *Off;\n   IndAccOpnDtRI   = *Off;\n   IndAccStatusRI  = *Off;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: AccValidation                                                          //\n// Description   : Procedure to Validate Fields for Account Update Operation            //\n//------------------------------------------------------------------------------------ //\nDcl-Proc AccValidation;\n\n   // Validation for BranchCode\n   If S2BrCode    = *Blank;\n      IndBrCodeRI = *On;\n      MngErrMsg   = 'Branch Code field cannot be blank';\n      Return;\n   EndIf;\n   If %Check(AlphaNum : S2BrCode) <> 0;\n      IndBrCodeRI = *On;\n      MngErrMsg   = 'Branch Code field cannot contain special character';\n      Return;\n   EndIf;\n   // Validation for Account opening date\n   If %Char(S2AccOpnDt) = '0001-01-01';\n      IndAccOpnDtRI     = *On;\n      MngErrMsg         = 'Account Opening date cannot be blank';\n      Return;\n   EndIf;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: GetAccStatus                                                          //\n// Description   : Procedure to Select Account type                                    //\n//------------------------------------------------------------------------------------ //\nDcl-Proc GetAccStatus;\n   Dow IndCancel = *Off;\n      ExFmt AccStatsWn;\n\n      If IndCancel = *On;\n         IndCancel = *Off;\n         Clear W2Choice;\n         Clear W2ErrorMsg;\n         IndChoiceRI = *Off;\n         Leave;\n      Else;\n        // Update the account status\n         Select;\n            When W2Choice = '1';\n               S2AccStats = 'PENDING';\n               Clear W2ErrorMsg;\n            When W2Choice = '2';\n               S2AccStats  = 'APPROVED';\n               Clear W2ErrorMsg;\n             When W2Choice = '3';\n               S2AccStats  = 'Deny';\n               Clear W2ErrorMsg;\n            Other;\n              IndChoiceRI = *On;\n              W2ErrorMsg  = 'Invalid Opt';\n         EndSl;\n\n         If W2ErrorMsg  = *Blank;\n            IndChoiceRI = *Off;\n            Clear W2Choice;\n            Leave;\n         EndIf;\n\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name:  UpdateRec;                                                         //\n// Description   : Procedure to update account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc  UpdateRec;\n\n   If S2AccType  = 'SAVING';\n      S2Irate    = 2.70;\n   Else;\n      S2Irate  =   3.00;\n   EndIf;\n\n   Exec Sql\n      Update AccPf\n      Set BrCode=:S2BrCode, AccOpnDt=:S2AccOpnDt, IRate=:S2IRate, AccStatus=:S2AccStats\n      Where CustId = :S2CustId;\n   MngErrMsg  = 'Record Updated Successfully';\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplayCust                                                         //\n// Description   : Procedure to Display Custome Details                                //\n//------------------------------------------------------------------------------------ //\nDcl-Proc  DisplayAcc;\n   Exec Sql\n      Select A.CustId, A.AccNo, A.BrCode, A.AccType, A.AccOpnDt, A.AccStatus, C.CName\n      Into :S2CustId, :S2AccNo, :S2BrCode, :S2AccType, :S2AccOpnDt, :S2AccStats, :S2CName3\n      From AccPf A\n      Join CustPf C\n      On A.CustId = C.CId\n      Where A.CustId = :S1CustId;\n\n   MNGHDR     = '        Display Account Details        ';\n   MngFtrL2   = 'F3=Exit   F12=Cancel';\n   IndFieldPR = *On;\n\n   Dow IndExit = *Off Or IndCancel = *Off;\n      Write MngHeader;\n      Write MngFooter;\n      Exfmt AccOprtion;\n\n      If IndExit = *On Or IndCancel = *On;\n         IndCancel = *Off;\n         IndFieldPR = *Off;\n         Clear S1Option;\n         Leave;\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DeleteAcc                                                           //\n// Description   : Procedure to delete Account details                                 //\n//------------------------------------------------------------------------------------ //\nDcl-Proc DeleteAcc;\n   Dow IndCancel = *Off;\n      ClearDltSfl();\n      LoadDltSfl();\n      DisplayDltSfl();\n\n      If IndCancel = *On;\n         IndCancel = *Off;\n         Reset Idx;\n         Reset Idx1;\n         Reset PCustId;\n         Clear ArrCustId;\n         DeleteFlag = *Off;\n         Clear S1Option;\n         Leave;\n      Else;\n         For Idx = 1 to Idx1-1;\n            PCustId = ArrCustId(Idx);\n\n            Exec Sql\n               Delete From LoginPf\n               Where UserId = :PCustId;\n\n            Exec Sql\n               Delete From AccPf\n               Where CustId = :PCustId;\n\n            Exec Sql\n               Delete From CustPF\n               Where CId = :PCustId;\n         EndFor;\n\n         MngErrMsg = 'Data deleted succuessfully';\n         Deleteflag = *Off;\n         Reset Idx;\n         Reset Idx1;\n         Reset PCustId;\n         Clear ArrCustId;\n         DeleteFlag = *Off;\n         Clear S1Option;\n         Leave;\n      EndIf;\n\n   EndDo;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: ClearDltSfl                                                         //\n// Description   : Procedure to Clear delete subfile                                   //\n//------------------------------------------------------------------------------------ //\nDcl-Proc ClearDltSfl;\n   IndDltSlfClr = *On;\n   #Rrn1        = 0;\n   Write AccDltCtl1;\n   IndDltSlfClr = *Off;\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: LoadDltSfl                                                         //\n// Description   : Procedure to load delete subfile                                   //\n//------------------------------------------------------------------------------------//\nDcl-Proc LoadDltSfl;\n\n   For Idx =1 to Idx1-1;\n      PCustId = ArrCustid(Idx);\n      Exec Sql\n         Select A.CustId, A.AccType, A.AccStatus, C.CName\n         Into :S3CustId, :S3AccType, :S3AccStats, :S3Cname1\n         From Kartikcs/AccPf A\n         Join Kartikcs/CustPf C\n         On A.CustId = C.CId\n         Where A.CustId = :PCustId;\n\n      #Rrn1 += 1;\n\n      If #Rrn1 >  9999;\n         Leave;\n      EndIf;\n\n      Write AccDltSfl1;\n   EndFor;\n\nEnd-Proc;\n\n//------------------------------------------------------------------------------------ //\n// Procedure Name: DisplayDltSfl                                                       //\n// Description   : Procedure to display delete subfile                                 //\n//------------------------------------------------------------------------------------ //\n\nDcl-Proc DisplayDltSfl;\n   IndDltSflDsp    = *On;\n   IndDltSflDspCtl = *On;\n   IndDltSflEnd    = *On;\n\n   If #Rrn1 < 1;\n      IndDltSflDsp = *Off;\n   EndIf;\n\n   MngHdr = '        Delete Account Details        ';\n   MngFtrL2 = 'F12= Cancel';\n   Write MngHeader;\n   Write MngFooter;\n   Exfmt AccDltCtl1;\nEnd-Proc;","context":" \n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A          R MNGHEADER\n\n     A                                  1  3'User:'\n     A                                  1  9USER\n     A                                  1 32'Capital Trust Bank'\n     A                                      DSPATR(HI)\n     A                                  1 64'Date:'\n     A                                  2 64'Time:'\n     A                                  1 70DATE\n     A                                      EDTCDE(Y)\n     A                                  2 70TIME\n     A            MNGHDR        40A  O  2 21COLOR(YLW)\n     A                                  3  3'__________________________________-\n     A                                      ___________________________________-\n     A                                      ______'\n     A                                      COLOR(BLU)\n     A          R MNGFOOTER\nmngaccdtlm.sqlrpgle:\nDcl-C QT           Const('''');\nDcl-C AlphaNum 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';\nDcl-F MngDsbD WorkStn Indds(IndicatorDs) Sfile(AccSfl01   : #Rrn)\nDcl-Ds IndicatorDs;\n   IndExit         Ind Pos(03);\n   IndPrompt       Ind Pos(04);\n   IndRefresh      Ind Pos(05);\n   IndConfirm      Ind Pos(07);\n   IndCancel       Ind Pos(12);\n   IndSflDsp       Ind Pos(21);\n   IndSflDspCtl    Ind Pos(22);\n   IndSflClr       Ind Pos(23);\n   IndSflEnd       Ind Pos(24);\n   IndOptRI        Ind Pos(25);\n   IndOptPC        Ind Pos(26);\n   IndBrCodeRI     Ind Pos(27);\n   IndAccOpnDtRI   Ind Pos(28);\n   IndAccStatusRI  Ind Pos(29);\n   IndChoiceRI     Ind Pos(30);\n   IndDltSflDsp    Ind Pos(42);\n   IndDltSflDspCtl Ind Pos(43);\n   IndDltSlfClr    Ind Pos(44);\n   IndDltSflEnd    Ind Pos(45);\n   IndFieldPR      Ind Pos(98);\nEnd-Ds;\nDcl-Ds AccDetails;\n   S2BrCode    Char(11)   Inz;\n   S2AccOpnDt  Date       Inz;\n   S2IRate     Zoned(5:2) Inz;\n   S2AccStats  Char(10)   Inz;\nEnd-Ds;\nDcl-S #Rrn         Zoned(4) Inz(*Zero);\nDcl-S Idx          Zoned(5) Inz(*Zero);\nDcl-S Idx1         Zoned(5) Inz(1);\nDcl-S PCustId      Char(10) Inz(*Zero);\nDcl-S ArrCustId    Char(20) Dim(9999);\nDcl-S Stmt         Char(200) Inz(*Blank);\nDcl-S Deleteflag   Ind      Inz(*Off);\nDcl-S #Rrn1                 Like(#Rrn);","output":"Module Name - MngAccDtlm\nDescription - Module to manage the customer's bank account details\n\nPurpose: This RPGLE module `MngAccdtlm` has one exported procedure `CustAccSubFile` to Manage customer bank account details (view, update, delete).\n\n1. Setup (Start & Main Loop) \n- The `CustAccSubFile` procedure is the main driver.\n- It controls the flow using indicator flags (IndExit, IndRefresh, IndCancel, etc.).\n- Each action (like pressing F3, F5, choosing options 2/4/5) sets a flag.\n- The loop keeps running until IndExit = *On.\n\n2. Loading Data into Subfile\nProcedure: `LoadSfl`\n- Runs an *SQL SELECT* to fetch all accounts joined with customer names:\n```rpgle \n        Select A.CustId, A.AccType, A.AccStatus, C.CName\n         From AccPf A Join CustPf C ON A.CustId = C.CId\n```\n- If the user typed a *search term*, it filters the data using `LIKE`.\n- Each record is written to a subfile row using Write `AccSfl01`.\n\n3. Displaying the subfile \nProcedure: `DisplaySfl`\n- Turns on subfile display indicators:\n```rpgle \n        IndSflDsp = *On;\n        IndSflDspCtl = *On;\n```\n- Shows the subfile screen and waits for user input (`Exfmt AccCtl01`)\n- User can:\n  - Enter option (2, 4, 5) next to a record\n  - Press function keys (F3, F5, F12)\n\n4. Handling User Options (CRUD Actions)\nProcedure: `OtherOption`\n- Reads each selected row from the subfile.\n- Depending on the option:\n`2:` Calls `UpdateAcc`\n`4:` Marks for deletion and stores in an array (`ArrCustId`)\n`5:` Calls `DisplayAcc`\n\n4.1 Updating Account (`UpdateAcc`)\n- Retrieves current data from Database via SQL.\n- Displays update screen.\n- Waits for user input.\n- If `F7 = Confirm` is pressed:\n  - Validates inputs (`AccValidation`)\n  - Updates the record (`UpdateRec`)\n\n4.2 Viewing Account (`DisplayAcc`)\n- Same as update, but fields are read-only.\n- Uses indicator `IndFieldPR = *On` to protect fields.\n\n4.3 Deleting Account(s) (`DeleteAcc`)\n- Shows another subfile listing only the selected records.\n- On confirmation:\n  - Deletes from:\n    - LoginPf (user ID)\n    - AccPf (account)\n    - CustPf (customer)\n\n5. Refreshing or Exiting\n - `F5 = Refresh` clears filters and reloads.\n - `F3/F12` set `IndExit` or `IndCancel`, which ends the loop or resets the screen.\n\nValidations involved:\n - Below is summary table of validated fields.\n \n| Field         | Validation type            | validated in    | Message or Result                         |\n|---------------|----------------------------|-----------------|-------------------------------------------|\n| Branch code   | Required, Alphanumeric     | `AccValidation` | Error message and field indicator set     |\n| Acc open date | Required, Valid ISO Date   | `AccValidation` | Error message if blank                    |\n| Acc Status    | Must select 1, 2, or 3     | `GetAccStatus`  | Prompt window, mapped value assigned      |\n| Option Entry  | Must be 2, 4, or 5         | `OtherOption`   | Clears if invalid                         |\n| IRate         | Auto-set by type           | `UpdateRec`     | Business rule applied automatically       | \n\nAdditional Features:\n- User-friendly interface with function key support (F3, F5, F12, etc.)\n- Modular structure using procedures for maintainability\n- SQL used for efficient data retrieval and updates\n- Supports both full list and filtered searches\n\nTarget Users:\n This module is likely designed for bank employees, such as:\n- Account managers\n- Customer service representatives\n- Back-office staff handling account maintenance\n\nIn short, this module is a central interface for CRUD operations (Create, Read, Update, Delete) on customer account records, ensuring data consistency and ease of use via an RPGLE subfile-driven screen.\n\nConstraints:\n- Branch Code - Must not be blank, must be alphanumeric\n- Account opening date - Must not be blank (i.e., not default date)\n- Account status - Only values `1`, `2`, or `3` accepted\n- Subfile record limit - Maximum 9999 records \n- SQL Join - Requires matching `CustId` between account and customer database physical files \n- Deletion - Deletes across multiple related tables","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/MNGACCDTLM/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff","scope":"module","depth":"how"}}
{"id":"NEWCSTMRRG_DataPopulate_sum","input_data":"   Dcl-proc DataPopulate;\n\n     Exec sql call qcmdExc('CHGJOB CCSID(37)');\n\n    //Reset indicator subprocedure\n     ResetIndicator();\n     Clear NCERROR ;\n     Validation();\n\n     If NCERROR = *Blank And Insert = *On;\n        Exec Sql\n          Insert Into CstDtlPf  ( CSTID , CSTNAME , CSTSTATE , CSTGMAIL ,\n                             CSTADDRESS , CSTGENDER , CSTCITY ,\n                             CSTMOBILE , CSTCOUNTRY , CSTPINCODE )\n          Values ( :CNUSRID , :CNNAME , :CNSTATE , :CNGMAIL ,\n                :CNAddress , :CNGender , :CNCity , :CNMobile ,\n                :CNCountry , :CNPINCODE );\n\n        Exec sql\n          SELECT SYSTOOLS.BASE64ENCODE(:CNCPASS) into :Encrypt\n                 from SYSIBM.SYSDUMMY1  ;\n        Exec Sql\n          Insert Into LogInPf ( LOGINID , PASSWORD , SCURITYQUE ,\n                              SCURITYANS , ROLE )\n          Values ( :CNUSRID , :Encrypt , :SECQUE ,\n                      :CNSECURITY , 'customer' );\n\n        Insert = *Off;\n        Clear NEWCSTREG ;\n        NCERROR = 'Record Inserted Successfully' ;\n     EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F LoginPf   Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F CSTDTLPF  Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;\n  Dcl-S Id         Zoned(4);\n  Dcl-S Encrypt    Char(10);\n  Dcl-S Count      Zoned(5);","output":"This fully-free SQLRPGLE procedure `DataPopulate` validates customer details and inserts them into the database","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_DataPopulate/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"NEWCSTMRRG_DataPopulate_api","input_data":"   Dcl-proc DataPopulate;\n\n     Exec sql call qcmdExc('CHGJOB CCSID(37)');\n\n    //Reset indicator subprocedure\n     ResetIndicator();\n     Clear NCERROR ;\n     Validation();\n\n     If NCERROR = *Blank And Insert = *On;\n        Exec Sql\n          Insert Into CstDtlPf  ( CSTID , CSTNAME , CSTSTATE , CSTGMAIL ,\n                             CSTADDRESS , CSTGENDER , CSTCITY ,\n                             CSTMOBILE , CSTCOUNTRY , CSTPINCODE )\n          Values ( :CNUSRID , :CNNAME , :CNSTATE , :CNGMAIL ,\n                :CNAddress , :CNGender , :CNCity , :CNMobile ,\n                :CNCountry , :CNPINCODE );\n\n        Exec sql\n          SELECT SYSTOOLS.BASE64ENCODE(:CNCPASS) into :Encrypt\n                 from SYSIBM.SYSDUMMY1  ;\n        Exec Sql\n          Insert Into LogInPf ( LOGINID , PASSWORD , SCURITYQUE ,\n                              SCURITYANS , ROLE )\n          Values ( :CNUSRID , :Encrypt , :SECQUE ,\n                      :CNSECURITY , 'customer' );\n\n        Insert = *Off;\n        Clear NEWCSTREG ;\n        NCERROR = 'Record Inserted Successfully' ;\n     EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F LoginPf   Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F CSTDTLPF  Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;\n  Dcl-S Id         Zoned(4);\n  Dcl-S Encrypt    Char(10);\n  Dcl-S Count      Zoned(5);","output":"## Purpose\nThis fully-free SQLRPGLE procedure `DataPopulate` is responsible for inserting new customer records into the database. It validates customer details, encrypts the password, and stores the login credentials. If successful, it resets the input fields and displays a confirmation message.\n\n## Parameters\n\n### Input Parameters\n\n- `CNUSRID`  Customer ID\n- `CNNAME`  Customer Name\n- `CNSTATE`  State\n- `CNGMAIL`  Email Address\n- `CNAddress`  Address\n- `CNGender`  Gender\n- `CNCity`  City\n- `CNMobile`  Mobile Number\n- `CNCountry`  Country\n- `CNPINCODE`  PIN Code\n- `CNCPASS`  Password (to be encrypted)\n- `SECQUE`  Security Question\n- `CNSECURITY`  Security Answer\n\n### Output Parameters\n\n- `Encrypt`  Encrypted password (Base64 encoded)\n- `NCERROR`  Error or success message\n\n### Internal Flags & Controls\n\n- `Insert`  Flag indicating if data should be inserted\n- `NEWCSTREG`  Stores new customer registration details\n\n## Database Changes\n\n- Customer details are inserted into the `CstDtlPf` table.\n- Login credentials (encrypted password and security details) are stored in the `LogInPf` table.\n\n## Global Variables\n\n- `NCERROR`  Holds validation errors or success messages.\n- `Insert`  Controls whether customer data is inserted.\n- `NEWCSTREG`  Stores newly entered customer information before clearing.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_DataPopulate/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"NEWCSTMRRG_DataPopulate_how","input_data":"   Dcl-proc DataPopulate;\n\n     Exec sql call qcmdExc('CHGJOB CCSID(37)');\n\n    //Reset indicator subprocedure\n     ResetIndicator();\n     Clear NCERROR ;\n     Validation();\n\n     If NCERROR = *Blank And Insert = *On;\n        Exec Sql\n          Insert Into CstDtlPf  ( CSTID , CSTNAME , CSTSTATE , CSTGMAIL ,\n                             CSTADDRESS , CSTGENDER , CSTCITY ,\n                             CSTMOBILE , CSTCOUNTRY , CSTPINCODE )\n          Values ( :CNUSRID , :CNNAME , :CNSTATE , :CNGMAIL ,\n                :CNAddress , :CNGender , :CNCity , :CNMobile ,\n                :CNCountry , :CNPINCODE );\n\n        Exec sql\n          SELECT SYSTOOLS.BASE64ENCODE(:CNCPASS) into :Encrypt\n                 from SYSIBM.SYSDUMMY1  ;\n        Exec Sql\n          Insert Into LogInPf ( LOGINID , PASSWORD , SCURITYQUE ,\n                              SCURITYANS , ROLE )\n          Values ( :CNUSRID , :Encrypt , :SECQUE ,\n                      :CNSECURITY , 'customer' );\n\n        Insert = *Off;\n        Clear NEWCSTREG ;\n        NCERROR = 'Record Inserted Successfully' ;\n     EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F LoginPf   Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F CSTDTLPF  Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;\n  Dcl-S Id         Zoned(4);\n  Dcl-S Encrypt    Char(10);\n  Dcl-S Count      Zoned(5);","output":"This fully-free SQLRPGLE procedure `DataPopulate` validates input data and inserts customer details into `CstDtlPf` and login credentials into `LogInPf` with an encrypted password. It then resets flags and displays a success message.\n\nSet Job CCSID\n- The procedure starts by executing an SQL command to set the `CCSID` (Coded Character Set Identifier) to 37, ensuring correct character encoding.\n```rpgle\n      Exec sql call qcmdExc('CHGJOB CCSID(37)');\n```\n\nReset Indicators and Validate Data\n- It calls the `ResetIndicator` subprocedure to reset any flags or control variables.\n- Next, it clears any previous error messages `NCERROR` and calls `Validation` to check if the input data is correct.\n```rpgle\n      ResetIndicator();\n      Clear NCERROR;\n      Validation();\n```\n\nInsert Customer Data\n- If there are no errors `NCERROR` = `*Blank`, and the insert flag `Insert` = `*On` is enabled, the customer details are inserted into the `CstDtlPf` table.\n```rpgle\n      Exec Sql\n         Insert Into CstDtlPf ( CSTID , CSTNAME , CSTSTATE , CSTGMAIL ,\n                              CSTADDRESS , CSTGENDER , CSTCITY ,\n                              CSTMOBILE , CSTCOUNTRY , CSTPINCODE )\n         Values ( :CNUSRID , :CNNAME , :CNSTATE , :CNGMAIL ,\n                  :CNAddress , :CNGender , :CNCity , :CNMobile ,\n                  :CNCountry , :CNPINCODE );\n```\n- This step stores customer information such as ID, Name, Address, Contact details, and Gender in the database.\n\nEncrypt Password and Store Login Credentials\n- Before storing the login details, the procedure encrypts the customer's password using `Base64` encoding.\n```rpgle\n      Exec sql\n         SELECT SYSTOOLS.BASE64ENCODE(:CNCPASS) into :Encrypt\n               from SYSIBM.SYSDUMMY1;\n```\n- After encryption, the login credentials are inserted into the `LogInPf` table along with security questions and the default role `customer`.\n```rpgle\n      Exec Sql\n         Insert Into LogInPf ( LOGINID , PASSWORD , SCURITYQUE ,\n                              SCURITYANS , ROLE )\n         Values ( :CNUSRID , :Encrypt , :SECQUE ,\n                  :CNSECURITY , 'customer' );\n```\n\nReset Flags and Confirm Success\n- After successfully inserting the data, the procedure turns off the flag `Insert` = `*Off`, clears new customer registration fields, and sets a success message.\n```rpgle\n      Insert = *Off;\n      Clear NEWCSTREG;\n      NCERROR = 'Record Inserted Successfully';\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_DataPopulate/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"NEWCSTMRRG_IdAutoPopulate_sum","input_data":"  Dcl-Proc IdAutoPopulate ;\n      Dcl-Pi IdAutoPopulate Char(6);\n      End-Pi;\n\n    Exec Sql\n       Set option commit = *None;\n\n    Exec Sql\n       Select Max(CSTID) into :RegId from CSTDTLPF;\n       CstId = RegId;\n    If CstId = *blank;\n       CstId = 'CT0001';\n       CNUsrId = Cstid ;\n       Return CNUsrId ;\n    Else;\n       Id = %Int(%Subst( CstId : 3 ));\n       Id = Id + 1;\n       Formatpart = %Editc( Id : 'X' );\n       NewusrId = 'CT' + %Trimr(%Replace(Formatpart:'0':1));\n       CnUsrId = NewusrId ;\n       Return CNUsrId ;\n    EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F CSTDTLPF  Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-s NewUsrid   Char(6) ;\n  Dcl-s Formatpart Char(4) ;\n  Dcl-S RegId      Char(6) ;\n  Dcl-S Id         Zoned(4);","output":"This fully-free SQLRPGLE procedure `IdAutoPopulate` generates a new customer ID by checking the latest existing ID in the system.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_IdAutoPopulate/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"NEWCSTMRRG_IdAutoPopulate_api","input_data":"  Dcl-Proc IdAutoPopulate ;\n      Dcl-Pi IdAutoPopulate Char(6);\n      End-Pi;\n\n    Exec Sql\n       Set option commit = *None;\n\n    Exec Sql\n       Select Max(CSTID) into :RegId from CSTDTLPF;\n       CstId = RegId;\n    If CstId = *blank;\n       CstId = 'CT0001';\n       CNUsrId = Cstid ;\n       Return CNUsrId ;\n    Else;\n       Id = %Int(%Subst( CstId : 3 ));\n       Id = Id + 1;\n       Formatpart = %Editc( Id : 'X' );\n       NewusrId = 'CT' + %Trimr(%Replace(Formatpart:'0':1));\n       CnUsrId = NewusrId ;\n       Return CNUsrId ;\n    EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F CSTDTLPF  Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-s NewUsrid   Char(6) ;\n  Dcl-s Formatpart Char(4) ;\n  Dcl-S RegId      Char(6) ;\n  Dcl-S Id         Zoned(4);","output":"## Purpose  \nThis fully-free SQLRPGLE procedure `IdAutoPopulate` generates a unique customer ID automatically. It ensures that each new customer gets a sequential and properly formatted ID based on the latest existing ID in the system.\n\n## Parameters  \n\n- Return Value: A 6-character string representing the newly generated customer ID.\n\n## Database\n\n- Retrieves the highest existing customer ID `CSTID` from the `CSTDTLPF` table but does not modify the database.\n\n## Impacts\n\n### Global Variables\n\n- The procedure uses variables `CstId`, `RegId`, `NewUsrId`, and `CNUsrId` to generate and return the new ID.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_IdAutoPopulate/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"NEWCSTMRRG_IdAutoPopulate_how","input_data":"  Dcl-Proc IdAutoPopulate ;\n      Dcl-Pi IdAutoPopulate Char(6);\n      End-Pi;\n\n    Exec Sql\n       Set option commit = *None;\n\n    Exec Sql\n       Select Max(CSTID) into :RegId from CSTDTLPF;\n       CstId = RegId;\n    If CstId = *blank;\n       CstId = 'CT0001';\n       CNUsrId = Cstid ;\n       Return CNUsrId ;\n    Else;\n       Id = %Int(%Subst( CstId : 3 ));\n       Id = Id + 1;\n       Formatpart = %Editc( Id : 'X' );\n       NewusrId = 'CT' + %Trimr(%Replace(Formatpart:'0':1));\n       CnUsrId = NewusrId ;\n       Return CNUsrId ;\n    EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F CSTDTLPF  Disk Usage(*Input:*Output:*Update) Keyed;\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-s NewUsrid   Char(6) ;\n  Dcl-s Formatpart Char(4) ;\n  Dcl-S RegId      Char(6) ;\n  Dcl-S Id         Zoned(4);","output":"This fully-free SQLRPGLE procedure `IdAutoPopulate` generates a unique customer ID automatically. It ensures that each new customer gets a sequential and properly formatted ID based on the latest existing ID in the system.\n\nStart the Procedure\n- The procedure `IdAutoPopulate` is called and returns a 6-character customer ID.\n\nSet SQL Options\n```rpgle\n        Exec Sql Set option commit = *None;\n```\n- Disables commitment control for this transaction.\n\nRetrieve the Latest Customer ID from the Database\n```rpgle\n        Exec Sql Select Max(CSTID) into :RegId from CSTDTLPF;\n        CstId = RegId;\n```\n- Queries the database to get the highest existing customer ID `CSTID` from the `CSTDTLPF` table.  \n- Stores the result in `CstId`.\n\nCheck if There Are No Existing Customer IDs\n```rpgle\n        If CstId = *blank;\n```\n- If the database is empty (no existing IDs), assigns the first ID as `'CT0001'`.\n\nAssign the First Customer ID if No ID Exists  \n```rpgle\n        CstId = 'CT0001';\n        CNUsrId = Cstid;\n        Return CNUsrId;\n```\n- Sets `CstId` to `'CT0001'` for the first customer.  \n- Assigns this value to `CNUsrId` and returns it.\n\nIf an Existing ID is Found, Extract the Numeric Part\n```rpgle\n        Id = %Int(%Subst( CstId : 3 ));\n        Id = Id + 1;\n```\n- Extracts the numeric portion of the highest ID.  \n- Increments the numeric part by 1.\n\nFormat the New Customer ID \n```rpgle\n        Formatpart = %Editc( Id : 'X' );\n        NewusrId = 'CT' + %Trimr(%Replace(Formatpart:'0':1));\n```\n- Converts the incremented number into a string with proper formatting.  \n- Prefixes it with `'CT'` to maintain consistency.\n\nAssign and Return the New Customer ID  \n```rpgle\n        CnUsrId = NewusrId;\n        Return CNUsrId;\n```\n- Stores the formatted new ID in `CNUsrId`.  \n- Returns the newly generated customer ID.\n- This procedure ensures that each new customer is assigned a sequential and correctly formatted unique ID.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_IdAutoPopulate/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"NEWCSTMRRG_ResetIndicator_sum","input_data":"   Dcl-Proc ResetIndicator;\n\n     WrongPass   = *Off;\n     CnfPass     = *Off;\n     IndName     = *Off;\n     IndState    = *Off;\n     IndGmail    = *Off;\n     IndAddress  = *Off;\n     IndGender   = *Off;\n     IndCity     = *Off;\n     IndMobile   = *Off;\n     Indpincode  = *Off;\n     IndSecurity = *Off;\n     IndSecQ     = *Off;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;","output":" This fully-free ILE SQL RPG procedure `ResetIndicator`  is responsible for resetting all indicator flags used for validation and error handling.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_ResetIndicator/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"NEWCSTMRRG_ResetIndicator_api","input_data":"   Dcl-Proc ResetIndicator;\n\n     WrongPass   = *Off;\n     CnfPass     = *Off;\n     IndName     = *Off;\n     IndState    = *Off;\n     IndGmail    = *Off;\n     IndAddress  = *Off;\n     IndGender   = *Off;\n     IndCity     = *Off;\n     IndMobile   = *Off;\n     Indpincode  = *Off;\n     IndSecurity = *Off;\n     IndSecQ     = *Off;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;","output":"## Purpose\nThis fully-free ILE SQL RPG procedure `ResetIndicator` resets all validation and status indicators used in the customer registration process. It ensures a clean state before handling new user interactions.\n\n## Parameters\nThis procedure does not take any input and output parameters.\n\n## Dependencies\nThe procedure modifies values within the `IndDs1` data structure, which contains validation indicators for different fields in the customer registration process.\n\n### Global Variables\n\nThe following indicator variables from the `IndDs1` data structure are reset to *Off:\n\n| Indicator | Name     | Description     |\n|----|----|----|\n| `*IN27` | `WrongPass` | Password validation error |\n| `*IN28` | `CnfPass` | Confirm password mismatch error |\n| `*IN29` | `IndName` | Name field validation error |\n| `*IN30` | `IndState`| State field validation error |\n| `*IN31` | `IndGmail` | Email validation error |\n| `*IN32` | `IndAddress` | Address validation error |\n| `*IN33` | `IndGender` | Gender selection error |\n| `*IN34` | `IndCity` | City field validation error |\n| `*IN35` | `IndMobile` | Mobile number validation error |\n| `*IN37` | `IndPincode` | Pincode validation error |\n| `*IN38` | `IndSecurity` | Security answer validation error |\n| `*IN39` | `IndSecQ` | Security question validation error |\n\nBy turning off these indicators `ResetIndicator` ensures that no outdated error messages persist when a new registration attempt begins.\n\n##  Usage Example\nImagine a user registration form where input fields need validation. If a user enters incorrect data, corresponding indicators (`IndName`, `IndMobile`, etc.) will be turned on.\nOnce the user fixes their inputs or navigates away, `ResetIndicator` can be called to clear all error indicators.\n\n```rpgle\n  If ErrorFound;\n    ResetIndicator();  // Reset all validation indicators\n  Endif;\n```\n\n- If an error was found in form validation, `ResetIndicator()` is called to clear previous validation errors.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_ResetIndicator/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"NEWCSTMRRG_ResetIndicator_how","input_data":"   Dcl-Proc ResetIndicator;\n\n     WrongPass   = *Off;\n     CnfPass     = *Off;\n     IndName     = *Off;\n     IndState    = *Off;\n     IndGmail    = *Off;\n     IndAddress  = *Off;\n     IndGender   = *Off;\n     IndCity     = *Off;\n     IndMobile   = *Off;\n     Indpincode  = *Off;\n     IndSecurity = *Off;\n     IndSecQ     = *Off;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;","output":"The fully-free ILE SQL RPG procedure `ResetIndicator` ensures that all relevant indicators are turned off and clears necessary fields to reset the screen state properly.\nThis procedure is called whenever the screen needs to be refreshed or when an operation (such as user input validation) completes, ensuring a clean and error-free UI for the next interaction.\n\n```rpgle\n    Dcl-Proc ResetIndicator;\n```\n\n- Declares the `ResetIndicator` procedure.\n- This procedure does not take any parameters.\n- It is meant to be called whenever the system needs to clear validation flags or reset user input tracking.\n\nResetting Indicator Variables\n\n```rpgle\n    WrongPass   = *Off;\n    CnfPass     = *Off;\n    IndName     = *Off;\n    IndState    = *Off;\n    IndGmail    = *Off;\n    IndAddress  = *Off;\n    IndGender   = *Off;\n    IndCity     = *Off;\n    IndMobile   = *Off;\n    Indpincode  = *Off;\n    IndSecurity = *Off;\n    IndSecQ     = *Off;\n```\n\n- Each indicator variable is assigned `*Off`, meaning false or inactive.\n- These indicators are used in user input validation or error handling.\n- Example usage of each:\n  - `WrongPass` - Tracks incorrect password entry.\n  - `CnfPass` - Tracks password confirmation status.\n  - `IndName` - Tracks whether the Name field has errors.\n  - `IndState` - Tracks State selection validation.\n  - `IndGmail` - Tracks Gmail input validation.\n  - `IndAddress` - Tracks Address input validation.\n  - `IndGender` - Tracks Gender selection validation.\n  - `IndCity` - Tracks City input validation.\n  - `IndMobile` - Tracks Mobile number validation.\n  - `Indpincode` - Tracks Pincode validation.\n  - `IndSecurity` - Tracks Security settings validation.\n  - `IndSecQ` - Tracks Security question selection validation.\n\nEnd of Procedure\n```rpgle\n    End-Proc;\n```\n\n- Ends the procedure execution.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_ResetIndicator/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"NEWCSTMRRG_validation_sum","input_data":"   Dcl-Proc Validation ;\n\n     Dcl-s mailvalid varchar(100);\n     Result  = %Scan( '0' : %Char(CNMobile) : 1 );\n     Len     = %Len(%Trim(%Char(CnMobile)));\n     Len1    = %Len(%Trim(%Char(CnPincode)));\n     Result1 = %Check(String:%Char(CNMobile));\n     Result2 = %Check(String:%Char(CNPincode));\n     Result3 = %Check(String1:%Trim(CNCity));\n     Result4 = %Check(String1:%Trim(CNName));\n     Result5 = %Check(String2:%Trim(CNAddress));\n     mailvalid = %Trim(cngmail);\n     Regex     = '^(?:\\w+\\.?)*\\w+@(?:\\w+\\.)*\\w+$';\n\n     Exec Sql\n         Set :Count = RegExp_Count(:mailvalid,:Regex);\n\n    //If-Else statement to control the flow of program\n    //Password field validation\n     If CNPass    = *Blank;\n        NCError   = 'Password field can not be blank';\n        WrongPass = *On;\n        Return;\n\n    //Confirm password field validation\n     ElseIf CNCPass = *Blank Or CNPass <> CNCPass ;\n            NCError = 'Password and confirm password field should be same';\n            CnfPass = *On;\n            Return;\n\n    //Name field validation\n     ElseIf CNName  = *Blank ;\n            NCError = 'Name field can not be blank';\n            IndName = *On;\n            Return;\n\n     ElseIf Result4 <> 0;\n            NCError = 'Only Characters are allowed';\n            IndName = *On;\n            Return;\n\n    //State field validation\n     ElseIf CNState  = *Blank ;\n            NCError  = 'State field can not be blank';\n            IndState = *On;\n            Return;\n\n    //Email field validation\n     Elseif CNGmail  = *Blank ;\n            NCError  = 'Email field can not be blank';\n            IndGmail = *On;\n            Return;\n\n     ElseIf Count   <> 1 ;\n            NCError  = 'Invalid Email';\n            IndGmail = *On;\n            Return;\n\n    //Address field validaiton\n     ElseIf CNAddress  = *Blank ;\n            NCError    = 'Address field can not be blank';\n            IndAddress = *On;\n            Return;\n\n     ElseIf Result5   <> 0 ;\n            NCError    = 'Special Characters are not allowed';\n            IndAddress = *On;\n            Return;\n\n    //Security question field validation\n     ElseIf SECQUE  = *Blank;\n            NCError = 'Security Question field can not be blank';\n            IndSecQ = *On;\n            Return;\n\n    //Gender field validation\n     ElseIf CNGender  = *Blank ;\n            NCError   = 'Gender field can not be blank';\n            IndGender = *On;\n            Return;\n\n    //City field validation\n     ElseIf CNCity  = *Blank ;\n            NCError = 'City field can not be blank';\n            IndCity = *On;\n            Return;\n\n     ElseIf Result3 <> 0;\n            NCError = 'Only Characters are allowed';\n            IndCity = *On;\n            Return;\n\n    //Mobile number field validation\n     ElseIf CNMobile  = 0;\n            NCError   = 'Mobile field can not be blank';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Result    = 1 ;\n            NCError   = 'Mobile number field should not strat with zero';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Len < 10 ;\n            NCError   = 'Mobile number should not Less than Ten';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Result1 <> 0;\n            NCError   = 'Character should not be in this field';\n            IndMobile = *On;\n            Return;\n\n    //Pincode field validation\n     ElseIf CNPincode = 0;\n            NCError    = 'Pincode field can not be blank';\n            IndPincode = *On;\n            Return;\n\n     ElseIf Len1 < 6 ;\n            NCError    = 'Pincode field should not less than 6';\n            IndPincode = *On;\n            Return;\n\n     ElseIf Result2 <> 0;\n            NCError    = 'Character should not be in this field';\n            IndPincode = *On;\n            Return;\n\n    //password and confirm password field validation\n     ElseIf CNPass <> CNCPass ;\n            NCError = 'Password and confirm password field should be same';\n            CnfPass = *On;\n            Return;\n\n    //Security answer field validation\n     ElseIf CnSecurity  = *Blank;\n            NCError     = ' Security Answer field Should not be blank';\n            IndSecurity = *On;\n            Return;\n\n     Else;\n\n          //Reset Indicator subprocedure  \n           ResetIndicator();\n           Clear NCERROR ;\n      EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;\n  Dcl-S Result     zoned(1);\n  Dcl-S Result1    Zoned(2);\n  Dcl-S Result2    Zoned(2);\n  Dcl-S Result3    Zoned(2);\n  Dcl-S Result4    Zoned(2);\n  Dcl-S Result5    Zoned(2);\n  Dcl-S Len        Zoned(2);\n  Dcl-S Len1       Zoned(2);\n  Dcl-S String     Char(10) Inz('0123456789');\n  Dcl-S String1    Char(26) Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n  Dcl-S String2    Char(36) Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');\n  Dcl-S Id         Zoned(4);\n  Dcl-S Count      Zoned(5);\n  Dcl-S Regex      VarChar(50);","output":" This fully-free SQLRPGLE procedure `Validation` will validate each field of the `NEWCSTREG`  screen.\n It returns to the caller after turning on related field-level error indicators and displaying the error message to display on the screen.  \nThis procedure is part of new customer registration module that allows users to create an account by filling required screen fields.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_validation/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"NEWCSTMRRG_validation_api","input_data":"   Dcl-Proc Validation ;\n\n     Dcl-s mailvalid varchar(100);\n     Result  = %Scan( '0' : %Char(CNMobile) : 1 );\n     Len     = %Len(%Trim(%Char(CnMobile)));\n     Len1    = %Len(%Trim(%Char(CnPincode)));\n     Result1 = %Check(String:%Char(CNMobile));\n     Result2 = %Check(String:%Char(CNPincode));\n     Result3 = %Check(String1:%Trim(CNCity));\n     Result4 = %Check(String1:%Trim(CNName));\n     Result5 = %Check(String2:%Trim(CNAddress));\n     mailvalid = %Trim(cngmail);\n     Regex     = '^(?:\\w+\\.?)*\\w+@(?:\\w+\\.)*\\w+$';\n\n     Exec Sql\n         Set :Count = RegExp_Count(:mailvalid,:Regex);\n\n    //If-Else statement to control the flow of program\n    //Password field validation\n     If CNPass    = *Blank;\n        NCError   = 'Password field can not be blank';\n        WrongPass = *On;\n        Return;\n\n    //Confirm password field validation\n     ElseIf CNCPass = *Blank Or CNPass <> CNCPass ;\n            NCError = 'Password and confirm password field should be same';\n            CnfPass = *On;\n            Return;\n\n    //Name field validation\n     ElseIf CNName  = *Blank ;\n            NCError = 'Name field can not be blank';\n            IndName = *On;\n            Return;\n\n     ElseIf Result4 <> 0;\n            NCError = 'Only Characters are allowed';\n            IndName = *On;\n            Return;\n\n    //State field validation\n     ElseIf CNState  = *Blank ;\n            NCError  = 'State field can not be blank';\n            IndState = *On;\n            Return;\n\n    //Email field validation\n     Elseif CNGmail  = *Blank ;\n            NCError  = 'Email field can not be blank';\n            IndGmail = *On;\n            Return;\n\n     ElseIf Count   <> 1 ;\n            NCError  = 'Invalid Email';\n            IndGmail = *On;\n            Return;\n\n    //Address field validaiton\n     ElseIf CNAddress  = *Blank ;\n            NCError    = 'Address field can not be blank';\n            IndAddress = *On;\n            Return;\n\n     ElseIf Result5   <> 0 ;\n            NCError    = 'Special Characters are not allowed';\n            IndAddress = *On;\n            Return;\n\n    //Security question field validation\n     ElseIf SECQUE  = *Blank;\n            NCError = 'Security Question field can not be blank';\n            IndSecQ = *On;\n            Return;\n\n    //Gender field validation\n     ElseIf CNGender  = *Blank ;\n            NCError   = 'Gender field can not be blank';\n            IndGender = *On;\n            Return;\n\n    //City field validation\n     ElseIf CNCity  = *Blank ;\n            NCError = 'City field can not be blank';\n            IndCity = *On;\n            Return;\n\n     ElseIf Result3 <> 0;\n            NCError = 'Only Characters are allowed';\n            IndCity = *On;\n            Return;\n\n    //Mobile number field validation\n     ElseIf CNMobile  = 0;\n            NCError   = 'Mobile field can not be blank';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Result    = 1 ;\n            NCError   = 'Mobile number field should not strat with zero';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Len < 10 ;\n            NCError   = 'Mobile number should not Less than Ten';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Result1 <> 0;\n            NCError   = 'Character should not be in this field';\n            IndMobile = *On;\n            Return;\n\n    //Pincode field validation\n     ElseIf CNPincode = 0;\n            NCError    = 'Pincode field can not be blank';\n            IndPincode = *On;\n            Return;\n\n     ElseIf Len1 < 6 ;\n            NCError    = 'Pincode field should not less than 6';\n            IndPincode = *On;\n            Return;\n\n     ElseIf Result2 <> 0;\n            NCError    = 'Character should not be in this field';\n            IndPincode = *On;\n            Return;\n\n    //password and confirm password field validation\n     ElseIf CNPass <> CNCPass ;\n            NCError = 'Password and confirm password field should be same';\n            CnfPass = *On;\n            Return;\n\n    //Security answer field validation\n     ElseIf CnSecurity  = *Blank;\n            NCError     = ' Security Answer field Should not be blank';\n            IndSecurity = *On;\n            Return;\n\n     Else;\n\n          //Reset Indicator subprocedure  \n           ResetIndicator();\n           Clear NCERROR ;\n      EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;\n  Dcl-S Result     zoned(1);\n  Dcl-S Result1    Zoned(2);\n  Dcl-S Result2    Zoned(2);\n  Dcl-S Result3    Zoned(2);\n  Dcl-S Result4    Zoned(2);\n  Dcl-S Result5    Zoned(2);\n  Dcl-S Len        Zoned(2);\n  Dcl-S Len1       Zoned(2);\n  Dcl-S String     Char(10) Inz('0123456789');\n  Dcl-S String1    Char(26) Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n  Dcl-S String2    Char(36) Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');\n  Dcl-S Id         Zoned(4);\n  Dcl-S Count      Zoned(5);\n  Dcl-S Regex      VarChar(50);","output":"## Purpose \n\nThis fully-free ILE Sql RPG procedure `Validation` will Validate each field of the `NEWCSTREG`  screen used to input customer data when registering new customers.\n\n## Parameters\n\nNone\n\n### Input\n\n#### Screen\n\nScreen fields validated under record format `NEWCSTREG` of display file `EHEADSCRN` are listed below.\n\n- `CNPass` - Password\n- `CNCPass` - Confirm password\n- `CNName` - Name\n- `CNState` - State\n- `CNGmail` - Email\n- `CNAddress` - Address\n- `SECQUE` - Security question\n- `CNGender`- Gender\n- `CNCity` - City\n- `CNMobile` - Mobile number\n- `CNPincode`- Pincode\n- `CnSecurity` - Security answer\n\n### Output\n\n#### Indicators\n\nThe following indicators are turned on which cause the field in error to be highlighted when the `NEWCSTREG` is rewritten to the display.\n\n| Indicator Name | Indicator Number  | DSPF Field to Highlight | Description |\n| -------------- |-------------------|-------------------------|-------------|\n| `WrongPass` | `27` | CNPass | Password |\n| `CnfPass` | `28` | CNCPass | Password Confirmation |\n| `IndName` | `29` | CNName | Customer Name |\n| `IndState` | `30` | CNState | State |\n| `IndGmail` | `31` | CNGmail | Email Address |\n| `IndAddress` | `32` | CNAddress | Postal Address |\n| `IndGender` | `33` | CNGender | Gender |\n| `IndCity` | `34` | CNCity | City |\n| `IndMobile` | `35` | CNMobile | Mobile Number |\n| `IndPincode` | `37` | CNPincode | PIN code |\n| `IndSecurity` | `38` | CNPincode | Security Answer |\n| `IndSecQ` | `39` | SECQUE | Security Question |\n\n#### Error messages\n\nIn screen field `NCERROR` will be assigned one of the error messages below if the input fields of record format `NEWCSTREG` fail validation.\n\n- `Password field cannot be blank`\n- `Confirm Password field cannot be blank`\n- `Password field and confirm field should be same`\n- `Name field cannot be blank`\n- `Name field cannot contain a number and special character`\n- `State field cannot be blank`\n- `Email field cannot be blank`\n- `Address field cannot be blank`\n- `Special Character not allowed in address field`\n- `Security Question field cannot be blank`\n- `Gender cannot be unselected`\n- `Mobile field cannot be blank`\n- `Mobile number cannot be Less than Ten`\n- `Field should not start with zero`\n- `Pincode field cannot be blank`\n- `pincode number cannot be less than six`\n- `Character is not allowed in this field`\n- `Password and confirm password field should be same`\n- `Security answer field cannot be blank`\n  \n  ## Dependencies\n\n  Below are the list of procedures used\n\n-   `ResetIndicator` with No parameters.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_validation/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"NEWCSTMRRG_validation_how","input_data":"   Dcl-Proc Validation ;\n\n     Dcl-s mailvalid varchar(100);\n     Result  = %Scan( '0' : %Char(CNMobile) : 1 );\n     Len     = %Len(%Trim(%Char(CnMobile)));\n     Len1    = %Len(%Trim(%Char(CnPincode)));\n     Result1 = %Check(String:%Char(CNMobile));\n     Result2 = %Check(String:%Char(CNPincode));\n     Result3 = %Check(String1:%Trim(CNCity));\n     Result4 = %Check(String1:%Trim(CNName));\n     Result5 = %Check(String2:%Trim(CNAddress));\n     mailvalid = %Trim(cngmail);\n     Regex     = '^(?:\\w+\\.?)*\\w+@(?:\\w+\\.)*\\w+$';\n\n     Exec Sql\n         Set :Count = RegExp_Count(:mailvalid,:Regex);\n\n    //If-Else statement to control the flow of program\n    //Password field validation\n     If CNPass    = *Blank;\n        NCError   = 'Password field can not be blank';\n        WrongPass = *On;\n        Return;\n\n    //Confirm password field validation\n     ElseIf CNCPass = *Blank Or CNPass <> CNCPass ;\n            NCError = 'Password and confirm password field should be same';\n            CnfPass = *On;\n            Return;\n\n    //Name field validation\n     ElseIf CNName  = *Blank ;\n            NCError = 'Name field can not be blank';\n            IndName = *On;\n            Return;\n\n     ElseIf Result4 <> 0;\n            NCError = 'Only Characters are allowed';\n            IndName = *On;\n            Return;\n\n    //State field validation\n     ElseIf CNState  = *Blank ;\n            NCError  = 'State field can not be blank';\n            IndState = *On;\n            Return;\n\n    //Email field validation\n     Elseif CNGmail  = *Blank ;\n            NCError  = 'Email field can not be blank';\n            IndGmail = *On;\n            Return;\n\n     ElseIf Count   <> 1 ;\n            NCError  = 'Invalid Email';\n            IndGmail = *On;\n            Return;\n\n    //Address field validaiton\n     ElseIf CNAddress  = *Blank ;\n            NCError    = 'Address field can not be blank';\n            IndAddress = *On;\n            Return;\n\n     ElseIf Result5   <> 0 ;\n            NCError    = 'Special Characters are not allowed';\n            IndAddress = *On;\n            Return;\n\n    //Security question field validation\n     ElseIf SECQUE  = *Blank;\n            NCError = 'Security Question field can not be blank';\n            IndSecQ = *On;\n            Return;\n\n    //Gender field validation\n     ElseIf CNGender  = *Blank ;\n            NCError   = 'Gender field can not be blank';\n            IndGender = *On;\n            Return;\n\n    //City field validation\n     ElseIf CNCity  = *Blank ;\n            NCError = 'City field can not be blank';\n            IndCity = *On;\n            Return;\n\n     ElseIf Result3 <> 0;\n            NCError = 'Only Characters are allowed';\n            IndCity = *On;\n            Return;\n\n    //Mobile number field validation\n     ElseIf CNMobile  = 0;\n            NCError   = 'Mobile field can not be blank';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Result    = 1 ;\n            NCError   = 'Mobile number field should not strat with zero';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Len < 10 ;\n            NCError   = 'Mobile number should not Less than Ten';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Result1 <> 0;\n            NCError   = 'Character should not be in this field';\n            IndMobile = *On;\n            Return;\n\n    //Pincode field validation\n     ElseIf CNPincode = 0;\n            NCError    = 'Pincode field can not be blank';\n            IndPincode = *On;\n            Return;\n\n     ElseIf Len1 < 6 ;\n            NCError    = 'Pincode field should not less than 6';\n            IndPincode = *On;\n            Return;\n\n     ElseIf Result2 <> 0;\n            NCError    = 'Character should not be in this field';\n            IndPincode = *On;\n            Return;\n\n    //password and confirm password field validation\n     ElseIf CNPass <> CNCPass ;\n            NCError = 'Password and confirm password field should be same';\n            CnfPass = *On;\n            Return;\n\n    //Security answer field validation\n     ElseIf CnSecurity  = *Blank;\n            NCError     = ' Security Answer field Should not be blank';\n            IndSecurity = *On;\n            Return;\n\n     Else;\n\n          //Reset Indicator subprocedure  \n           ResetIndicator();\n           Clear NCERROR ;\n      EndIf;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n\n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nNewCstmrReg.sqlrpgle:\n  Dcl-F Eheadscrn Workstn Indds(Indds1);\n  Dcl-Ds IndDs1;\n\n    Cancel      Ind Pos(12);\n    Prompt      Ind Pos(04);\n    Refresh     Ind Pos(05);\n    Insert      Ind Pos(06);\n    WrongPass   Ind Pos(27);\n    CnfPass     Ind Pos(28);\n    Indname     Ind pos(29);\n    Indstate    Ind pos(30);\n    Indgmail    Ind pos(31);\n    Indaddress  Ind pos(32);\n    Indgender   Ind pos(33);\n    Indcity     Ind pos(34);\n    Indmobile   Ind pos(35);\n    Indpincode  Ind pos(37);\n    IndSecurity Ind Pos(38);\n    IndSecQ     Ind Pos(39);\n\n  End-Ds;\n  Dcl-S Result     zoned(1);\n  Dcl-S Result1    Zoned(2);\n  Dcl-S Result2    Zoned(2);\n  Dcl-S Result3    Zoned(2);\n  Dcl-S Result4    Zoned(2);\n  Dcl-S Result5    Zoned(2);\n  Dcl-S Len        Zoned(2);\n  Dcl-S Len1       Zoned(2);\n  Dcl-S String     Char(10) Inz('0123456789');\n  Dcl-S String1    Char(26) Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n  Dcl-S String2    Char(36) Inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');\n  Dcl-S Id         Zoned(4);\n  Dcl-S Count      Zoned(5);\n  Dcl-S Regex      VarChar(50);","output":"This is a fully-free ILE Sql Rpg Procedure `Validation` and is part of new customer registration module.\nIt allows users to create an account by filling required fields.\nProcedure `Validation` will Validate each field of the display screen based on certain conditions and return after turning on the field-level indicators and displaying the Error message in screen field `NCError` if any as mentioned below\n\n1. If *password field is blank* highlight it and set error message to be `Password field cannot be blank`\n\n- else if *password field and confirm password field is not equal to each other* then highlight the confirm password and set error message to be `Password field and confirm field should be same`\n\n```rpgle\n     //If-Else statement to control the flow of program\n     //Password field validation\n     If CNPass    = *Blank;\n        NCError   = 'Password field can not be blank';\n        WrongPass = *On;\n        Return;\n\n     //Confirm password field validation\n     ElseIf CNCPass = *Blank Or CNPass <> CNCPass ;\n            NCError = 'Password and confirm password field should be same';\n            CnfPass = *On;\n            Return;\n```\n\n2. If *name field is blank* then highlight it and set error message to be `Name field cannot be blank`\n\n- If *value filled in the name field contains special characters and numbers* then highlight it and set error message to be `Name field cannot contain a number and special character`\n\n ```rpgle\n     //Name field validation\n     ElseIf CNName  = *Blank ;\n            NCError = 'Name field can not be blank';\n            IndName = *On;\n            Return;\n\n     ElseIf Result4 <> 0;\n            NCError = 'Only Characters are allowed';\n            IndName = *On;\n            Return;\n```\n\n3. If *state field is blank* then highlight it and set error message to be  \n         `State field cannot be blank`\n\n ```rpgle\n     //State field validation\n     ElseIf CNState  = *Blank ;\n            NCError  = 'State field can not be blank';\n            IndState = *On;\n            Return;\n ```\n\n4. If *email field is blank* then highlight it and set error message to be  \n         `Email field cannot be blank`\n\n- If *value filled in the email field is not valid* then highlight it and set error message to be `Invalid Email`\n\n```rpgle\n     //Email field validation\n     Elseif CNGmail  = *Blank ;\n            NCError  = 'Email field can not be blank';\n            IndGmail = *On;\n            Return;\n     ElseIf Count   <> 1 ;\n            NCError  = 'Invalid Email';\n            IndGmail = *On;\n            Return;\n```\n\n5. If *address field is blank* then highlight it and set error message to be\n         `Address field cannot be blank`\n     - If *any special character in address field* then highlight it and set error message to be  \n         `Special Character not allowed`\n\n```rpgle\n     //Address field validaiton\n     ElseIf CNAddress  = *Blank ;\n            NCError    = 'Address field can not be blank';\n            IndAddress = *On;\n            Return;\n\n     ElseIf Result5   <> 0 ;\n            NCError    = 'Special Characters are not allowed';\n            IndAddress = *On;\n            Return; \n```\n\n6. If *Security question field is blank* then highlight it and set error message to be  \n         `Security Question field cannot be blank`\n\n```rpgle\n     //Security question field validation\n     ElseIf SECQUE  = *Blank;\n            NCError = 'Security Question field can not be blank';\n            IndSecQ = *On;\n            Return;\n```\n\n7. If *gender field is blank* then highlight it and set error message to be\n        `Gender cannot be unselected`\n\n```rpgle\n     //Gender field validation\n     ElseIf CNGender  = *Blank ;\n            NCError   = 'Gender field can not be blank';\n            IndGender = *On;\n            Return;\n```\n\n8. If *city field is blank* then highlight it and set error message to be `City field cannot be blank`\n\n- If *any special character in the city field* then highlight it and set error message to be  \n       `Only Characters are allowed`\n\n```rpgle\n     //City field validation\n     ElseIf CNCity  = *Blank ;\n            NCError = 'City field can not be blank';\n            IndCity = *On;\n            Return;\n\n     ElseIf Result3 <> 0;\n            NCError = 'Only Characters are allowed';\n            IndCity = *On;\n            Return;\n```\n\n8. If *mobile field is blank* then highlight it and set error message to be\n     `Mobile field cannot be blank`\n\n- If *Mobile field has less than 10 digits* then highlight it and set error message to be\n  `Mobile number cannot be Less than Ten`\n- If *mobile field starts with zero* then highlight it and set error message to be  \n         `Field should not start with zero`\n\n```rpgle\n     //Mobile number field validation\n     ElseIf CNMobile  = 0;\n            NCError   = 'Mobile field can not be blank';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Result    = 1 ;\n            NCError   = 'Mobile number field should not strat with zero';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Len < 10 ;\n            NCError   = 'Mobile number should not Less than Ten';\n            IndMobile = *On;\n            Return;\n\n     ElseIf Result1 <> 0;\n            NCError   = 'Character should not be in this field';\n            IndMobile = *On;\n            Return;\n```\n\n9. If *pin code field is blank* then highlight it and set error message to be  \n         `Pincode field cannot be blank`\n\n- If *pin code field number is less than six* then highlight it and set error message to be  \n         `Pincode field should not less than 6`\n- If *there is any character in this pincode field* then highlight it and set error message to be  \n         `Character should not be in this field`\n\n```rpgle\n     //Pincode field validation\n     ElseIf CNPincode = 0;\n            NCError    = 'Pincode field can not be blank';\n            IndPincode = *On;\n            Return;\n\n     ElseIf Len1 < 6 ;\n            NCError    = 'Pincode field should not less than 6';\n            IndPincode = *On;\n            Return;\n\n     ElseIf Result2 <> 0;\n            NCError    = 'Character should not be in this field';\n            IndPincode = *On;\n            Return;\n```\n\n10. If *password and confirm password fields are Not equal* then return an error message `Password and confirm password field should be same`\n\n**NOTE** this logic is duplicate with the code in bullet 1.\n\n```rpgle\n     //password and confirm password field validation\n     ElseIf CNPass <> CNCPass ;\n            NCError = 'Password and confirm password field should be same';\n            CnfPass = *On;\n            Return;\n```\n\n11. If *security answer field is blank* then highlight it and set error message to be  \n        `Security answer field Should not be blank`\n\n```rpgle\n     //Security answer field validation\n     ElseIf CnSecurity  = *Blank;\n            NCError     = ' Security Answer field Should not be blank';\n            IndSecurity = *On;\n            Return;\n```\n\n12. If all screen fields are valid  invoke procedure `ResetIndicator` without parameters to reset all screen field indicators and clear error message screen field`NCERROR`.  As a result the screen will be shown with no fields being highlighted as in error and no error message showing.\n\n```rpgle\n     Else;\n\n          //Reset Indicator subprocedure  \n           ResetIndicator();\n           Clear NCERROR ;\n      EndIf;\n\n   End-Proc;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NEWCSTMRRG_validation/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"NWORG_REG_AutoIncId_sum","input_data":"       Dcl-Proc AutoIncId;\n          Dcl-Pi AutoIncId Char(6);\n          End-Pi;\n       Exec Sql\n         Set option commit = *None;\n\n       Exec Sql\n\n            Select Max(ORGID) into :HNid from EVNTORGPF;\n            ORGID = HNid;\n            If ORGID = *blank;\n            ORGID = 'MG0001';\n            NORGId = ORGID ;\n            Return NORGID ;\n           Else;\n\n\n             MId = %Int(%Subst( ORGID : 3 ));\n             MId = MId + 1;\n             Formatpart1 = %Editc( MId : 'X' );\n             NewuserId = 'MG' + %Trimr(%Replace(Formatpart1:'0':1));\n             NORGID = NewuserId ;\n            Return NORGId ;\n           EndIf;\n\n\n       End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R SIGN_ONSCN\n \n     A                                      CF07(07 'New User Registration')\n     A                                      CF08(08 'New Vendor Registration')\n     A                                      CF09(09 'Forgot Password')\n     A                                  1 35'SHOW SHOPERS'\n     A                                      COLOR(WHT)\n     A                                  2 29'(TICKET BOOKING SYSTEM)'\n     A                                      COLOR(WHT)\n     A                                  1 67DATE\n     A                                      EDTCDE(Y)\n     A                                  2 67TIME\n     A                                  4 11' __________________________SIGN ON-\n     A                                      __________________________'\n     A                                      COLOR(WHT)\n     A                                  8 12'LOGIN ID.................:'\n     A                                      COLOR(GRN)\n     A                                 10 12'LOGIN PASSWORD...........:'\n     A                                      COLOR(GRN)\n     A            ERRMSG        40A  O 24  2COLOR(WHT)\n     A                                 21  6'          '\n     A                                      COLOR(BLU)\n     A                                 22  2'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 15'F7=New User Registration'\n     A                                      COLOR(BLU)\n     A                                 22 42'F8=New Event Organizer Registratio-\n     A                                      n'\n     A                                      COLOR(BLU)\n     A                                 16 24'*********'\n     A                                      COLOR(WHT)\n     A                                 17 24'IBM i 7.4'\n     A                                      COLOR(WHT)\n     A                                 18 24'*********'\n     A                                      COLOR(WHT)\n     A                                 23  2'F9=Forgot Password'\n     A                                      COLOR(BLU)\n     A            NLGNID         6A  B  8 40\n     A  80                                  DSPATR(RI)\n     A  80                                  DSPATR(PC)\n     A                                      COLOR(GRN)\n     A            NLGNPWD       10A  B 10 40COLOR(TRQ)\n     A  81                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A          R FRGT_PWSCN\nNworg_reg.sqlrpgle:\n        Dcl-f Cstdspf Workstn Indds(Indrds);\n        Dcl-F Evntorgpf Disk Usage(*Input:*Output:*Update) Keyed;\n       Dcl-s HNid char(6);\n       Dcl-s MId zoned(4);\n       Dcl-s Newuserid char(6);\n       Dcl-s Formatpart1 char(4);","output":"    This fully-free SQLRPGLE procedure  `AutoIncId` is used to build screen field `Organizer Id`.\n    If there is No maximum `Organizer Id` from database file `Evntorgpf` then set as `MG0001`.\n    Otherwise increment count in last 3 bytes of `Organizer Id` by 1 with prefix `MG` and set that value.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NWORG_REG_AutoIncId/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"NWORG_REG_AutoIncId_api","input_data":"       Dcl-Proc AutoIncId;\n          Dcl-Pi AutoIncId Char(6);\n          End-Pi;\n       Exec Sql\n         Set option commit = *None;\n\n       Exec Sql\n\n            Select Max(ORGID) into :HNid from EVNTORGPF;\n            ORGID = HNid;\n            If ORGID = *blank;\n            ORGID = 'MG0001';\n            NORGId = ORGID ;\n            Return NORGID ;\n           Else;\n\n\n             MId = %Int(%Subst( ORGID : 3 ));\n             MId = MId + 1;\n             Formatpart1 = %Editc( MId : 'X' );\n             NewuserId = 'MG' + %Trimr(%Replace(Formatpart1:'0':1));\n             NORGID = NewuserId ;\n            Return NORGId ;\n           EndIf;\n\n\n       End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R SIGN_ONSCN\n \n     A                                      CF07(07 'New User Registration')\n     A                                      CF08(08 'New Vendor Registration')\n     A                                      CF09(09 'Forgot Password')\n     A                                  1 35'SHOW SHOPERS'\n     A                                      COLOR(WHT)\n     A                                  2 29'(TICKET BOOKING SYSTEM)'\n     A                                      COLOR(WHT)\n     A                                  1 67DATE\n     A                                      EDTCDE(Y)\n     A                                  2 67TIME\n     A                                  4 11' __________________________SIGN ON-\n     A                                      __________________________'\n     A                                      COLOR(WHT)\n     A                                  8 12'LOGIN ID.................:'\n     A                                      COLOR(GRN)\n     A                                 10 12'LOGIN PASSWORD...........:'\n     A                                      COLOR(GRN)\n     A            ERRMSG        40A  O 24  2COLOR(WHT)\n     A                                 21  6'          '\n     A                                      COLOR(BLU)\n     A                                 22  2'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 15'F7=New User Registration'\n     A                                      COLOR(BLU)\n     A                                 22 42'F8=New Event Organizer Registratio-\n     A                                      n'\n     A                                      COLOR(BLU)\n     A                                 16 24'*********'\n     A                                      COLOR(WHT)\n     A                                 17 24'IBM i 7.4'\n     A                                      COLOR(WHT)\n     A                                 18 24'*********'\n     A                                      COLOR(WHT)\n     A                                 23  2'F9=Forgot Password'\n     A                                      COLOR(BLU)\n     A            NLGNID         6A  B  8 40\n     A  80                                  DSPATR(RI)\n     A  80                                  DSPATR(PC)\n     A                                      COLOR(GRN)\n     A            NLGNPWD       10A  B 10 40COLOR(TRQ)\n     A  81                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A          R FRGT_PWSCN\nNworg_reg.sqlrpgle:\n        Dcl-f Cstdspf Workstn Indds(Indrds);\n        Dcl-F Evntorgpf Disk Usage(*Input:*Output:*Update) Keyed;\n       Dcl-s HNid char(6);\n       Dcl-s MId zoned(4);\n       Dcl-s Newuserid char(6);\n       Dcl-s Formatpart1 char(4);","output":"## Purpose\nThis fully-free SQLRPGLE procedure `AutoIncId` is used to fetch event `organizer id`.\nIf there is No maximum `Organizer Id` from database file `Evntorgpf` set as `'MG0001'`.\nOtherwise increment count in last 3 bytes of `Organizer Id` by 1 with prefix `'MG'` and set that value.\n\n## Parameter\n\n### Input\n\n  Passed in input parameter `AutoIncId` - Character of length 6\n\n### input/output\n\n- `NORGID` - Organizer ID - Character of length 6. From screen record format `ORG_REGSCN` of display file `cstdspf.dspf`.\n\n### Dependencies\n\n Database file records in `EVNTORGPF`\n\n The following objects should be found in library list.\n\n- `cstdspf` - display file object that is used for screen input/output\n- `evntorgpf`- database file used for input","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NWORG_REG_AutoIncId/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"NWORG_REG_AutoIncId_how","input_data":"       Dcl-Proc AutoIncId;\n          Dcl-Pi AutoIncId Char(6);\n          End-Pi;\n       Exec Sql\n         Set option commit = *None;\n\n       Exec Sql\n\n            Select Max(ORGID) into :HNid from EVNTORGPF;\n            ORGID = HNid;\n            If ORGID = *blank;\n            ORGID = 'MG0001';\n            NORGId = ORGID ;\n            Return NORGID ;\n           Else;\n\n\n             MId = %Int(%Subst( ORGID : 3 ));\n             MId = MId + 1;\n             Formatpart1 = %Editc( MId : 'X' );\n             NewuserId = 'MG' + %Trimr(%Replace(Formatpart1:'0':1));\n             NORGID = NewuserId ;\n            Return NORGId ;\n           EndIf;\n\n\n       End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R SIGN_ONSCN\n \n     A                                      CF07(07 'New User Registration')\n     A                                      CF08(08 'New Vendor Registration')\n     A                                      CF09(09 'Forgot Password')\n     A                                  1 35'SHOW SHOPERS'\n     A                                      COLOR(WHT)\n     A                                  2 29'(TICKET BOOKING SYSTEM)'\n     A                                      COLOR(WHT)\n     A                                  1 67DATE\n     A                                      EDTCDE(Y)\n     A                                  2 67TIME\n     A                                  4 11' __________________________SIGN ON-\n     A                                      __________________________'\n     A                                      COLOR(WHT)\n     A                                  8 12'LOGIN ID.................:'\n     A                                      COLOR(GRN)\n     A                                 10 12'LOGIN PASSWORD...........:'\n     A                                      COLOR(GRN)\n     A            ERRMSG        40A  O 24  2COLOR(WHT)\n     A                                 21  6'          '\n     A                                      COLOR(BLU)\n     A                                 22  2'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 15'F7=New User Registration'\n     A                                      COLOR(BLU)\n     A                                 22 42'F8=New Event Organizer Registratio-\n     A                                      n'\n     A                                      COLOR(BLU)\n     A                                 16 24'*********'\n     A                                      COLOR(WHT)\n     A                                 17 24'IBM i 7.4'\n     A                                      COLOR(WHT)\n     A                                 18 24'*********'\n     A                                      COLOR(WHT)\n     A                                 23  2'F9=Forgot Password'\n     A                                      COLOR(BLU)\n     A            NLGNID         6A  B  8 40\n     A  80                                  DSPATR(RI)\n     A  80                                  DSPATR(PC)\n     A                                      COLOR(GRN)\n     A            NLGNPWD       10A  B 10 40COLOR(TRQ)\n     A  81                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A          R FRGT_PWSCN\nNworg_reg.sqlrpgle:\n        Dcl-f Cstdspf Workstn Indds(Indrds);\n        Dcl-F Evntorgpf Disk Usage(*Input:*Output:*Update) Keyed;\n       Dcl-s HNid char(6);\n       Dcl-s MId zoned(4);\n       Dcl-s Newuserid char(6);\n       Dcl-s Formatpart1 char(4);","output":"This fully-free SQLRPGLE procedure `AutoIncId` fetches the maximum (Event-Organizer ID) from `Evntorgpf` and store it in `Hnid` host variable.\n\n```Rpgle\n     Exec Sql\n       Select Max(ORGID) into :HNid from EVNTORGPF;\n        ORGID = HNid;\n```\n\nIf `Event-Organizer ID` database field of database file `eventorgf` is blanks, it populates `'MG0001'` in the Event-Organizer ID field and it is stored in `NORGID` screen field of display file `cstdspf`.\n\n```Rpgle\n        If ORGID = *blank;\n            ORGID = 'MG0001';\n            NORGId = ORGID ;\n            Return NORGID ;\n```\n\n Otherwise it extracts last 3 bytes by substring from the `Event-Organizer ID` and increments it by 1 then format it and concatenate the prefix `MG` with `Event-Organizer ID`.\n\n```Rpgle\n        Else;\n         MId = %Int(%Subst( ORGID : 3 ));\n         MId = MId + 1;\n         Formatpart1 = %Editc( MId : 'X' );\n         NewuserId = 'MG' + %Trimr(%Replace(Formatpart1:'0':1));\n```\n\nIt is stored in `NORGID` display file field in `ORG_REGSCN` record format in display file `cstdspf`.\n\n```Rpgle\n        NORGID = NewuserId ;\n        Return NORGId ;\n       EndIf;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NWORG_REG_AutoIncId/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"NWORG_REG_EventOrgReg_sum","input_data":"        Dcl-Proc EventOrgReg Export;\n           Dow Cancel = *Off;\n            AutoIncId();  //Call Autoincid sub-procedure\n            Exfmt ORG_REGSCN;\n\n\n           Select;\n            When Cancel  = *On;\n              Cancel  = *Off;\n              Clear ORG_REGSCN;\n              OffInd();  //Call Offind sub-procedure\n              Leave;\n\n            When Refresh = *On;\n              Refresh = *Off;\n              Clear ORG_REGSCN;\n              OffInd(); //Call Offind sub-procedure\n\n            When FLD = 'NORGSTATE' AND Prompt = *On;\n                 Prompt  = *Off;\n                 NORGSTATE = PromptDsp();  //Call external promptdsp sub-procedu\n                 ostate  = *Off;\n                 FieldValidation();\n\n            When FLD = 'NORGQUES' And Prompt = *On;\n                 Prompt = *Off;\n                NORGQUES =  PromptQue();  //Call external promptque sub-procedur\n                 OQues  = *Off;\n                FieldValidation();  //Call fieldvalidation sub-procedure\n\n\n            When FLD = 'NORGGNDER' AND Prompt = *On;\n                 Prompt = *Off;\n                 OGender  = *Off;\n                 Clear ErrMsg;\n\n              Dow Cancel = *Off;\n\n                 Exfmt GNDRWNDW  ;\n\n               Select ;\n                 When Gender = 1;\n                      NORGGNDER = 'M';\n\n                 When Gender = 2;\n                      NORGGNDER = 'F';\n\n                 When Gender = 3;\n                      NORGGNDER = 'O';\n               Endsl;\n\n\n                 If Cancel = *On;\n                      Cancel = *Off;\n                      Clear ErrMsg;\n                      OffInd();  //Call Offind sub-procedure\n                      Leave;\n                 Endif;\n\n              Enddo;\n            Other;\n               InsertData();  //Call insertdata sub-procedure\n\n          Endsl;\n          Enddo;\n        End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R SIGN_ONSCN\n \n     A                                      CF07(07 'New User Registration')\n     A                                      CF08(08 'New Vendor Registration')\n     A                                      CF09(09 'Forgot Password')\n     A                                  1 35'SHOW SHOPERS'\n     A                                      COLOR(WHT)\n     A                                  2 29'(TICKET BOOKING SYSTEM)'\n     A                                      COLOR(WHT)\n     A                                  1 67DATE\n     A                                      EDTCDE(Y)\n     A                                  2 67TIME\n     A                                  4 11' __________________________SIGN ON-\n     A                                      __________________________'\n     A                                      COLOR(WHT)\n     A                                  8 12'LOGIN ID.................:'\n     A                                      COLOR(GRN)\n     A                                 10 12'LOGIN PASSWORD...........:'\n     A                                      COLOR(GRN)\n     A            ERRMSG        40A  O 24  2COLOR(WHT)\n     A                                 21  6'          '\n     A                                      COLOR(BLU)\n     A                                 22  2'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 15'F7=New User Registration'\n     A                                      COLOR(BLU)\n     A                                 22 42'F8=New Event Organizer Registratio-\n     A                                      n'\n     A                                      COLOR(BLU)\n     A                                 16 24'*********'\n     A                                      COLOR(WHT)\n     A                                 17 24'IBM i 7.4'\n     A                                      COLOR(WHT)\n     A                                 18 24'*********'\n     A                                      COLOR(WHT)\n     A                                 23  2'F9=Forgot Password'\n     A                                      COLOR(BLU)\n     A            NLGNID         6A  B  8 40\n     A  80                                  DSPATR(RI)\n     A  80                                  DSPATR(PC)\n     A                                      COLOR(GRN)\n     A            NLGNPWD       10A  B 10 40COLOR(TRQ)\n     A  81                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A          R FRGT_PWSCN\nNworg_reg.sqlrpgle:\n        Dcl-f Cstdspf Workstn Indds(Indrds);\n       Dcl-Ds  Indrds;\n           Exit ind pos(3);\n           Prompt Ind pos(4);\n           Refresh Ind Pos(5);\n           Add Ind Pos(6);\n           Cancel Ind Pos(12);\n           OPwd  Ind Pos(60);\n           OCPwd Ind Pos(61);\n           OName Ind Pos(62);\n           OEmail Ind Pos(63);\n           ODOB Ind Pos(64);\n           OState Ind Pos(65);\n           OAddress Ind Pos(66);\n           OAns    Ind Pos(67);\n           OMob Ind Pos(68);\n           OAdharid Ind Pos(69);\n           OGender Ind Pos(70);\n           OQues   Ind Pos(71);\n       End-ds;","output":"This fully-free SQLRPGLE procedure `EventOrgReg` handles the user interactions for an organization registration screen. It includes processing user input, validating fields, prompting for selections, and inserting data.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NWORG_REG_EventOrgReg/output/sum_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"NWORG_REG_EventOrgReg_api","input_data":"        Dcl-Proc EventOrgReg Export;\n           Dow Cancel = *Off;\n            AutoIncId();  //Call Autoincid sub-procedure\n            Exfmt ORG_REGSCN;\n\n\n           Select;\n            When Cancel  = *On;\n              Cancel  = *Off;\n              Clear ORG_REGSCN;\n              OffInd();  //Call Offind sub-procedure\n              Leave;\n\n            When Refresh = *On;\n              Refresh = *Off;\n              Clear ORG_REGSCN;\n              OffInd(); //Call Offind sub-procedure\n\n            When FLD = 'NORGSTATE' AND Prompt = *On;\n                 Prompt  = *Off;\n                 NORGSTATE = PromptDsp();  //Call external promptdsp sub-procedu\n                 ostate  = *Off;\n                 FieldValidation();\n\n            When FLD = 'NORGQUES' And Prompt = *On;\n                 Prompt = *Off;\n                NORGQUES =  PromptQue();  //Call external promptque sub-procedur\n                 OQues  = *Off;\n                FieldValidation();  //Call fieldvalidation sub-procedure\n\n\n            When FLD = 'NORGGNDER' AND Prompt = *On;\n                 Prompt = *Off;\n                 OGender  = *Off;\n                 Clear ErrMsg;\n\n              Dow Cancel = *Off;\n\n                 Exfmt GNDRWNDW  ;\n\n               Select ;\n                 When Gender = 1;\n                      NORGGNDER = 'M';\n\n                 When Gender = 2;\n                      NORGGNDER = 'F';\n\n                 When Gender = 3;\n                      NORGGNDER = 'O';\n               Endsl;\n\n\n                 If Cancel = *On;\n                      Cancel = *Off;\n                      Clear ErrMsg;\n                      OffInd();  //Call Offind sub-procedure\n                      Leave;\n                 Endif;\n\n              Enddo;\n            Other;\n               InsertData();  //Call insertdata sub-procedure\n\n          Endsl;\n          Enddo;\n        End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R SIGN_ONSCN\n \n     A                                      CF07(07 'New User Registration')\n     A                                      CF08(08 'New Vendor Registration')\n     A                                      CF09(09 'Forgot Password')\n     A                                  1 35'SHOW SHOPERS'\n     A                                      COLOR(WHT)\n     A                                  2 29'(TICKET BOOKING SYSTEM)'\n     A                                      COLOR(WHT)\n     A                                  1 67DATE\n     A                                      EDTCDE(Y)\n     A                                  2 67TIME\n     A                                  4 11' __________________________SIGN ON-\n     A                                      __________________________'\n     A                                      COLOR(WHT)\n     A                                  8 12'LOGIN ID.................:'\n     A                                      COLOR(GRN)\n     A                                 10 12'LOGIN PASSWORD...........:'\n     A                                      COLOR(GRN)\n     A            ERRMSG        40A  O 24  2COLOR(WHT)\n     A                                 21  6'          '\n     A                                      COLOR(BLU)\n     A                                 22  2'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 15'F7=New User Registration'\n     A                                      COLOR(BLU)\n     A                                 22 42'F8=New Event Organizer Registratio-\n     A                                      n'\n     A                                      COLOR(BLU)\n     A                                 16 24'*********'\n     A                                      COLOR(WHT)\n     A                                 17 24'IBM i 7.4'\n     A                                      COLOR(WHT)\n     A                                 18 24'*********'\n     A                                      COLOR(WHT)\n     A                                 23  2'F9=Forgot Password'\n     A                                      COLOR(BLU)\n     A            NLGNID         6A  B  8 40\n     A  80                                  DSPATR(RI)\n     A  80                                  DSPATR(PC)\n     A                                      COLOR(GRN)\n     A            NLGNPWD       10A  B 10 40COLOR(TRQ)\n     A  81                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A          R FRGT_PWSCN\nNworg_reg.sqlrpgle:\n        Dcl-f Cstdspf Workstn Indds(Indrds);\n       Dcl-Ds  Indrds;\n           Exit ind pos(3);\n           Prompt Ind pos(4);\n           Refresh Ind Pos(5);\n           Add Ind Pos(6);\n           Cancel Ind Pos(12);\n           OPwd  Ind Pos(60);\n           OCPwd Ind Pos(61);\n           OName Ind Pos(62);\n           OEmail Ind Pos(63);\n           ODOB Ind Pos(64);\n           OState Ind Pos(65);\n           OAddress Ind Pos(66);\n           OAns    Ind Pos(67);\n           OMob Ind Pos(68);\n           OAdharid Ind Pos(69);\n           OGender Ind Pos(70);\n           OQues   Ind Pos(71);\n       End-ds;","output":"## Purpose\n\nThis fully-free SQLRPGLE procedure `EventOrgReg` handles the organization registration screen, allowing users to input details, validate them, and store the information.\n\n## Parameters\n\nNo input or output parameters.\n\n## Dependencies\n\nThe procedure depends on external subroutines for retrieving values\n\n`AutoIncId` - for generating an organization ID.\n`PromptDsp` and `PromptQue` - for retrieving State and Question values.\n`InsertData` - for storing valid registration details.\n\n## Impacts\n\n### Indicators\n\nVarious indicators control screen behavior\n\n| **Indicator**      | **Name**    |  **Description**                                  |\n|--------------------|-------------|---------------------------------------------------|\n| `*IN04`            | `Prompt`    | Opens the gender selection window `GNDRWNDW`      |\n| `*IN05`            | `Refresh`   | Clears and resets the form                        |\n| `*IN12`            | `Cancel`    | Determines if the process should be terminated    |\n| `*IN71`            | `OQues`     | used to control the state of the `NORGQUES` field |\n\n### Global Variables\n\n- `NORGID` - Holds the generated organization ID.\n- `NORGNAME` - Stores the organization name.\n- `NORGSTATE` - Stores the selected state.\n- `NORGQUES` - Holds the selected security question.\n- `NORGGNDER` - Stores the selected gender ('M', 'F', or 'O').\n\n### Dependencies\n- The below subroutines are being used in `EventOrgReg` procedure: \n\n| **Subprocedure** | **Use of Subprocedure** |\n| ---------------- | ----------------------- |\n| `AutoIncId` | Generates a unique organization ID for registration. |\n| `PromptDsp` | Retrieves a list of available states for selection. |\n| `PromptQue` | Provides a list of security questions for the user. |\n| `InsertData` | Stores the registered organization details after validation. |\n| `OffInd`    | Resets indicators after processing. |","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NWORG_REG_EventOrgReg/output/api_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"NWORG_REG_EventOrgReg_how","input_data":"        Dcl-Proc EventOrgReg Export;\n           Dow Cancel = *Off;\n            AutoIncId();  //Call Autoincid sub-procedure\n            Exfmt ORG_REGSCN;\n\n\n           Select;\n            When Cancel  = *On;\n              Cancel  = *Off;\n              Clear ORG_REGSCN;\n              OffInd();  //Call Offind sub-procedure\n              Leave;\n\n            When Refresh = *On;\n              Refresh = *Off;\n              Clear ORG_REGSCN;\n              OffInd(); //Call Offind sub-procedure\n\n            When FLD = 'NORGSTATE' AND Prompt = *On;\n                 Prompt  = *Off;\n                 NORGSTATE = PromptDsp();  //Call external promptdsp sub-procedu\n                 ostate  = *Off;\n                 FieldValidation();\n\n            When FLD = 'NORGQUES' And Prompt = *On;\n                 Prompt = *Off;\n                NORGQUES =  PromptQue();  //Call external promptque sub-procedur\n                 OQues  = *Off;\n                FieldValidation();  //Call fieldvalidation sub-procedure\n\n\n            When FLD = 'NORGGNDER' AND Prompt = *On;\n                 Prompt = *Off;\n                 OGender  = *Off;\n                 Clear ErrMsg;\n\n              Dow Cancel = *Off;\n\n                 Exfmt GNDRWNDW  ;\n\n               Select ;\n                 When Gender = 1;\n                      NORGGNDER = 'M';\n\n                 When Gender = 2;\n                      NORGGNDER = 'F';\n\n                 When Gender = 3;\n                      NORGGNDER = 'O';\n               Endsl;\n\n\n                 If Cancel = *On;\n                      Cancel = *Off;\n                      Clear ErrMsg;\n                      OffInd();  //Call Offind sub-procedure\n                      Leave;\n                 Endif;\n\n              Enddo;\n            Other;\n               InsertData();  //Call insertdata sub-procedure\n\n          Endsl;\n          Enddo;\n        End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R SIGN_ONSCN\n \n     A                                      CF07(07 'New User Registration')\n     A                                      CF08(08 'New Vendor Registration')\n     A                                      CF09(09 'Forgot Password')\n     A                                  1 35'SHOW SHOPERS'\n     A                                      COLOR(WHT)\n     A                                  2 29'(TICKET BOOKING SYSTEM)'\n     A                                      COLOR(WHT)\n     A                                  1 67DATE\n     A                                      EDTCDE(Y)\n     A                                  2 67TIME\n     A                                  4 11' __________________________SIGN ON-\n     A                                      __________________________'\n     A                                      COLOR(WHT)\n     A                                  8 12'LOGIN ID.................:'\n     A                                      COLOR(GRN)\n     A                                 10 12'LOGIN PASSWORD...........:'\n     A                                      COLOR(GRN)\n     A            ERRMSG        40A  O 24  2COLOR(WHT)\n     A                                 21  6'          '\n     A                                      COLOR(BLU)\n     A                                 22  2'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 15'F7=New User Registration'\n     A                                      COLOR(BLU)\n     A                                 22 42'F8=New Event Organizer Registratio-\n     A                                      n'\n     A                                      COLOR(BLU)\n     A                                 16 24'*********'\n     A                                      COLOR(WHT)\n     A                                 17 24'IBM i 7.4'\n     A                                      COLOR(WHT)\n     A                                 18 24'*********'\n     A                                      COLOR(WHT)\n     A                                 23  2'F9=Forgot Password'\n     A                                      COLOR(BLU)\n     A            NLGNID         6A  B  8 40\n     A  80                                  DSPATR(RI)\n     A  80                                  DSPATR(PC)\n     A                                      COLOR(GRN)\n     A            NLGNPWD       10A  B 10 40COLOR(TRQ)\n     A  81                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A          R FRGT_PWSCN\nNworg_reg.sqlrpgle:\n        Dcl-f Cstdspf Workstn Indds(Indrds);\n       Dcl-Ds  Indrds;\n           Exit ind pos(3);\n           Prompt Ind pos(4);\n           Refresh Ind Pos(5);\n           Add Ind Pos(6);\n           Cancel Ind Pos(12);\n           OPwd  Ind Pos(60);\n           OCPwd Ind Pos(61);\n           OName Ind Pos(62);\n           OEmail Ind Pos(63);\n           ODOB Ind Pos(64);\n           OState Ind Pos(65);\n           OAddress Ind Pos(66);\n           OAns    Ind Pos(67);\n           OMob Ind Pos(68);\n           OAdharid Ind Pos(69);\n           OGender Ind Pos(70);\n           OQues   Ind Pos(71);\n       End-ds;","output":"The fully-free SQLRPGLE procedure `EventOrgReg` is an interactive program that handles event organizer registration. It manages user inputs, validates fields, displays selection prompts, and inserts data into the system. The procedure loops until the user decides to cancel.\n\n1. **Procedure Declaration**  \n   ```rpg\n         Dcl-Proc EventOrgReg Export;\n   ```\n   - Declares the procedure `EventOrgReg` and marks it as `Export`, meaning it can be called from other modules or programs.\n\n2. **Main Loop Execution**  \n   ```rpg\n         Dow Cancel = *Off;\n   ```\n   - Enter a loop that continues until `Cancel` is turned *On*.\n\n3. **Auto-Increment ID Generation**  \n   ```rpg\n         AutoIncId();  // Call AutoIncId sub-procedure\n   ```\n   - Calls the `AutoIncId` sub-procedure, likely generating a unique identifier for the event organizer.\n\n4. **Display Registration Screen**  \n   ```rpg\n         Exfmt ORG_REGSCN;\n   ```\n   - Displays the `ORG_REGSCN` screen and waits for user input.\n\n### **Handling Different Cases in the Registration Process**\n1. **Cancel Registration**\n   ```rpg\n         When Cancel = *On;\n         Cancel = *Off;\n         Clear ORG_REGSCN;\n         OffInd();  // Call OffInd sub-procedure\n         Leave;\n   ```\n   - If `Cancel` is *On*:\n     - Reset `Cancel` to *Off*.\n     - Clear the registration screen.\n     - Call `OffInd` sub-procedure (likely resets indicators).\n     - Exit the loop.\n\n2. **Refresh Registration Screen**\n   ```rpg\n            When Refresh = *On;\n            Refresh = *Off;\n            Clear ORG_REGSCN;\n            OffInd(); // Call OffInd sub-procedure\n      ```\n   - If `Refresh` is *On*:\n     - Reset `Refresh` to *Off*.\n     - Clear the registration screen.\n     - Call `OffInd` to reset indicators.\n\n3. **State Selection Prompt**\n   ```rpg\n         When FLD = 'NORGSTATE' AND Prompt = *On;\n         Prompt = *Off;\n         NORGSTATE = PromptDsp();  // Call external PromptDsp sub-procedure\n         OState = *Off;\n         FieldValidation();\n   ```\n   - If the user selects the field `NORGSTATE` and presses the prompt key:\n     - Call `PromptDsp` (likely opens a selection window for states).\n     - Reset `OState` and validate the field using `FieldValidation`.\n\n4. **Security Question Selection Prompt**\n   ```rpg\n         When FLD = 'NORGQUES' And Prompt = *On;\n         Prompt = *Off;\n         NORGQUES = PromptQue();  // Call external PromptQue sub-procedure\n         OQues = *Off;\n         FieldValidation();  // Call FieldValidation sub-procedure\n   ```\n   - If the user selects `NORGQUES` and presses the prompt key:\n     - Call `PromptQue` (likely opens a security question selection window).\n     - Reset `OQues` and validate the field.\n\n5. **Gender Selection Window**\n   ```rpg\n         When FLD = 'NORGGNDER' AND Prompt = *On;\n         Prompt = *Off;\n         OGender = *Off;\n         Clear ErrMsg;\n   ```\n   - If the user selects the gender field `NORGGNDER` and presses the prompt key:\n     - Reset `Prompt` and `OGender`.\n     - Clear any error messages.\n\n   - **Gender Selection Process**\n     ```rpg\n         Dow Cancel = *Off;\n            Exfmt GNDRWNDW;\n     ```\n     - A window `GNDRWNDW` is displayed for gender selection.\n\n     - **User chooses gender:**\n       ```rpg\n            Select;\n               When Gender = 1;\n               NORGGNDER = 'M';\n\n               When Gender = 2;\n               NORGGNDER = 'F';\n\n               When Gender = 3;\n               NORGGNDER = 'O';\n            Endsl;\n       ```\n       - If `Gender = 1`, set `NORGGNDER = 'M'` (Male).\n       - If `Gender = 2`, set `NORGGNDER = 'F'` (Female).\n       - If `Gender = 3`, set `NORGGNDER = 'O'` (Other).\n\n     - **Handle Cancel in Gender Selection**\n       ```rpg\n            If Cancel = *On;\n               Cancel = *Off;\n               Clear ErrMsg;\n               OffInd();  // Call OffInd sub-procedure\n               Leave;\n            Endif;\n       ```\n       - If the user cancels (`Cancel = *On`), reset `Cancel`, clear errors, and reset indicators.\n\n6. **Final Data Insertion**\n   ```rpg\n         Other;\n         InsertData();  // Call InsertData sub-procedure\n   ```\n   - If none of the above conditions match, it calls `InsertData`, which likely saves the registration details to the database.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/NWORG_REG_EventOrgReg/output/how_output.md","task":"explain","difficulty":3,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"STATPROMPTR_Clrsubfile_sum","input_data":"   Dcl-Proc Clrsubfile  ;\n\n       Rrn =0    ;\n       SSflClr = *On ;\n       Write SSFLCTL;\n       SSflClr = *Off  ;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-s Rrn Zoned(4);","output":"This fully-free ILE RPG procedure `Clrsubfile` is to clear subfile `Statesfl` in display file `EheadScrnD.dspf`.\nIt is part of fully-free ILE Rpg module `STATPRMPTR` that allows user to select and return to caller their choice for single state value.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_Clrsubfile/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"STATPROMPTR_Clrsubfile_api","input_data":"   Dcl-Proc Clrsubfile  ;\n\n       Rrn =0    ;\n       SSflClr = *On ;\n       Write SSFLCTL;\n       SSflClr = *Off  ;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-s Rrn Zoned(4);","output":"## Purpose \n\nThis fully-free ILE RPG procedure `Clrsubfile` clears the subfile `Statesfl` in display file `EheadScrnD.dspf` and sets program variable `Rrn` to zero.\n\n## Parameters \nNone \n\n### Global Variables\nThe following Global variables are processed in this procedure.\n\n- `Rrn` - Relative record number of subfile `Statesfl` in display file `EheadScrnD.dspf`. Variable declared in that program of numeric zoned 4 bytes with zero decimals has been initialized to zero. \n\n### Usage example \n\n```Rpgle\n        Clrsubfile(); \n``` \n\n### Dependencies \n\nThe following objects should be found in the library list.\n`EheadScrnD.dspf` is the display file object that is used for screen input/output.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_Clrsubfile/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"STATPROMPTR_Clrsubfile_how","input_data":"   Dcl-Proc Clrsubfile  ;\n\n       Rrn =0    ;\n       SSflClr = *On ;\n       Write SSFLCTL;\n       SSflClr = *Off  ;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-s Rrn Zoned(4);","output":"This fully-free ILE RPG procedure `Clrsubfile` is used to clear the subfile `Statesfl` in display file `EheadScrnD.dspf` and sets relative record number program variable value to zero. \n\n Below are the steps involved.\nRelative record number used in program variable `Rrn` has been initialized to zero.\nNamed Indicator `SSflClr` for Clearing subfile `Statesfl` of display file `EheadScrnD.dspf` has been set On.\nWrite Control record format `SSFLCTL` for subfile `Statesfl` of display file `EheadScrnD.dspf`.\nNamed Indicator `SSflClr` for Clearing subfile `Statesfl` of display file `EheadScrnD.dspf` has been set Off.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_Clrsubfile/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"STATPROMPTR_Dsplysubfile_sum","input_data":"   Dcl-Proc dsplysubfile;\n\n        SSflDsp = *On ;\n        SSflDspCtl = *On ;\n        SSflEnd = *On;\n\n        If Rrn = 0;\n           SSflDsp = *Off;\n        Endif;\n\n        Write STATEFOTER;\n        Exfmt SSFLCTL ;\n  \n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-s Rrn Zoned(4);","output":"This fully-free ILE SQL RPG procedure `DsplySubfile`  displays state records from `STATEPF` in a subfile, managing display indicators and user interaction. If no records exist, it disables the subfile display.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_Dsplysubfile/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"STATPROMPTR_Dsplysubfile_api","input_data":"   Dcl-Proc dsplysubfile;\n\n        SSflDsp = *On ;\n        SSflDspCtl = *On ;\n        SSflEnd = *On;\n\n        If Rrn = 0;\n           SSflDsp = *Off;\n        Endif;\n\n        Write STATEFOTER;\n        Exfmt SSFLCTL ;\n  \n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-s Rrn Zoned(4);","output":"## Purpose\nThe fully-free ILE SQL RPG procedure `DsplySubfile` manages the display of the state selection subfile. It ensures the subfile control format is displayed correctly based on the available records.\n\n## Parameters\nThis procedure does not accept any input and output parameters.\n\n## Database\nNo direct database updates or reads occur within this procedure. The subfile is displayed based on the previously loaded data.\n\n## Dependencies\nDisplay File: EheadscrnD (Contains `SSFLCTL`, `STATEFOTER` and `STATESFL`).\nIndicator Data Structure: `IndDs1` (Contains indicators to control subfile display).\nSubfile Loading Procedure: `Loadsubfile` (Must be called before displaying the subfile).\nSubfile Clearing Procedure: `Clrsubfile` (Should be executed before populating the subfile).\n\n## Error Messages\nEmpty Subfile Message: If no records are loaded (Rrn = 0), the subfile display is turned off.\n\n\n### Global Variables\nIndicators from the  INDDS  data structure `IndDs1`:\n `SSflDsp`  (*IN42)  Controls whether the subfile is displayed.\n `SSflDspCtl`  (*IN43)  Enables the display of the subfile control format.\n `SSflEnd`  (*IN40)  Indicates the end of the subfile.\n\nSubfile Record Number:\n`Rrn`  Stores the relative record number of the subfile. If `Rrn` = 0, the subfile display is disabled.\n\nSubfile Control Format Fields:\n `STATEFOTER`   Footer format for additional screen information.\nBehavior\nThe subfile display is turned on (`SSflDsp` = *On) if records exist (Rrn > 0). Otherwise it remains off.\nThe subfile control format is written to the display file using the Write  `STATEFOTER`  operation.\nThe  `Exfmt`  `SSFLCTL`  operation is executed to display the subfile and wait for user input.\n\n## Usage Example\nCall the  `DsplySubfile` procedure after loading the subfile to display the available state records.\n\n```rpgle\nDsplySubfile();\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_Dsplysubfile/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"STATPROMPTR_Dsplysubfile_how","input_data":"   Dcl-Proc dsplysubfile;\n\n        SSflDsp = *On ;\n        SSflDspCtl = *On ;\n        SSflEnd = *On;\n\n        If Rrn = 0;\n           SSflDsp = *Off;\n        Endif;\n\n        Write STATEFOTER;\n        Exfmt SSFLCTL ;\n  \n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-s Rrn Zoned(4);","output":"The fully-free ILE SQL RPG procedure `Dsplysubfile`  is responsible for displaying the state selection subfile in the display file EheadscrnD. \n\n```rpgle\n    Dcl-Proc dsplysubfile;\n```\n\n- Declares the `Dsplysubfile` procedure.\n- It does not take any parameters and is expected to update the display-related indicators.\n\nSetting Display Indicators  \n\n```rpgle\n    SSflDsp = On ;\n    SSflDspCtl = On ;\n    SSflEnd = On;\n```\n\n- `SSflDsp = On` - Turns on the subfile display, allowing records in the subfile to be visible.\n- `SSflDspCtl = On` - Turns on the subfile control format, ensuring subfile controls (paging, scrolling, etc.) are active.\n- `SSflEnd = On` - Marks the end of the subfile, typically used for subfile handling to indicate the last page or no more records to load.\n\nChecking if Subfile is Empty  \n\n```rpgle\n    If Rrn = 0;\n    SSflDsp = Off;\n    Endif;\n```\n\n- `Rrn` (Relative Record Number) represents the number of records in the subfile.\n- If `Rrn = 0`, it means the subfile is empty, so the program turns off `SSflDsp` to hide the subfile from the user.\n- This ensures that an empty subfile is not displayed, preventing confusion.\n\nDisplaying Footer and Showing Screen  \n\n```rpgle\n    Write STATEFOTER;\n    Exfmt SSFLCTL;\n```\n\n- `Write STATEFOTER` - Writes the footer format of the display file (likely containing status messages, instructions or additional info).\n- `Exfmt SSFLCTL`  -\n  - Writes and displays the subfile control format (`SSFLCTL`) to the user.\n  - Waits for user input before proceeding.\n  - Allows users to select, scroll or navigate through the subfile.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_Dsplysubfile/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"STATPROMPTR_StatePrompt_sum","input_data":"   Dcl-Proc StatePrompt Export;\n       Dcl-Pi StatePrompt Char(15);\n         p_State Char(15);\n       End-Pi;\n\n       Dow Cancel = *Off ;\n           Clrsubfile();\n           Loadsubfile();\n           Dsplysubfile();\n\n          //Get state value\n           Select ;\n              When Cancel = *On;\n                   Cancel = *Off;\n                   If P_State = *Blanks;\n                      StateVar = *Blanks;\n                      Return StateVar;\n                   Else;\n                      StateVar = p_State;\n                      Return StateVar;\n                   EndIf;\n\n             Other;\n\n               Readc STATESFL;\n               Dow Not %EOF();\n\n                Select ;\n\n                 When SOpt = 1;\n                 Clear SOpt ;\n                 Return SSTATE   ;\n\n                Other ;\n                 Clear SOpt ;\n\n                EndSl;\n\n                 ReadC STATESFL;\n\n               EndDo;\n           EndSl;\n\n       EndDo;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-S StateVar Char(15);","output":"This fully-free SQLRPGLE procedure `StatePrompt` helps users pick a state from a list. It keeps showing the options until the user selects one or cancels. If canceled, it either returns an empty value or the last selected state.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_StatePrompt/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"sum"}}
{"id":"STATPROMPTR_StatePrompt_api","input_data":"   Dcl-Proc StatePrompt Export;\n       Dcl-Pi StatePrompt Char(15);\n         p_State Char(15);\n       End-Pi;\n\n       Dow Cancel = *Off ;\n           Clrsubfile();\n           Loadsubfile();\n           Dsplysubfile();\n\n          //Get state value\n           Select ;\n              When Cancel = *On;\n                   Cancel = *Off;\n                   If P_State = *Blanks;\n                      StateVar = *Blanks;\n                      Return StateVar;\n                   Else;\n                      StateVar = p_State;\n                      Return StateVar;\n                   EndIf;\n\n             Other;\n\n               Readc STATESFL;\n               Dow Not %EOF();\n\n                Select ;\n\n                 When SOpt = 1;\n                 Clear SOpt ;\n                 Return SSTATE   ;\n\n                Other ;\n                 Clear SOpt ;\n\n                EndSl;\n\n                 ReadC STATESFL;\n\n               EndDo;\n           EndSl;\n\n       EndDo;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-S StateVar Char(15);","output":"## Purpose\n\nThe fully-free SQLRPGLE procedure `StatePrompt` is used to prompt the user to select a state from a predefined list. The procedure keeps displaying the list until a valid selection is made or the user cancels the selection. If canceled, it either returns a blank value or the previously selected state.\n\n## Parameters\n\n| Parameter Name | Type | Length | Input/Output | Description |\n|---------------|----------|--------|--------------|------------------------------------|\n| `p_State` | Character | 15 | Input | Holds the initially selected state (if any) |\n| `Statevar` | Character | 15| Output | The selected state value or blank if no selection is made. |\n\n## Impacts\n\n### Global Variables Used\n\n| Variable Name | Datatype | Length | Description |\n|--------------|----------|--------|-------------|\n| `SSTATE`     | Character | 15 | Holds the state value selected from the subfile |\n\n## Dependencies\n\n### Indicators Used\n\n| Indicator Name | Datatype | Indicator Number | Purpose in the Procedure |\n|-------------------|-------------|--------------------------|------------------------------|\n| `Cancel` | Indicator | *IN12 | Used to check if the user wants to exit the prompt and reset if needed. |\n\n### Database\n\n| File Name | Type  | Purpose |\n|-----------|------|---------|\n| `STATESFL` | Subfile | Stores the list of available states for selection |\n\n**Usage Example**: To call the `StatePrompt` procedure inside an RPG program, it can be done as follows:\n```rpgle\n        SelectedState = StatePrompt('Texas');  \n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_StatePrompt/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"api"}}
{"id":"STATPROMPTR_StatePrompt_how","input_data":"   Dcl-Proc StatePrompt Export;\n       Dcl-Pi StatePrompt Char(15);\n         p_State Char(15);\n       End-Pi;\n\n       Dow Cancel = *Off ;\n           Clrsubfile();\n           Loadsubfile();\n           Dsplysubfile();\n\n          //Get state value\n           Select ;\n              When Cancel = *On;\n                   Cancel = *Off;\n                   If P_State = *Blanks;\n                      StateVar = *Blanks;\n                      Return StateVar;\n                   Else;\n                      StateVar = p_State;\n                      Return StateVar;\n                   EndIf;\n\n             Other;\n\n               Readc STATESFL;\n               Dow Not %EOF();\n\n                Select ;\n\n                 When SOpt = 1;\n                 Clear SOpt ;\n                 Return SSTATE   ;\n\n                Other ;\n                 Clear SOpt ;\n\n                EndSl;\n\n                 ReadC STATESFL;\n\n               EndDo;\n           EndSl;\n\n       EndDo;\n\n   End-Proc;","context":"\n     A                                      DSPSIZ(24 80 *DS3)\n     A                                      INDARA\n     A                                      CF03(03 'Exit')\n     A                                      CF12(12 'Cancel')\n     A                                      CF05(05 'Refresh')\n     A          R LOGINSCRN\n   \n     A                                      CF07(07 'NewCst')\n     A                                      CF08(08 'NewVndr')\n     A                                      CF04(04 'FgPass')\n     A                                  1 21'Inventory Management and Electric -\n     A                                      Store'\n     A                                      COLOR(WHT)\n     A                                  1 62'Date:'\n     A                                  2 34'Electric Head'\n     A                                      COLOR(WHT)\n     A                                  2 62'Time:'\n     A                                  3  2'__________________________________-\n     A                                      Sign On____________________________-\n     A                                      _________'\n     A                                      COLOR(TRQ)\n     A                                  8 20'LoginId . :'\n     A                                      COLOR(WHT)\n     A                                 10 20'Password. :'\n     A                                      COLOR(WHT)\n     A            LGINID         6A  B  8 32\n     A  25                                  DSPATR(RI)\n     A  25                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                 22  2'F3=Exit'\n     A                                      COLOR(BLU)\n     A                                 22 13'F4=Forget Password'\n     A                                      COLOR(BLU)\n     A                                 22 37'F5=Refresh'\n     A                                      COLOR(BLU)\n     A                                 22 52'F7=New Customer Registration'\n     A                                      COLOR(BLU)\n     A                                 23  2'F8=New Vendor Registration'\n     A                                      COLOR(BLU)\n     A            LGERROR       70A  O 24  2COLOR(WHT)\n     A            LGPASS        10A  B 10 32\n     A  26                                  DSPATR(RI)\n     A  26                                  DSPATR(PC)\n     A                                      CHECK(LC)\n     A                                      DSPATR(ND)\n     A                                  1 68DATE\n     A                                      EDTCDE(Y)\n     A                                  2 68TIME\n     A          R NEWCSTREG\nStatPrmptR.sqlrpgle:\n   Dcl-F EheadscrnD Workstn Indds(Indds1) Sfile(STATESFL:rrn);\n   Dcl-Ds IndDs1;\n\n     Cancel     Ind Pos(12);\n     SSflEnd    Ind Pos(40);\n     SSflClr    Ind Pos(41);\n     SSflDsp    Ind Pos(42);\n     SSflDspCtl Ind Pos(43);\n\n   End-Ds;\n   Dcl-S StateVar Char(15);","output":"The fully-free SQLRPGLE procedure `StatePrompt` is designed to allow a user to select a state from a list. It continuously displays the available states until the user selects one or cancels the selection.\n\n## Explanation\n\n### 1. Procedure Declaration\n```rpgle\n      Dcl-Proc StatePrompt Export;\n```\n- `Dcl-Proc StatePrompt Export;`:  Declares the procedure `StatePrompt` and makes it available for use outside this module (`Export` keyword).\n\n### 2. Procedure Interface (Parameters)\n```rpgle\n      Dcl-Pi StatePrompt Char(15);\n         p_State Char(15);\n      End-Pi;\n```\n- Procedure Interface (`Dcl-Pi`): Defines the parameter the procedure will receive.\n- `p_State Char(15);`: Input parameter, The selected state value (15-character string).\n- Return Value (`Char(15)`): The procedure returns a 15-character state name.\n\n### 3. Main Loop: Keeps running until Cancel\n```rpgle\n      Dow Cancel = *Off ;\n```\n- `Dow Cancel = *Off`: A loop that runs until the `Cancel` indicator is turned *on*.\n\n#### Clear and Load the Subfile\n```rpgle\n      Clrsubfile();\n      Loadsubfile();\n      Dsplysubfile();\n```\n- `Clrsubfile`: Clears the state selection subfile (UI list).\n- `Loadsubfile`: Loads the state names into the subfile for display.\n- `Dsplysubfile`: Displays the subfile to the user.\n\n### 4. Handling User Selection\n```rpgle\n      // Get state value\n      Select;\n         When Cancel = *On;\n```\n- If the user cancels (`Cancel = *On`):\n  ```rpgle\n      Cancel = *Off;\n      If P_State = *Blanks;\n         StateVar = *Blanks;\n         Return StateVar;\n      Else;\n         StateVar = p_State;\n         Return StateVar;\n      EndIf;\n  ```\n- If no state is selected (`P_State = *Blanks`) return an empty value.\n- If a state was previously selected, return that state.\n\n### 5. Handling State Selection from Subfile\n```rpgle\n      Other;\n         Readc STATESFL;\n         Dow Not %EOF();\n```\n- `Readc STATESFL;`: Reads a record from the `STATESFL` subfile.\n- `Dow Not %EOF();`: Loops through the records until the end of the file.\n\n#### Checking Selected Option\n```rpgle\nSelect;\n   When SOpt = 1;\n      Clear SOpt;\n      Return SSTATE;\n   Other;\n      Clear SOpt;\nEndSl;\n```\n- If `SOpt = 1` (user selected a state):\n  - Clear the selection (`Clear SOpt;`).\n  - Return the selected state (`SSTATE`).\n- Otherwise, just clear the selection.\n\n### 6. Continue Reading the Subfile\n```rpgle\n      ReadC STATESFL;\n      EndDo;\n      EndSl;\n```\n- Moves to the next record and continues the loop.\n\n### 7. End of the Main Loop\n```rpgle\n      EndDo;\n      End-Proc;\n```\n- The loop (`Dow Cancel = *Off;`) keeps running until the user selects a state or cancels.\n- The procedure ends and returns the selected state.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/Programmers.io/STATPROMPTR_StatePrompt/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff-sql","scope":"proc","depth":"how"}}
{"id":"0d51a01ad9d-subr-BuyerSr_sum","input_data":"**free\nBEGSR BuyerSr;\n  if FirstTime = 'Y';\n    LandTax = 0;\n  else;\n    LandTax = LANDTAXR(HousePrice);\n  endif;\n\n  Commission = HousePrice * (AgentRate / 100);\n\n  TotalCost = LegalFees + SurveyFee + TitleIns + Inspection;\n  buyer = HousePrice + TotalCost + LandTax;\n\n  if TotalCost < 1000;\n    *IN99 = *ON;\n  ENDIF;\nENDSR;","context":"","output":"The fully-free Rpgle subroutine `BuyerSR` computes how much the buyer has to pay in a real estate transaction.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/0d51a01ad9d-subr-BuyerSr/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"sum"}}
{"id":"0d51a01ad9d-subr-BuyerSr_api","input_data":"**free\nBEGSR BuyerSr;\n  if FirstTime = 'Y';\n    LandTax = 0;\n  else;\n    LandTax = LANDTAXR(HousePrice);\n  endif;\n\n  Commission = HousePrice * (AgentRate / 100);\n\n  TotalCost = LegalFees + SurveyFee + TitleIns + Inspection;\n  buyer = HousePrice + TotalCost + LandTax;\n\n  if TotalCost < 1000;\n    *IN99 = *ON;\n  ENDIF;\nENDSR;","context":"","output":"## Purpose\n\nThis fully free format RPGLE subroutine `BuyerSR` computes how much the buyer has to pay in a real estate transaction.\n\n### Input\n\nThese globals are used as input to the subroutine\n\n- `FirstTime` - 'Y' indicates that the buyer is a first-time buyer.\n- `HousePrice` - how much the house is selling for\n- `AgentRate` - what percentage of the house price is paid to the real-estate agent as a commission\n- `LegalFees` - legal fees involved in this transaction\n- `SurveyFee` - additional fee for the land survey\n- `TitleIns` - cost of title insurance\n- `Inspection` - cost of house inspection\n- `LandTax` - cost of land transfer tax\n\n## Output\n\nThe following global variables are computed by the subroutine\n\n- `LandTax` - How much land tax is charged given the price of the house, if this a first-time buyer, the tax due will be '0'.\n- `Commission` - How much is the real estate agent's commission\n- `TotalCost` - All additional costs of the transaction besides the land transfer tax.\n- `buyer` - the total amoun that the buyer needs to pay\n- *IN99 - will be turned on if the `TotalCost` is less than $1,000\n\n## Dependencies\n\n- `LANDTAXR` - External Function that computes the land tax given the house price","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/0d51a01ad9d-subr-BuyerSr/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"api"}}
{"id":"0d51a01ad9d-subr-BuyerSr_how","input_data":"**free\nBEGSR BuyerSr;\n  if FirstTime = 'Y';\n    LandTax = 0;\n  else;\n    LandTax = LANDTAXR(HousePrice);\n  endif;\n\n  Commission = HousePrice * (AgentRate / 100);\n\n  TotalCost = LegalFees + SurveyFee + TitleIns + Inspection;\n  buyer = HousePrice + TotalCost + LandTax;\n\n  if TotalCost < 1000;\n    *IN99 = *ON;\n  ENDIF;\nENDSR;","context":"","output":"The fully free Rpgle subroutine `BuyerSR` computes how much the buyer has to pay in a real estate transaction.\n\n```rpg\n  if FirstTime = 'Y';\n    LandTax = 0;\n  else;\n    LandTax = LANDTAXR(HousePrice);\n  endif;\n```\n\nThe `LandTax` is set to 0 if this is a first-time home buyer. Otherwise the `LANDTAXR` procedure is called to compute the land transfer tax give the house price.\n\n```rpg\n  Commission = HousePrice * (AgentRate / 100);\n```\n\nThe commission is computed base on the rate the Real Estate agent charges.\n\n```rpg\n  TotalCost = LegalFees + SurveyFee + TitleIns + Inspection;\n  buyer = HousePrice + TotalCost + LandTax;\n```\nThe`TotalCost` is the sum of all additional costs of the transaction includinging legal fees, land survey, title insurance and house inspection.\nTHe `buyer` is the total buyer has to pay, which is all of the above plus the house prices and land transfer tax.\n\n```rpg\n  if TotalCost < 1000;\n    *IN99 = *ON;\n  ENDIF;\n```\n\n*IN99 will be turned on if the `TotalCost` is less than $1,000.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/0d51a01ad9d-subr-BuyerSr/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"how"}}
{"id":"0d84648e8c03cd6442c63b32aad9145fb52e4955_sum","input_data":"**FREE\n\n/if defined(*CRTBNDRPG)\n ctl-opt dftactgrp(*no)\n         actgrp(*new);\n/endif\nctl-opt main(divise);\n\ndcl-proc divise;\n    dcl-pi *N;\n        pDividende int(5) const;\n        pDiviseur int(5) const;\n        pQuotient  zoned(7:2);\n    end-pi;\n    dcl-s lZone char(10);\n    \n    clear pQuotient;\n    \n    clear lZone;\n    select;\n    when pDividende = *zeros;\n       lZone = 'Dividende'; \n       snd-msg *escape %msg('USR0001':'YABUG':%trim(lZone))  \n            %TARGET(*CALLER:1); \n    when pDiviseur > 12;\n       lZone = 'Diviseur'; \n       snd-msg *escape %msg('USR0002':'YABUG':%trim(lZone)) \n            %TARGET(*CALLER:1); \n    endsl;\n    \n    monitor;\n        pQuotient = pDividende / pDiviseur;\n    on-error;\n        snd-msg *escape %msg('ERR0001':'YABUG':%trim(%proc()))\n            %TARGET(*CALLER:1); \n    endmon;\n    return;\nend-proc;","context":"","output":"This fully free-format calculates the quotient of two integers provided as parameters with error checking.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/0d84648e8c03cd6442c63b32aad9145fb52e4955/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"sum"}}
{"id":"0d84648e8c03cd6442c63b32aad9145fb52e4955_api","input_data":"**FREE\n\n/if defined(*CRTBNDRPG)\n ctl-opt dftactgrp(*no)\n         actgrp(*new);\n/endif\nctl-opt main(divise);\n\ndcl-proc divise;\n    dcl-pi *N;\n        pDividende int(5) const;\n        pDiviseur int(5) const;\n        pQuotient  zoned(7:2);\n    end-pi;\n    dcl-s lZone char(10);\n    \n    clear pQuotient;\n    \n    clear lZone;\n    select;\n    when pDividende = *zeros;\n       lZone = 'Dividende'; \n       snd-msg *escape %msg('USR0001':'YABUG':%trim(lZone))  \n            %TARGET(*CALLER:1); \n    when pDiviseur > 12;\n       lZone = 'Diviseur'; \n       snd-msg *escape %msg('USR0002':'YABUG':%trim(lZone)) \n            %TARGET(*CALLER:1); \n    endsl;\n    \n    monitor;\n        pQuotient = pDividende / pDiviseur;\n    on-error;\n        snd-msg *escape %msg('ERR0001':'YABUG':%trim(%proc()))\n            %TARGET(*CALLER:1); \n    endmon;\n    return;\nend-proc;","context":"","output":"This fully free-format calculates the quotient of two integers provided as parameters with error checking.\n\nThe first parameter `pDividende` is the read-only 5 digit integer parameter to be divided.\nThe second parameter `pDiviseur` is the read-only 5 digit integer parameter that the `pDividende` is divided by.\nThe third parameter `pQuotient` of type zoned decimal with a precision of 7,2 will contain resultant quotient or 0 if there is an error.\n\nThe possible error responses are:\n\n1. If `pDividende` is zero, an escape message (with the message id 'USR0001'  from message file 'YABUG' with substitution 'Dividende') us sent to the caller.\n\n2. If `pDiviseur` is greater than 12, an escape message indicating a user error (with the message id 'USR0002' from message file 'YABUG' with substitution 'Diviseur') is sent to the caller.\n\n3. If an error occurs during the division operation, an escape message with the message id 'ERR0001' from message file 'YABUG', is sent to the caller.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/0d84648e8c03cd6442c63b32aad9145fb52e4955/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"api"}}
{"id":"0d84648e8c03cd6442c63b32aad9145fb52e4955_how","input_data":"**FREE\n\n/if defined(*CRTBNDRPG)\n ctl-opt dftactgrp(*no)\n         actgrp(*new);\n/endif\nctl-opt main(divise);\n\ndcl-proc divise;\n    dcl-pi *N;\n        pDividende int(5) const;\n        pDiviseur int(5) const;\n        pQuotient  zoned(7:2);\n    end-pi;\n    dcl-s lZone char(10);\n    \n    clear pQuotient;\n    \n    clear lZone;\n    select;\n    when pDividende = *zeros;\n       lZone = 'Dividende'; \n       snd-msg *escape %msg('USR0001':'YABUG':%trim(lZone))  \n            %TARGET(*CALLER:1); \n    when pDiviseur > 12;\n       lZone = 'Diviseur'; \n       snd-msg *escape %msg('USR0002':'YABUG':%trim(lZone)) \n            %TARGET(*CALLER:1); \n    endsl;\n    \n    monitor;\n        pQuotient = pDividende / pDiviseur;\n    on-error;\n        snd-msg *escape %msg('ERR0001':'YABUG':%trim(%proc()))\n            %TARGET(*CALLER:1); \n    endmon;\n    return;\nend-proc;","context":"","output":"This fully free-format calculates the quotient of two integers provided as parameters with error checking.\n\n```rpg\n/if defined(*CRTBNDRPG)\n ctl-opt dftactgrp(*no)\n         actgrp(*new);\n/endif\n```\n\nIf the program is compiled using `*CRTBNDRPG`, it is set to run in its own activation group (a new one created for each call) instead of the default activation group.\n\n```rpg\nctl-opt main(divise);\ndcl-proc divise;\n    dcl-pi *N;\n        pDividende int(5) const;\n        pDiviseur int(5) const;\n        pQuotient  zoned(7:2);\n    end-pi;\n```\n\nThe main procedure named `divise` has a prototype which accepts two read-only integer parameters `pDividende` and `pDiviseur` to be used in the calculation, and an output parameter `pQuotient` of type zoned decimal with a precision of 7,2 for the resultant quotient.\n\n```rpg\n  clear pQuotient;\n```\n\nAt the beginning of the main procedure, the output variable `pQuotient` is cleared (set to its initial value). \n\n```rpg\n    select;\n    when pDividende = *zeros;\n       lZone = 'Dividende'; \n       snd-msg *escape %msg('USR0001':'YABUG':%trim(lZone))  \n            %TARGET(*CALLER:1); \n    when pDiviseur > 12;\n       lZone = 'Diviseur'; \n       snd-msg *escape %msg('USR0002':'YABUG':%trim(lZone)) \n            %TARGET(*CALLER:1); \n    endsl;\n```\n\nThe program then proceeds to a selection structure to perform error checking:\n\n1. If `pDividende` is zero, it sets a local variable `lZone` to the literal 'Dividende' and sends an escape message indicating a user error (with the message id 'USR0001' from message file 'YABUG') to the caller.\n\n2. If `pDiviseur` is greater than 12, it sets `lZone` to the literal 'Diviseur' and sends a different escape message indicating a user error (with the message id 'USR0002' from message file 'YABUG') to the caller.\n\n```rpg\n    monitor;\n        pQuotient = pDividende / pDiviseur;\n    on-error;\n        snd-msg *escape %msg('ERR0001':'YABUG':%trim(%proc()))\n            %TARGET(*CALLER:1); \n    endmon;\n```\n\nAfter error checking, the program enters a `monitor` block to execute the division. Within this block, `pQuotient` is calculated by dividing `pDividende` by `pDiviseur`. If an error occurs during the division operation, an `on-error` block catches it and sends an escape message with the message id 'ERR0001' from message file 'YABUG', again to the caller.\n\n```rpg\n    return;\nend-proc;\n```\n\nLastly, the procedure returns control back to the caller, presumably passing back the calculated `pQuotient` if no errors occurred.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/0d84648e8c03cd6442c63b32aad9145fb52e4955/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"file","depth":"how"}}
{"id":"4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_Clear_sum","input_data":"BEGSR CLEAR;\n  *IN95 = *OFF;\n  CLEAR GENDER;\n  *IN96 = *OFF;\n  CLEAR CVDISEASE;\n  *IN97 = *OFF;\n  CLEAR DIABETES;\n  *IN98 = *OFF;\n  CLEAR RSPDISEASE;\n  *IN99 = *OFF;\n  CLEAR HBPRESSURE;\n  *IN60 = *OFF;\nENDSR;","context":"","output":"This free-format ILE Rpg subroutine `CLEAR` is used to *switch off screen fields indicators* and to clear \nscreen fields (`GENDER, CVDISEASE, DIABETES, RSPDISEASE, HBPRESSURE`).","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_Clear/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"sum"}}
{"id":"4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_Clear_api","input_data":"BEGSR CLEAR;\n  *IN95 = *OFF;\n  CLEAR GENDER;\n  *IN96 = *OFF;\n  CLEAR CVDISEASE;\n  *IN97 = *OFF;\n  CLEAR DIABETES;\n  *IN98 = *OFF;\n  CLEAR RSPDISEASE;\n  *IN99 = *OFF;\n  CLEAR HBPRESSURE;\n  *IN60 = *OFF;\nENDSR;","context":"","output":"## Purpose\nThis free-format ILE Rpg subroutine `CLEAR` is used to *switch off screen fields indicators* and clear \nscreen fields.\n\n## Parameters\nNone \n\n### Input\nNone\n\n## Output\n\n### Global variables \n\nThe following global variables/indicators are computed by this subroutine\n\n- Screen fields `GENDER,CVDISEASE,DIABETES,RSPDISEASE and HBPRESSURE` were cleared.\n\n| Indicator number | DSPF field turned Off | \n|----------------- |---------------------- |\n|`95`              | GENDER                |\n|`96`              | CVDISEASE             |\n|`97`              | DIABETES              |\n|`98`              | RSPDISEASE            |\n|`99`              | HBPRESSURE            |\n\n- followed by indicator `60` - will be turned off.\n\n## Dependencies\n\nThe below mentioned objects needed to be in the library list.\n`COVIDDSP` is display file used for input/output\n`COVIDINFO` is display file used for input/output","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_Clear/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"api"}}
{"id":"4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_Clear_how","input_data":"BEGSR CLEAR;\n  *IN95 = *OFF;\n  CLEAR GENDER;\n  *IN96 = *OFF;\n  CLEAR CVDISEASE;\n  *IN97 = *OFF;\n  CLEAR DIABETES;\n  *IN98 = *OFF;\n  CLEAR RSPDISEASE;\n  *IN99 = *OFF;\n  CLEAR HBPRESSURE;\n  *IN60 = *OFF;\nENDSR;","context":"","output":"This free-format ILE Rpg subroutine `CLEAR` is used to *switch off screen fields indicators* and clear \nscreen fields (`GENDER, CVDISEASE, DIABETES, RSPDISEASE, HBPRESSURE`).\n\nThis program declares two display files: COVIDDSP and COVIDINFO, which are presumably used to input and output data on the workstation.\n\n```Rpgle \n    BEGSR CLEAR;\n      *IN95 = *OFF;\n      CLEAR GENDER;\n      *IN96 = *OFF;\n      CLEAR CVDISEASE;\n      *IN97 = *OFF;\n      CLEAR DIABETES;\n      *IN98 = *OFF;\n      CLEAR RSPDISEASE;\n      *IN99 = *OFF;\n      CLEAR HBPRESSURE;\n      *IN60 = *OFF;\n    ENDSR;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_Clear/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"how"}}
{"id":"4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_DETERMINERISK_sum","input_data":"BEGSR DETERMINERISK;\n\n  AGE = %DIFF(%DATE():BIRTHDATE:*Y);\n\n  AGE = AGE;\n\n  SELECT;\n    WHEN AGE >= 80 AND AGE <= 999;\n      FRATE = 14.8;\n    WHEN AGE >= 70;\n      FRATE = 8;\n    WHEN AGE >= 60;\n      FRATE = 3.6;\n    WHEN AGE >= 50;\n      FRATE = 1.3;\n    WHEN AGE >= 40;\n      FRATE = .4;\n    WHEN AGE >= 30;\n      FRATE = .25;\n    WHEN AGE >= 20;\n      FRATE = .23;\n    WHEN AGE >= 10;\n      FRATE = .2;\n    WHEN AGE >= 0;\n      FRATE = .1;\n\n  ENDSL;\n\n  SELECT;\n    WHEN CVDISEASE = 'Y';\n      FRATE += .8;\n  ENDSL;\n  \n  SELECT;\n    WHEN DIABETES = 'Y';\n      FRATE += .6;\n  ENDSL;\n  \n  SELECT;\n    WHEN HBPRESSURE = 'Y';\n      FRATE += .3;\n  ENDSL;\n  \n  SELECT;\n    WHEN RSPDISEASE = 'Y';\n      FRATE += .4;\n  ENDSL;\n  \n  SELECT;\n    WHEN GENDER = 'F';\n      FRATE -= .05;\n  ENDSL;\n\n  FRATE = FRATE;\n\n  SELECT;\n    WHEN FRATE >= 9.5;\n      COHORT = 'Group 1';\n    WHEN FRATE >= 5.5;\n      COHORT = 'Group 2';\n    WHEN FRATE >= 3.5;\n      COHORT = 'Group 3';\n    WHEN FRATE >= 1.5;\n      COHORT = 'Group 4';\n    WHEN FRATE >= 0.0;\n      COHORT = 'Group 5';\n  ENDSL;\n\n  COHORT = COHORT;\nENDSR;","context":"","output":"This fully-free ILE RPG subroutine `DETERMINERISK` evaluates a person's health risk based on their age, medical conditions, and gender, then assigns them to a risk group.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_DETERMINERISK/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"sum"}}
{"id":"4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_DETERMINERISK_api","input_data":"BEGSR DETERMINERISK;\n\n  AGE = %DIFF(%DATE():BIRTHDATE:*Y);\n\n  AGE = AGE;\n\n  SELECT;\n    WHEN AGE >= 80 AND AGE <= 999;\n      FRATE = 14.8;\n    WHEN AGE >= 70;\n      FRATE = 8;\n    WHEN AGE >= 60;\n      FRATE = 3.6;\n    WHEN AGE >= 50;\n      FRATE = 1.3;\n    WHEN AGE >= 40;\n      FRATE = .4;\n    WHEN AGE >= 30;\n      FRATE = .25;\n    WHEN AGE >= 20;\n      FRATE = .23;\n    WHEN AGE >= 10;\n      FRATE = .2;\n    WHEN AGE >= 0;\n      FRATE = .1;\n\n  ENDSL;\n\n  SELECT;\n    WHEN CVDISEASE = 'Y';\n      FRATE += .8;\n  ENDSL;\n  \n  SELECT;\n    WHEN DIABETES = 'Y';\n      FRATE += .6;\n  ENDSL;\n  \n  SELECT;\n    WHEN HBPRESSURE = 'Y';\n      FRATE += .3;\n  ENDSL;\n  \n  SELECT;\n    WHEN RSPDISEASE = 'Y';\n      FRATE += .4;\n  ENDSL;\n  \n  SELECT;\n    WHEN GENDER = 'F';\n      FRATE -= .05;\n  ENDSL;\n\n  FRATE = FRATE;\n\n  SELECT;\n    WHEN FRATE >= 9.5;\n      COHORT = 'Group 1';\n    WHEN FRATE >= 5.5;\n      COHORT = 'Group 2';\n    WHEN FRATE >= 3.5;\n      COHORT = 'Group 3';\n    WHEN FRATE >= 1.5;\n      COHORT = 'Group 4';\n    WHEN FRATE >= 0.0;\n      COHORT = 'Group 5';\n  ENDSL;\n\n  COHORT = COHORT;\nENDSR;","context":"","output":"## Purpose\n\nThis fully-free ILE Rpg `DETERMINERISK` subroutine calculates a risk factor `FRATE` based on a person's age, medical conditions, and gender. It then categorizes the individual into a risk group `COHORT` for health assessment purposes.\n\n## Parameters\n\n### Input Parameters  \n\n- `BIRTHDATE`  The person's date of birth (used to calculate age).  \n- `CVDISEASE`  Indicator (`'Y'` or `'N'`) for cardiovascular disease.  \n- `DIABETES`  Indicator (`'Y'` or `'N'`) for diabetes.  \n- `HBPRESSURE`  Indicator (`'Y'` or `'N'`) for high blood pressure.  \n- `RSPDISEASE`  Indicator (`'Y'` or `'N'`) for respiratory disease.  \n- `GENDER`  The person's gender (`'M'` or `'F'`).  \n\n### Output Parameters  \n\n- `FRATE`  The calculated risk factor based on age and medical conditions.  \n- `COHORT`  The assigned risk category (Group 1 to Group 5).  \n\n## Database \n\n- No direct database modifications occur in this subroutine.  \n- The subroutine only calculates risk factors and assigns a category.  \n\n## Global Variables  \n\n- `FRATE`  Used to store the calculated risk factor.  \n- `COHORT`  Used to store the assigned risk category.  \n- `AGE`  Stores the calculated age based on `BIRTHDATE`.  \n- Other medical condition indicators (`CVDISEASE`, `DIABETES`, etc.) are accessed as input but not modified.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_DETERMINERISK/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"api"}}
{"id":"4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_DETERMINERISK_how","input_data":"BEGSR DETERMINERISK;\n\n  AGE = %DIFF(%DATE():BIRTHDATE:*Y);\n\n  AGE = AGE;\n\n  SELECT;\n    WHEN AGE >= 80 AND AGE <= 999;\n      FRATE = 14.8;\n    WHEN AGE >= 70;\n      FRATE = 8;\n    WHEN AGE >= 60;\n      FRATE = 3.6;\n    WHEN AGE >= 50;\n      FRATE = 1.3;\n    WHEN AGE >= 40;\n      FRATE = .4;\n    WHEN AGE >= 30;\n      FRATE = .25;\n    WHEN AGE >= 20;\n      FRATE = .23;\n    WHEN AGE >= 10;\n      FRATE = .2;\n    WHEN AGE >= 0;\n      FRATE = .1;\n\n  ENDSL;\n\n  SELECT;\n    WHEN CVDISEASE = 'Y';\n      FRATE += .8;\n  ENDSL;\n  \n  SELECT;\n    WHEN DIABETES = 'Y';\n      FRATE += .6;\n  ENDSL;\n  \n  SELECT;\n    WHEN HBPRESSURE = 'Y';\n      FRATE += .3;\n  ENDSL;\n  \n  SELECT;\n    WHEN RSPDISEASE = 'Y';\n      FRATE += .4;\n  ENDSL;\n  \n  SELECT;\n    WHEN GENDER = 'F';\n      FRATE -= .05;\n  ENDSL;\n\n  FRATE = FRATE;\n\n  SELECT;\n    WHEN FRATE >= 9.5;\n      COHORT = 'Group 1';\n    WHEN FRATE >= 5.5;\n      COHORT = 'Group 2';\n    WHEN FRATE >= 3.5;\n      COHORT = 'Group 3';\n    WHEN FRATE >= 1.5;\n      COHORT = 'Group 4';\n    WHEN FRATE >= 0.0;\n      COHORT = 'Group 5';\n  ENDSL;\n\n  COHORT = COHORT;\nENDSR;","context":"","output":"The RPGLE subroutine `DETERMINERISK` calculates a risk factor `FRATE` based on a person's age, medical conditions, and gender and assigns them to a risk group `COHORT`.  \n\n1. Calculate Age\nThe person's age is determined by subtracting their birthdate from the current date.\n\n```rpgle\nAGE = %DIFF(%DATE():BIRTHDATE:*Y);\n```\n\n2. Assign a Base Risk Factor Based on Age\nA risk factor `FRATE` is assigned depending on age. Older individuals have a higher base risk, while younger individuals have a lower base risk.\n\n```rpgle\n  SELECT;\n    WHEN AGE >= 80 AND AGE <= 999;\n      FRATE = 14.8;\n    WHEN AGE >= 70;\n      FRATE = 8;\n    WHEN AGE >= 60;\n      FRATE = 3.6;\n    WHEN AGE >= 50;\n      FRATE = 1.3;\n    WHEN AGE >= 40;\n      FRATE = .4;\n    WHEN AGE >= 30;\n      FRATE = .25;\n    WHEN AGE >= 20;\n      FRATE = .23;\n    WHEN AGE >= 10;\n      FRATE = .2;\n    WHEN AGE >= 0;\n      FRATE = .1;\n\n  ENDSL;\n```\n\n3. Modify Risk Factor Based on Medical Conditions\n\n- If the person has cardiovascular disease, their risk increases by 0.8.  \n- If the person has diabetes, their risk increases by 0.6.  \n- If the person has high blood pressure, their risk increases by 0.3.  \n- If the person has respiratory disease, their risk increases by 0.4.  \n- Each condition adds to the overall risk factor.\n\n```rpgle\n  SELECT;\n    WHEN CVDISEASE = 'Y';\n      FRATE += .8;\n  ENDSL;\n  \n  SELECT;\n    WHEN DIABETES = 'Y';\n      FRATE += .6;\n  ENDSL;\n  \n  SELECT;\n    WHEN HBPRESSURE = 'Y';\n      FRATE += .3;\n  ENDSL;\n  \n  SELECT;\n    WHEN RSPDISEASE = 'Y';\n      FRATE += .4;\n  ENDSL;\n```\n\n4. Adjust the Risk Factor for Gender  \n\n- If the person is female `GENDER = 'F'`, the `FRATE` is slightly reduced by `0.05` to reflect lower average risk.\n\n```rpgle\nSELECT;\n  WHEN GENDER = 'F';\n    FRATE -= 0.05;\nENDSL;\n```\n\n5. Determine the Risk Group `COHORT`  \nBased on the final `FRATE` value, the person is assigned to a risk group `COHORT`:  \n\n- Group 1  Highest risk (FRATE  9.5)  \n- Group 2  Moderate-high risk (FRATE  5.5)  \n- Group 3  Moderate risk (FRATE  3.5)  \n- Group 4  Low risk (FRATE  1.5)  \n- Group 5  Minimal risk (FRATE  0.0)  \n- This categorization helps in risk assessment for medical or insurance purposes.\n\n```rpgle\n  SELECT;\n    WHEN FRATE >= 9.5;\n      COHORT = 'Group 1';\n    WHEN FRATE >= 5.5;\n      COHORT = 'Group 2';\n    WHEN FRATE >= 3.5;\n      COHORT = 'Group 3';\n    WHEN FRATE >= 1.5;\n      COHORT = 'Group 4';\n    WHEN FRATE >= 0.0;\n      COHORT = 'Group 5';\n  ENDSL;\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/4dcfc7882c51eddd17bd0d956737d2b0ec97f7c0_DETERMINERISK/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"how"}}
{"id":"5c20bd0_13_searchByCourseId_sum","input_data":"**free\n\nBegSr $searchByCourseId;\n  Exsr $clearSearchSfl;\n  IF ViewStud_Open();\n  foundStudent = ViewStud_FetchNext();\n  DOW ViewStud_IsOk();\n    IF foundStudent.StuCrsId = ST_INPCRS;\n      Exsr $populateSflFields;\n    ENDIF;\n    foundStudent = ViewStud_FetchNext();\n  ENDDO;\n  ViewStud_Close();\n  ENDIF;\n  IF StudRRN <> 0;\n    Exsr $DisplaySflAndFold;\n  ELSE;\n    MSG_STUDET = 'Course does not exist or has no associated students';\n  ENDIF;\nENDSR;","context":"","output":"This fully-free ILE RPG Subroutine `$searchByCourseId` is designed to search for and display a list of students associated with a given course ID. If no matching students are found, it provides a message to indicate that the course is either non-existent or has no students associated with it.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bd0_13_searchByCourseId/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"sum"}}
{"id":"5c20bd0_13_searchByCourseId_api","input_data":"**free\n\nBegSr $searchByCourseId;\n  Exsr $clearSearchSfl;\n  IF ViewStud_Open();\n  foundStudent = ViewStud_FetchNext();\n  DOW ViewStud_IsOk();\n    IF foundStudent.StuCrsId = ST_INPCRS;\n      Exsr $populateSflFields;\n    ENDIF;\n    foundStudent = ViewStud_FetchNext();\n  ENDDO;\n  ViewStud_Close();\n  ENDIF;\n  IF StudRRN <> 0;\n    Exsr $DisplaySflAndFold;\n  ELSE;\n    MSG_STUDET = 'Course does not exist or has no associated students';\n  ENDIF;\nENDSR;","context":"","output":"## Purpose\n\nThis fully-free ILE RPG subroutine `$searchByCourseId` is responsible for searching through a set of student records to find students associated with a specific course ID and display them in a subfile on the screen.  \n\n## Input\n\nThese globals are used as input to the subroutine:\n\n- `ST_INPCRS` - Course ID\n- `StuCrsId` - Current student's course ID\n\n## Output\n\n### Screen\n\nWhen rrn value is greater than zero subfile is shown by processing subroutine '$DisplaySflAndFold'\n\n### Global Variables\n\n- `foundStudent` - data structure containing information about the last student found\n- `StudRRN` - the relative record number of the last student found\n- `MSG_STUDET` - will be assigned error message in case of error\n\n### Error message\n\nIf subfile is empty, below message is sent `Course does not exist or has no associated students`\n\n### Dependencies\n\nThe following subroutines were called:\n\n- `$clearSearchSfl` - subroutine to clear the subfile\n- `$DisplaySflAndFold` - subroutine to display the loaded subfile on the screen\n\nThe following procedures were called:\n\n- `ViewStud_Open()` - open the SQL cursor to iterate over students\n- `ViewStud_FetchNext()` - fetch the next student from the cursor and return a student data structure\n- `ViewStud_IsOk()` - return boolean whether a student was successfully retrieved\n- `ViewStud_close()` - close the students cursor","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bd0_13_searchByCourseId/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"api"}}
{"id":"5c20bd0_13_searchByCourseId_how","input_data":"**free\n\nBegSr $searchByCourseId;\n  Exsr $clearSearchSfl;\n  IF ViewStud_Open();\n  foundStudent = ViewStud_FetchNext();\n  DOW ViewStud_IsOk();\n    IF foundStudent.StuCrsId = ST_INPCRS;\n      Exsr $populateSflFields;\n    ENDIF;\n    foundStudent = ViewStud_FetchNext();\n  ENDDO;\n  ViewStud_Close();\n  ENDIF;\n  IF StudRRN <> 0;\n    Exsr $DisplaySflAndFold;\n  ELSE;\n    MSG_STUDET = 'Course does not exist or has no associated students';\n  ENDIF;\nENDSR;","context":"","output":"This fully-free ILE RPG subroutine `$searchByCourseId` is responsible for searching through a set of student records to find students associated with a specific course ID, `ST_INPCRS`, passed as input to the program. \n\nThis subroutine performs the following steps:\n\n1. Clearing the contents of a subfile dedicated to search results, invoking subroutine `$clearSearchSfl`.\n\n2. It attempts to open a file related to student data using the `ViewStud_Open` procedure. If the view opens successfully:\n\n    a. It initializes a loop to fetch student records one by one using the `ViewStud_FetchNext` function.\n\n    b. Within the loop, it checks whether the current student's course ID (`StuCrsId`) matches the input course ID (`ST_INPCRS`).\n\n    c. If there's a match, it calls another subroutine `$populateSflFields` to populate the subfile with details from the current student record.\n\n    d. It continues to fetch the next student record until there are no more records to process (until `ViewStud_IsOk` returns false).\n\n3. After iterating through all student records, it closes the student data file with `ViewStud_Close`.\n\n4. The subroutine then checks `StudRRN` which would typically hold the relative record number of the subfile and act as a counter for the records processed.\n\n    a. It calls the `$DisplaySflAndFold` subroutine to display the subfile and possibly process the display further.\n\n5. If no student records were found it sets the `MSG_STUDET` message indicating that the 'course either doesn't exist or has no associated students'.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bd0_13_searchByCourseId/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"how"}}
{"id":"5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_10_NewSubOpt_sum","input_data":"**free\n\n//***********************************************************\n// Add New Subject\n//***********************************************************\nBegSr $NewSubOpt;\n  DOW indicators.exit = *OFF;\n    Write Header;\n    Write Footer_Add;\n    Exfmt NEWSUBJECT;\n    IF indicators.back = *ON;\n      Clear MSG_NEWSUB;\n      LeaveSr;\n    ELSEIF indicators.refresh = *ON;\n      Clear NEWSUBNAME;\n      Clear MSG_NEWSUB;\n      MSG_NEWSUB = 'Fields cleared';\n    ELSEIF indicators.save = *ON;\n      IF NEWSUBNAME = ' ';\n        MSG_NEWSUB = 'Subject name cannot be empty';\n      ELSE;\n        foundSubject = -1;\n        SETLL *loval SUBMASTER;\n        READ(N) SUBMASTER;\n        DOW NOT %EOF(SUBMASTER);\n          If %TRIM(NEWSUBNAME) = SUBNAME;\n            MSG_NEWSUB = 'Subject already exists.';\n            foundSubject = SUBJECTID;\n            Leave;\n          ENDIF;\n          READ(N) SUBMASTER;\n        ENDDO;\n        IF foundSubject = -1;\n          SETGT *hival SUBMASTER;\n          READP(E) SUBMAFMT;\n          IF %ERROR = '1';\n            SUBJECTID = 10;\n          ELSE;\n            SUBJECTID += 10;\n          EndIf;\n          SUBNAME = %TRIM(NEWSUBNAME);\n          WRITE SUBMAFMT;\n          MSG_NEWSUB = 'Subject ' + %trim(%CHAR(NEWSUBNAME))+' ID ' + %CHAR(SUBJECTID) + ' added';\n          Clear NEWSUBNAME;\n        ENDIF;\n      ENDIF;\n    ELSE;\n      // do nothing\n      MSG_NEWSUB = 'Use F8 to add new Subject';\n    Endif;\n  ENDDO;\n  Clear MSG_NEWSUB;\nEndSr;","context":"","output":"This fully-free ILE RPG subroutine `$NewSubOpt` handles the addition of a new subject. It manages user interactions, validates input, checks for duplicates, assigns a unique subject ID and updates the `SUBMASTER` file.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_10_NewSubOpt/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"sum"}}
{"id":"5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_10_NewSubOpt_api","input_data":"**free\n\n//***********************************************************\n// Add New Subject\n//***********************************************************\nBegSr $NewSubOpt;\n  DOW indicators.exit = *OFF;\n    Write Header;\n    Write Footer_Add;\n    Exfmt NEWSUBJECT;\n    IF indicators.back = *ON;\n      Clear MSG_NEWSUB;\n      LeaveSr;\n    ELSEIF indicators.refresh = *ON;\n      Clear NEWSUBNAME;\n      Clear MSG_NEWSUB;\n      MSG_NEWSUB = 'Fields cleared';\n    ELSEIF indicators.save = *ON;\n      IF NEWSUBNAME = ' ';\n        MSG_NEWSUB = 'Subject name cannot be empty';\n      ELSE;\n        foundSubject = -1;\n        SETLL *loval SUBMASTER;\n        READ(N) SUBMASTER;\n        DOW NOT %EOF(SUBMASTER);\n          If %TRIM(NEWSUBNAME) = SUBNAME;\n            MSG_NEWSUB = 'Subject already exists.';\n            foundSubject = SUBJECTID;\n            Leave;\n          ENDIF;\n          READ(N) SUBMASTER;\n        ENDDO;\n        IF foundSubject = -1;\n          SETGT *hival SUBMASTER;\n          READP(E) SUBMAFMT;\n          IF %ERROR = '1';\n            SUBJECTID = 10;\n          ELSE;\n            SUBJECTID += 10;\n          EndIf;\n          SUBNAME = %TRIM(NEWSUBNAME);\n          WRITE SUBMAFMT;\n          MSG_NEWSUB = 'Subject ' + %trim(%CHAR(NEWSUBNAME))+' ID ' + %CHAR(SUBJECTID) + ' added';\n          Clear NEWSUBNAME;\n        ENDIF;\n      ENDIF;\n    ELSE;\n      // do nothing\n      MSG_NEWSUB = 'Use F8 to add new Subject';\n    Endif;\n  ENDDO;\n  Clear MSG_NEWSUB;\nEndSr;","context":"","output":"## Purpose\nThe fully-free ILE RPG subroutine `$NewSubOpt` manages user interactions for adding a new subject. It validates input, checks for duplicate subjects, assigns a unique subject ID and updates the `SUBMASTER` file.\n\n## Parameters\nThis subroutine does not accept any input or output parameters.\n\n## Side Effect\n- Adds a new subject record if it does not exist.\n- Updates the `MSG_NEWSUB` message variable to provide feedback to the user.  \n- Clears `NEWSUBNAME` after successful addition.\n\n## Error Messages\nThe subroutine updates the `MSG_NEWSUB` variable with appropriate error messages:\n`'Subject name cannot be empty'`  Displayed if `NEWSUBNAME` is blank.\n`'Subject already exists.'` Displayed if the subject name is found in `SUBMASTER`.\n`'Use F8 to add new Subject'`  Default message when no action is taken.\n\n## Dependencies\n- `SUBMASTER`  Physical file containing subject records.\n- `NEWSUBJECT`  Display file used for user interaction.\n\n- `SETLL *loval SUBMASTER`  Positions the file at the beginning for searching existing subjects.\n- `READ(N) SUBMASTER`  Reads records to check for duplicate subjects.\n- `SETGT *hival SUBMASTER`  Positions the file at the end to determine the next available `SUBJECTID`.\n- `READP(E) SUBMAFMT`  Reads the last record to calculate the new `SUBJECTID`.\n- `WRITE SUBMAFMT`  Writes the new subject record into `SUBMASTER`.\n\n### Global Variables\nThe subroutine interacts with the following global variables:\n\nIndicators from `indds` Data Structure: \n- `exit` (*IN03)  Terminates the subject addition process.\n- `back` (*IN12)  Cancels the operation and exits the subroutine.\n- `refresh` (*IN05)  Clears input fields and displays a message.\n- `save` (*IN08)  Initiates the subject-saving process.\n\nControl Variables:\n- `NEWSUBNAME`  Stores the subject name entered by the user.\n- `SUBNAME`  Holds the subject name from `SUBMASTER` for duplicate checking.\n- `SUBJECTID`  Stores the unique ID assigned to the new subject.\n- `MSG_NEWSUB`  Displays status messages related to subject creation.\n\n## Usage Example\nThe `$NewSubOpt` subroutine is executed when the user initiates the subject addition process. \n\n```rpgle\n    exsr $NewSubOpt;  // Handles adding a new subject\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_10_NewSubOpt/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"api"}}
{"id":"5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_10_NewSubOpt_how","input_data":"**free\n\n//***********************************************************\n// Add New Subject\n//***********************************************************\nBegSr $NewSubOpt;\n  DOW indicators.exit = *OFF;\n    Write Header;\n    Write Footer_Add;\n    Exfmt NEWSUBJECT;\n    IF indicators.back = *ON;\n      Clear MSG_NEWSUB;\n      LeaveSr;\n    ELSEIF indicators.refresh = *ON;\n      Clear NEWSUBNAME;\n      Clear MSG_NEWSUB;\n      MSG_NEWSUB = 'Fields cleared';\n    ELSEIF indicators.save = *ON;\n      IF NEWSUBNAME = ' ';\n        MSG_NEWSUB = 'Subject name cannot be empty';\n      ELSE;\n        foundSubject = -1;\n        SETLL *loval SUBMASTER;\n        READ(N) SUBMASTER;\n        DOW NOT %EOF(SUBMASTER);\n          If %TRIM(NEWSUBNAME) = SUBNAME;\n            MSG_NEWSUB = 'Subject already exists.';\n            foundSubject = SUBJECTID;\n            Leave;\n          ENDIF;\n          READ(N) SUBMASTER;\n        ENDDO;\n        IF foundSubject = -1;\n          SETGT *hival SUBMASTER;\n          READP(E) SUBMAFMT;\n          IF %ERROR = '1';\n            SUBJECTID = 10;\n          ELSE;\n            SUBJECTID += 10;\n          EndIf;\n          SUBNAME = %TRIM(NEWSUBNAME);\n          WRITE SUBMAFMT;\n          MSG_NEWSUB = 'Subject ' + %trim(%CHAR(NEWSUBNAME))+' ID ' + %CHAR(SUBJECTID) + ' added';\n          Clear NEWSUBNAME;\n        ENDIF;\n      ENDIF;\n    ELSE;\n      // do nothing\n      MSG_NEWSUB = 'Use F8 to add new Subject';\n    Endif;\n  ENDDO;\n  Clear MSG_NEWSUB;\nEndSr;","context":"","output":"The fully-free ILE RPG subroutine `$NewSubOpt` handles user interactions for adding a new subject. It manages user input, validates the subject name, checks for duplicates, assigns a unique subject ID and updates the `SUBMASTER` file accordingly.\n\n### Subroutine Declaration \n\n```rpgle\n    BegSr $NewSubOpt;\n```\n\n- `BegSr` marks the beginning of the `$NewSubOpt` subroutine.  \n- This subroutine is executed when the user attempts to add a new subject.  \n- The subroutine runs inside a loop that processes user inputs until the exit condition is met.\n\n### Processing User Input in a Loop \n\n```rpgle\n    DOW indicators.exit = *OFF;\n```\n\n- The loop continues running until the exit indicator is set to `*ON`.  \n- It ensures that the user stays on the screen until they exit or successfully add a new subject.  \n\n### Displaying the Add Subject Screen\n\n```rpgle\n    Write Header;\n    Write Footer_Add;\n    Exfmt NEWSUBJECT;\n```\n\n- `Write Header` and `Write Footer_Add` display the page layout.  \n- `Exfmt NEWSUBJECT` presents the `'Add New Subject'` screen, where the user enters a subject name and selects n action.\n\n### Handling Different User Actions \n\n```rpgle\n    IF indicators.back = *ON;\n      Clear MSG_NEWSUB;\n      LeaveSr;\n```\n\n#### Condition 1: Back (`F12` or Equivalent)\n\n- If the user presses the Back key (`F12`), the system clears the message variable (`MSG_NEWSUB`) and exits the subroutine using `LeaveSr`.  \n- Effect: The user is taken back to the previous screen without making any changes.\n\n```rpgle\n    ELSEIF indicators.refresh = *ON;\n      Clear NEWSUBNAME;\n     Clear MSG_NEWSUB;\n      MSG_NEWSUB = 'Fields cleared';\n```\n\n#### Condition 2: Refresh (`F5` or Equivalent)\n\n- If the user presses the Refresh key (`F5`), it clears the input fields (`NEWSUBNAME`) and any previously displayed messages (`MSG_NEWSUB`).  \n- The message `'Fields cleared'` is displayed as confirmation.  \n- Effect: The user can restart the subject entry without exiting the screen.\n\n```rpgle\n   ELSEIF indicators.save = *ON;\n```\n\n#### Condition 3: Save (`F8` or Equivalent)  \n\n- If the user presses the Save key (`F8`), the system validates and processes the subject addition.\n\n### Validating Subject Name Input  \n\n```rpgle\n      IF NEWSUBNAME = ' ';\n        MSG_NEWSUB = 'Subject name cannot be empty';\n```\n\n If the `NEWSUBNAME` field is empty, an error message is displayed: `'Subject name cannot be empty.'`  \n- Effect: The user must enter a valid subject name before proceeding.\n\n### Checking for Duplicate Subject Names \n\n```rpgle\n      ELSE;\n        foundSubject = -1;\n        SETLL *loval SUBMASTER;\n        READ(N) SUBMASTER;\n        DOW NOT %EOF(SUBMASTER);\n          If %TRIM(NEWSUBNAME) = SUBNAME;\n            MSG_NEWSUB = 'Subject already exists.';\n            foundSubject = SUBJECTID;\n           Leave;\n          ENDIF;\n          READ(N) SUBMASTER;\n        ENDDO;\n```\n\n- The system searches the `SUBMASTER` file to check if the subject name already exists.  \n- If a duplicate is found, an error message `'Subject already exists.'` is displayed, and the process stops.  \n- Effect: Prevents duplicate subject entries.\n\n### Assigning a Unique Subject ID  \n\n```rpgle\n        IF foundSubject = -1;\n          SETGT *hival SUBMASTER;\n          READP(E) SUBMAFMT;\n          IF %ERROR = '1';\n            SUBJECTID = 10;\n          ELSE;\n            SUBJECTID += 10;\n         EndIf;\n```\n\n- If the subject does not already exist, the system assigns a new `SUBJECTID`:  \n  - If no previous records exist, `SUBJECTID` starts at 10.  \n  - Otherwise, it increments the highest existing `SUBJECTID` by 10. \n- Effect: Ensures that each subject has a unique and sequential ID.\n\n### Saving the New Subject Record\n\n```rpgle\n          SUBNAME = %TRIM(NEWSUBNAME);\n          WRITE SUBMAFMT;\n          MSG_NEWSUB = 'Subject ' + %trim(%CHAR(NEWSUBNAME))+' ID ' + %CHAR(SUBJECTID) + ' added';\n          Clear NEWSUBNAME;\n```\n\n- The new subject name and ID are written to the `SUBMASTER` file.  \n- A confirmation message is displayed: `'Subject <name> ID <id> added.'` \n- The input field (`NEWSUBNAME`) is cleared for a new entry.  \n- Effect: The new subject is successfully added to the system.\n\n### Handling Default Cases  \n\n```rpgle\n    ELSE;\n      MSG_NEWSUB = 'Use F8 to add new Subject';\n```\n\n- If no recognized action is performed, a message reminds the user to press F8 to add a new subject.\n- Effect: Ensures the user understands how to proceed.\n\n### End of Processing Loop\n\n```rpgle\n    ENDDO;\n    Clear MSG_NEWSUB;\n    endSr;\n```\n\n- The loop (`DOW indicators.exit = *OFF`) ensures that the user remains on the screen until they exit. \n- `Clear MSG_NEWSUB;` resets the message variable before exiting the subroutine.\n- Effect: Ensures a clean exit from the subroutine.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_10_NewSubOpt/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"how"}}
{"id":"5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_7_$AddSubjectToStudent_sum","input_data":"**free\n\n// **********************\n// Add Subjects for Students\n// **********************\nBegSr $AddSubjectToStudent;\n  DOW indicators.exit = *OFF;\n    DT_STID = ST_ID;\n    DT_STNAME = ST_NAME;\n    DT_CRSNAME = ST_CRSNAME;\n    DT_SEMEST = ST_SEMEST;\n    IF updatedSub = *ON;\n      DT_SUBNAME = updatedSubName;\n      DT_Marks = updatedMarks;\n    ELSE;\n      DT_SUBNAME = ST_SUBJECT;\n      DT_MARKS = ST_MARKS;\n    ENDIF;\n    Write Footer_ADD;\n    Exfmt ADDDETAIL;\n\n    IF indicators.back = *ON;\n      Clear DT_STID;\n      Clear DT_STNAME;\n      Clear DT_CRSNAME;\n      Clear DT_SEMEST;\n      Clear DT_SUBNAME;\n      Clear DT_MARKS;\n      Clear MSG_ADDDET;\n      Exsr $reloadSearchResult;\n      LeaveSr;\n    ELSEIF indicators.refresh = *ON;\n      Clear DT_SUBNAME;\n      Clear DT_MARKS;\n      MSG_ADDDET = 'Page refreshed, fields cleared';\n    ELSEIF indicators.prompt = *ON;\n      Exsr $showAvailableSubjects;\n    ELSEIF indicators.save = *ON;\n      dupSubject = *OFF;\n      inSubCourse = *OFF;\n      // check if subject is in subcourse with matching course id\n      tSubName = %TRIM(DT_SUBNAME);\n      updatingSubId = get_subject_id(tSubName);\n      IF updatingSubId = -1;\n        MSG_ADDDET = 'Invalid subject - Subject does not exist';\n        ITER;\n      ENDIF;\n\n      dupSubject = is_duplicate_subject(DT_STID:updatingSubId);\n      IF dupSubject = *ON;\n        update_Marks(DT_STID:updatingSubId:DT_MARKS);\n        updatedSubName = %TRIM(DT_SUBNAME);\n        updatedMarks = DT_Marks;\n        MSG_ADDDET = 'Student already enrolled. Updating Marks to ' + %CHAR(DT_MARKS);\n        ST_MARKS = updatedMarks;\n        updatedSub = *ON;\n      ELSE;\n        updatedSub = *OFF;\n        addCrsId = get_CourseId(DT_CRSNAME);\n        addSemId = get_SemId(DT_SEMEST);\n        inSubCourse = is_subject_in_SubCourse(addCrsId:updatingSubId:addSemId);\n\n        IF inSubCourse = *ON;\n          add_subject_to_StuDetails(DT_STID:updatingSubId:DT_Marks);\n          MSG_ADDDET = 'BINGO! Student added to new subject: ' + %TRIM(DT_SUBNAME);\n          updatedSubName = %TRIM(DT_SUBNAME);\n          updatedMarks = DT_Marks;\n          updatedSub = *ON;\n        ELSE;\n          MSG_ADDDET = 'Subject is not in the right Course or Semester';\n        ENDIF;\n      ENDIF;\n    ENDIF;\n  ENDDO;\n\nENDSR;","context":"","output":"This fully-free ILE RPG subroutine `$AddSubjectToStudent` is responsible for adding subjects to students records and updating the marks for an existing subject enrolment.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_7_%24AddSubjectToStudent/output/sum_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"sum"}}
{"id":"5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_7_$AddSubjectToStudent_api","input_data":"**free\n\n// **********************\n// Add Subjects for Students\n// **********************\nBegSr $AddSubjectToStudent;\n  DOW indicators.exit = *OFF;\n    DT_STID = ST_ID;\n    DT_STNAME = ST_NAME;\n    DT_CRSNAME = ST_CRSNAME;\n    DT_SEMEST = ST_SEMEST;\n    IF updatedSub = *ON;\n      DT_SUBNAME = updatedSubName;\n      DT_Marks = updatedMarks;\n    ELSE;\n      DT_SUBNAME = ST_SUBJECT;\n      DT_MARKS = ST_MARKS;\n    ENDIF;\n    Write Footer_ADD;\n    Exfmt ADDDETAIL;\n\n    IF indicators.back = *ON;\n      Clear DT_STID;\n      Clear DT_STNAME;\n      Clear DT_CRSNAME;\n      Clear DT_SEMEST;\n      Clear DT_SUBNAME;\n      Clear DT_MARKS;\n      Clear MSG_ADDDET;\n      Exsr $reloadSearchResult;\n      LeaveSr;\n    ELSEIF indicators.refresh = *ON;\n      Clear DT_SUBNAME;\n      Clear DT_MARKS;\n      MSG_ADDDET = 'Page refreshed, fields cleared';\n    ELSEIF indicators.prompt = *ON;\n      Exsr $showAvailableSubjects;\n    ELSEIF indicators.save = *ON;\n      dupSubject = *OFF;\n      inSubCourse = *OFF;\n      // check if subject is in subcourse with matching course id\n      tSubName = %TRIM(DT_SUBNAME);\n      updatingSubId = get_subject_id(tSubName);\n      IF updatingSubId = -1;\n        MSG_ADDDET = 'Invalid subject - Subject does not exist';\n        ITER;\n      ENDIF;\n\n      dupSubject = is_duplicate_subject(DT_STID:updatingSubId);\n      IF dupSubject = *ON;\n        update_Marks(DT_STID:updatingSubId:DT_MARKS);\n        updatedSubName = %TRIM(DT_SUBNAME);\n        updatedMarks = DT_Marks;\n        MSG_ADDDET = 'Student already enrolled. Updating Marks to ' + %CHAR(DT_MARKS);\n        ST_MARKS = updatedMarks;\n        updatedSub = *ON;\n      ELSE;\n        updatedSub = *OFF;\n        addCrsId = get_CourseId(DT_CRSNAME);\n        addSemId = get_SemId(DT_SEMEST);\n        inSubCourse = is_subject_in_SubCourse(addCrsId:updatingSubId:addSemId);\n\n        IF inSubCourse = *ON;\n          add_subject_to_StuDetails(DT_STID:updatingSubId:DT_Marks);\n          MSG_ADDDET = 'BINGO! Student added to new subject: ' + %TRIM(DT_SUBNAME);\n          updatedSubName = %TRIM(DT_SUBNAME);\n          updatedMarks = DT_Marks;\n          updatedSub = *ON;\n        ELSE;\n          MSG_ADDDET = 'Subject is not in the right Course or Semester';\n        ENDIF;\n      ENDIF;\n    ENDIF;\n  ENDDO;\n\nENDSR;","context":"","output":"## Purpose\nThis fully-free ILE RPG subroutine `$AddSubjectToStudent` is responsible for adding subjects to students records and possibly updating the marks for an existing subject enrolment.\n\n## Parameters\nNone\n\n### Dependencies\nBelow mentioned subroutines are used in this subroutine `$AddSubjectToStudent`\n\n| Subroutine Name          |         Purpose           |\n|--------------------------|---------------------------|\n| `$reloadSearchResult`    | Reloads the search result |\n|`$showAvailableSubjects`  | Show available subjects   |\n\n\n### Error messages\nBelow mentioned error messages are generated in validation process.\n\n|Error Condition  | Error message |\n|--------------------|----------------------------|\n|If subfile is cleared |`'Page refreshed, fields cleared'`|\n|If subject not matching with course id |`'Invalid subject -Subject does not exist'`|\n|If duplicate entry of student found|`'Student already enrolled. Updating Marks to ' + %CHAR(DT_MARKS);'`|\n|If student added to new subject|`'BINGO! Student added to new subject: ' + %TRIM(DT_SUBNAME);`|\n|If the wrong subject added|`'Subject is not in the right Course or Semester';`|\n\n## Usage Example\n The procedure can be called/executed as below:\n``` Rpgle\n        exsr $AddSubjectToStudent\n```","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_7_%24AddSubjectToStudent/output/api_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"api"}}
{"id":"5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_7_$AddSubjectToStudent_how","input_data":"**free\n\n// **********************\n// Add Subjects for Students\n// **********************\nBegSr $AddSubjectToStudent;\n  DOW indicators.exit = *OFF;\n    DT_STID = ST_ID;\n    DT_STNAME = ST_NAME;\n    DT_CRSNAME = ST_CRSNAME;\n    DT_SEMEST = ST_SEMEST;\n    IF updatedSub = *ON;\n      DT_SUBNAME = updatedSubName;\n      DT_Marks = updatedMarks;\n    ELSE;\n      DT_SUBNAME = ST_SUBJECT;\n      DT_MARKS = ST_MARKS;\n    ENDIF;\n    Write Footer_ADD;\n    Exfmt ADDDETAIL;\n\n    IF indicators.back = *ON;\n      Clear DT_STID;\n      Clear DT_STNAME;\n      Clear DT_CRSNAME;\n      Clear DT_SEMEST;\n      Clear DT_SUBNAME;\n      Clear DT_MARKS;\n      Clear MSG_ADDDET;\n      Exsr $reloadSearchResult;\n      LeaveSr;\n    ELSEIF indicators.refresh = *ON;\n      Clear DT_SUBNAME;\n      Clear DT_MARKS;\n      MSG_ADDDET = 'Page refreshed, fields cleared';\n    ELSEIF indicators.prompt = *ON;\n      Exsr $showAvailableSubjects;\n    ELSEIF indicators.save = *ON;\n      dupSubject = *OFF;\n      inSubCourse = *OFF;\n      // check if subject is in subcourse with matching course id\n      tSubName = %TRIM(DT_SUBNAME);\n      updatingSubId = get_subject_id(tSubName);\n      IF updatingSubId = -1;\n        MSG_ADDDET = 'Invalid subject - Subject does not exist';\n        ITER;\n      ENDIF;\n\n      dupSubject = is_duplicate_subject(DT_STID:updatingSubId);\n      IF dupSubject = *ON;\n        update_Marks(DT_STID:updatingSubId:DT_MARKS);\n        updatedSubName = %TRIM(DT_SUBNAME);\n        updatedMarks = DT_Marks;\n        MSG_ADDDET = 'Student already enrolled. Updating Marks to ' + %CHAR(DT_MARKS);\n        ST_MARKS = updatedMarks;\n        updatedSub = *ON;\n      ELSE;\n        updatedSub = *OFF;\n        addCrsId = get_CourseId(DT_CRSNAME);\n        addSemId = get_SemId(DT_SEMEST);\n        inSubCourse = is_subject_in_SubCourse(addCrsId:updatingSubId:addSemId);\n\n        IF inSubCourse = *ON;\n          add_subject_to_StuDetails(DT_STID:updatingSubId:DT_Marks);\n          MSG_ADDDET = 'BINGO! Student added to new subject: ' + %TRIM(DT_SUBNAME);\n          updatedSubName = %TRIM(DT_SUBNAME);\n          updatedMarks = DT_Marks;\n          updatedSub = *ON;\n        ELSE;\n          MSG_ADDDET = 'Subject is not in the right Course or Semester';\n        ENDIF;\n      ENDIF;\n    ENDIF;\n  ENDDO;\n\nENDSR;","context":"","output":"This fully-free ILE RPG code defines a subroutine `AddSubjectToStudent` that is responsible for adding subjects to students' records, and possibly updating the marks for an existing subject enrolment. \n\n\n- This subroutine begins with `BegSr $AddSubjectToStudent` marking the start of its execution.\n\n### 1.    It Enters a do-while loop that continues as long as an exit indicator is not set to *ON.\n       \n\n It initializes some working variables `DT_*` with the student's details from variables like `ST_ID`, `ST_NAME`, etc. If there is an update flag `updatedSub`, it uses updated subject name and marks. Otherwise, it uses the current details from `ST_SUBJECT` and `ST_MARKS`.\n\n```rpgle\n        DT_STID = ST_ID;\n         DT_STNAME = ST_NAME;\n         DT_CRSNAME = ST_CRSNAME;\n         DT_SEMEST = ST_SEMEST;\n         IF updatedSub = *ON;\n         DT_SUBNAME = updatedSubName;\n         DT_Marks = updatedMarks;\n         ELSE;\n         DT_SUBNAME = ST_SUBJECT;\n         DT_MARKS = ST_MARKS;\n         ENDIF;\n```\n ### 2.  A record format named `Footer_ADD` is written to the display file/screen, and the display file `ADDDETAIL` is formatted to the screen.\n ```rpgle\n         Write Footer_ADD;\n         Exfmt ADDDETAIL;\n```\n\n   ### 2.1  If the `back` indicator is set to `*ON`, it clears all details, reloads the search result subrouting, and exits the subroutine.\n```rpgle\n        IF indicators.back = *ON;\n      Clear DT_STID;\n      Clear DT_STNAME;\n      Clear DT_CRSNAME;\n      Clear DT_SEMEST;\n      Clear DT_SUBNAME;\n      Clear DT_MARKS;\n      Clear MSG_ADDDET;\n      Exsr $reloadSearchResult;\n      LeaveSr;\n```         \n  ### 2.2  If the `refresh` indicator is set to `*ON`, it clears only the subject name and marks fields and updates a message indicating that the page was refreshed.\n\n```rpgle\n       ELSEIF indicators.refresh = *ON;\n       Clear DT_SUBNAME;\n       Clear DT_MARKS;\n       MSG_ADDDET = 'Page refreshed, fields cleared';\n```     \n  ### 2.3  If the `prompt` indicator is set to `*ON`, it executes another subroutine to show available subjects.\n\n```rpgle\n       ELSEIF indicators.prompt = *ON;\n       Exsr $showAvailableSubjects;\n```\n\n  ### 2.4  If the `save` indicator is set to `*ON`, it checks for a duplicate subject entry and subject-course-semester validity.\n\n```rpgle\n        ELSEIF indicators.save = *ON;\n        dupSubject = *OFF;\n        inSubCourse = *OFF;\n```    \n  ### 2.5    If the subject is a duplicate for the student, it will update the marks for that subject and set an appropriate message including the new marks.\n\n```rpgle\n        tSubName = %TRIM(DT_SUBNAME);\n        updatingSubId = get_subject_id(tSubName);\n        IF updatingSubId = -1;\n        MSG_ADDDET = 'Invalid subject - Subject does not exist';\n        ITER;\n       ENDIF;\n  ```\n  ### 2.6 If the subject is not a duplicate, it checks if the subject is assigned to the student's course and semester. \n  ```rpgle\n       dupSubject = is_duplicate_subject(DT_STID:updatingSubId);\n       IF dupSubject = *ON;\n        update_Marks(DT_STID:updatingSubId:DT_MARKS);\n        updatedSubName = %TRIM(DT_SUBNAME);\n        updatedMarks = DT_Marks;\n        MSG_ADDDET = 'Student already enrolled. Updating Marks to ' + %CHAR(DT_MARKS);\n        ST_MARKS = updatedMarks;\n        updatedSub = *ON;\n      ELSE;\n```\n  ### 2.7 If the subject is in the course \n```rpgle        \n        updatedSub = *OFF;\n        addCrsId = get_CourseId(DT_CRSNAME);\n        addSemId = get_SemId(DT_SEMEST);\n        inSubCourse = is_subject_in_SubCourse(addCrsId:updatingSubId:addSemId);\n\n```\n   ### 2.7.1  If valid, it adds the student to the subject with the provided marks and sets an appropriate success message.\n       \n```rpgle\n       IF inSubCourse = *ON;\n          add_subject_to_StuDetails(DT_STID:updatingSubId:DT_Marks);\n          MSG_ADDDET = 'BINGO! Student added to new subject: ' + %TRIM(DT_SUBNAME);\n          updatedSubName = %TRIM(DT_SUBNAME);\n          updatedMarks = DT_Marks;\n          updatedSub = *ON;\n        ELSE;\n ```\n ### 2.7.2. If the subject is not within the right course or semester, it sets an error message indicating the mismatch.       \n```rpgle\n          MSG_ADDDET = 'Subject is not in the right Course or Semester';\n        ENDIF;\n```\n        \nThe subroutine loops until the exit condition is met or the back indicator is activated. \n\nThis routine would typically be invoked as part of a larger program or menu-driven application where student records are being managed, allowing for the addition or updating of subjects and marks.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data/explain/ibm-florin-poc/5c20bdf978e719be9918f4a80ef2ddbdefac6bc0_7_%24AddSubjectToStudent/output/how_output.md","task":"explain","difficulty":2,"language":"rpg4ff","scope":"subr","depth":"how"}}
{"id":"10981319d9b34678b5ca84a88ea3f08e18e6cdca_cdca","input_data":"   h dftactgrp(*no)\n      /copy mih-lock\n      /copy mih-ptr\n     d main            pr                  extpgm('LOCK01')\n     d   request_type                 1a\n     d lock_request    ds                  qualified\n     d   base                              likeds(lock_request_tmpl_t)\n     d   obj                           *\n     d   lock_state                   1a\n\n     d main            pi\n     d   request_type                 1a\n\n      /free\n           lock_request.base = *allx'00';\n           lock_request.base.num_requests = 1;\n           lock_request.base.offset_lock_state = 32;\n           lock_request.base.lock_opt = x'4200'; // Synchronous request\n                                                 // and wait indefinitely.\n           // Lock myself\n           rslvsp_tmpl.obj_type = x'0201';\n           rslvsp_tmpl.obj_name = 'LOCK01';\n           rslvsp2(lock_request.obj : rslvsp_tmpl);\n           lock_request.lock_state = x'09';      // LENR lock\n           if request_type = 'I';\n               lock_request.base.lock_opt = x'0200'; // Immediate request\n           elseif request_type = 'A';\n               lock_request.base.lock_opt = x'8200'; // Asynchronous request\n           endif;\n\n           lockobj(lock_request);  // Lock myself with specified lock request type\n           *inlr = *on;\n      /end-free","context":"","output":"api_output.md\n## Purpose \n\nThis ILE RPG program, `LOCK01`, locks itself using MIH APIs. It is designed to control access to the `LOCK01` object by applying different lock request types such as Synchronous, Immediate, or Asynchronous depending on the input parameter.\n\n## Parameters \n\nThis program accepts one input parameter:\n`request_type` (CHAR(1)), Specifies the type of lock request:\n`'I'` = Immediate lock request\n`'A'` = Asynchronous lock request\nAny other value defaults to Synchronous lock with wait indefinitely.\n\nThere are no output parameters.\n\n\n## Dependencies\n\nThe program depends on the following MIH APIs and related templates (included via /copy members):\n\n`/copy mih-lock`\n`/copy mih-ptr`\n\nExternal APIs called within the program:\n`rslvsp2()`  Resolves the object pointer for `LOCK01` using the `rslvsp_tmpl` template.\n`lockobj()`  Requests a lock on the resolved object pointer with the specified lock options.\n\n### Functionality\n\nLocks the `LOCK01` Object\n\n## Usage Example\nCall the program with the appropriate lock request type:\n\n```clle\nCALL LOCK01 PARM('I')  /* Immediate lock request */\nCALL LOCK01 PARM('A') /* Asynchronous lock request */\nCALL LOCK01 PARM('S') /* Default synchronous lock request */\n```\n\nhow_output.md\nThis ILE RPG program, `LOCK01`, locks itself using MIH APIs (`rslvsp2` and `lockobj`) to control access with different lock request types.\n\n\n### Initializing the Lock Request Structure\n\n\n```rpgle\n    lock_request.base = *allx'00';\n```\n- Clears the lock_request.base structure by setting all its fields to hexadecimal zero (00).\n- Ensures no residual data exists before setting specific fields for this lock request\n\n\n```rpgle\n    lock_request.base.num_requests = 1;\n```\n- Sets the number of lock requests being made to 1.\n- Indicates this structure contains a single lock request entry.\n\n\n```rpgle\n    lock_request.base.offset_lock_state = 32;\n```\n- Sets the offset to the lock_state field in the lock request structure.\n- The offset value 32 tells the system where the lock state information begins within the   structure.\n\n\n```rpgle\n    lock_request.base.lock_opt = x'4200'; \n```\n- Initializes the lock option to x'4200'.\n- This means the lock request is Synchronous and will wait indefinitely until the lock is acquired.\n\n\n### Resolving the Object Pointer for `LOCK01`\n\n\n```rpgle\n    rslvsp_tmpl.obj_type = x'0201';\n```\n- `x'0201'` is the object type code for a program object.\n\n\n\n```rpgle\n    rslvsp_tmpl.obj_name = 'LOCK01';\n```\n- The program `LOCK01` is locking itself, likely to prevent concurrent executions or ensure exclusive access.\n\n```rpgle\n    rslvsp2(lock_request.obj : rslvsp_tmpl);\n```\n- Calls the `rslvsp2()` MIH API to resolve the object pointer.\n- Populates the `lock_request.obj` field with the pointer to `LOCK01` for use in the lock operation.\n\n\n### Setting the Lock State\n\n\n```rpgle\n    lock_request.lock_state = x'09'; \n```\n- Specifies the Lock State as `x'09'`.\n- 09 indicates a LENR lock (Lock Exclusive No Read), meaning no other jobs can read or update the object while this lock is held.\n\n### Handling the `request_type` Parameter\n\nThe program checks the `request_type` input to determine which kind of lock to perform.\n\n```rpgle\n    if request_type = 'I';\n        lock_request.base.lock_opt = x'0200'; \n```\n- If the input parameter `request_type` is `'I'`, the lock option is changed to `x'0200'`.\n- This sets an Immediate lock request, meaning the system tries to acquire the lock immediately without waiting.\n\n\n```rpgle\n    elseif request_type = 'A';\n        lock_request.base.lock_opt = x'8200'; \n```\n\n- If `request_type` is `'A'`, the lock option is changed to `x'8200'`.\n- This makes an Asynchronous lock request, allowing the program to continue processing without waiting for the lock to complete.\n\nIf `request_type` is neither `'I'` nor `'A'`, the default lock option (`x'4200'`, Synchronous Wait Indefinitely) remains in effect.\n\n\n### Requesting the Lock\n\n\n```rpgle\n    lockobj(lock_request);\n```\n- Calls the `lockobj()` MIH API with the `lock_request` structure.\n- Attempts to lock the object `LOCK01` with the specified options and lock state.\n\n\n### Ending the Program\n\n\n```rpgle\n    *inlr = *on;\n```\n- Sets the Last Record indicator (*INLR) to *ON, Signals the end of the program.\n\nsum_output.md\nThis ILE RPG program, `LOCK01`, locks itself. It sets up the lock request, finds the program object LOCK01, and locks it with different lock request types (Immediate, Asynchronous, Synchronous) for object control.","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data","task":"fixed-to-free","difficulty":2,"language":"rpg4fc"}}
{"id":"CountOccuranceOf","input_data":"dcl-proc countOccurrencesOf export;\n\n    dcl-pi *n int( 10 );\n       search  varchar( 64000 ) const;\n       source  varchar( 64000 ) const;\n    end-pi;\n\n    dcl-s position      int( 10 );\n    dcl-s result        int( 10 );\n    dcl-s searchLength  int( 10 );\n    dcl-s sourceLength  int( 10 );\n\n    result = 0;\n    position = 1;\n\n    searchLength = %len( search );\n    sourceLength = %len( source );\n\n    if ( searchLength > 0 );\n\n       doW ( position <= ( sourceLength - searchLength + 1 ));\n\n          if ( %subst( source : position : searchLength ) = search );\n             result += 1;\n             position += searchLength;\n          else;\n             position += 1;\n          endIf;\n\n       endDo;\n\n    endIf;\n\n    return result;\n\nend-proc;","context":"Rules.mk\nTEXTUTILS.SRVPGM: TEXTUTILS.BND TEXTUTILS.MODULE\nTEXTUTILS.BNDDIR: TEXTUTILS.BNDDIR TEXTUTILS.SRVPGM\n\nTEXTUTIL.BNDSRC\n/* Have to delete the BNDDIR, or it will always be older than the source */\n/* because the CRTBNDDIR will fail the second time and only the ADDBNDDIRE is executed */     \n!DLTOBJ OBJ(&O/&N) OBJTYPE(*BNDDIR)\nCRTBNDDIR BNDDIR(&O/&N)\nADDBNDDIRE BNDDIR(&O/&N) +\n   OBJ((*LIBL/TEXTUTIL *SRVPGM))\n\nTEXTUTILS.BND\n\n             strPgmExp  pgmLvl( *current ) signature( 'TEXTUTILS V1.00' )\n\n                export     symbol( trimAndUpperCase )\n                export     symbol( trimAndLowerCase )\n                export     symbol( toUpperCase )\n                export     symbol( toLowerCase )\n                export     symbol( parseDate )\n                export     symbol( getEnvironmentVariable )\n                export     symbol( toStringJsonArray )\n                export     symbol( scanReverse )\n                export     symbol( toYN )\n                export     symbol( toQuotedYN )\n                export     symbol( convertTimeStampToStringDate )\n                export     symbol( removeUnprintable )\n                export     symbol( isLetter )\n                export     symbol( isDigit )\n                export     symbol( toStringJsonArrayLarger )\n                export     symbol( splitStringMaxLength )\n                export     symbol( removeBlanks )\n                export     symbol( startsWith )\n                export     symbol( endsWith )\n                export     symbol( countOccurrencesOf )\n\n             endPgmExp\n\nTEXTUTIL_H.RPGLEINC\n**free\n// External procedure definitions for TextUtils\n//\n// Why:  Convert trim and to uppercase or trim and lowercase depending on the\n//       the procedure that is called trimAndToUpperCase or trimAndTolowerCase\n//       you can also call toLowerCase and toUpperCase if you want just to uppercase or lowercase\n//        the value and ignore the triming.\n\n\ndcl-c EMPTY_ISO_DATE  '0001-01-01';\ndcl-c EMPTY_DATE     d'0001-01-01';\n\ndcl-c CARRIAGE_RETURN           x'0D';\ndcl-c LINE_FEED                 x'25';\ndcl-c CARRIAGE_RETURN_LINE_FEED x'0D25';\ndcl-c LINE_FEED_CARRIAGE_RETURN x'250D';\n\ndcl-c SINGLE_QUOTE              '''';\ndcl-c DOUBLE_QUOTE              '\"'; \n\nDcl-s myvar varchar( 22 ) template; \n\nDcl-ds mods qualified dim( 1 ) template; \n     Myvarchar  varchar( 10 ); \n     Medate     date; \nEnd-ds; \n\n// convert the string time stamp to the string date.\ndcl-pr convertTimeStampToStringDate varchar( 10 );\n    stringTimeStamp varchar( 10 ) value;\nend-pr;\n\n// countOccurrencesOf\n//\n// Return the number of times a source string contains a\n// search string.\n//\n// A specific location in the source string won't match\n// the search string multiple times. For example, if you\n// search for:\n//\n//     ABA\n//\n// in:\n//\n//     ABABABA\n//\n// you will get a result of 2 (matches start at positions 1\n// and 5), not 3 (the match starting at 3 doesn't count).\n//\ndcl-pr countOccurrencesOf int( 10 );\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\n// endsWith\n//\n// Return *ON if the source string ends with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #startsWith\n//\ndcl-pr endsWith ind;\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\ndcl-pr getEnvironmentVariable varchar(150);\n      environmentVariableName char(64) value;\nend-pr;\n\n//******************************************************************************\n// isDigit\n//\n// Return *ON if the character is a numeric digit.\n//\n// @see isLetter\n\ndcl-pr isDigit ind;\n     characterToTest char( 1 ) const;\nend-pr;\n\n//******************************************************************************\n// isLetter\n//\n// Return *ON if the character is an upper-case or lower-case letter.\n//\n// @see isDigit\n\ndcl-pr isLetter ind;\n     characterToTest char( 1 ) const;\nend-pr;\n\ndcl-pr parseDate date;\n     *n varchar(50) value;\nend-pr;\n\n//-------------------------------------------------------------------------------------------------\n//  remove the blanks from the string that has been passed. This can be anywhere in the string.\n//-------------------------------------------------------------------------------------------------\ndcl-pr removeBlanks varchar( 64000 );\n    inputString     varchar( 64000 ) const;\nend-pr;\n\n//******************************************************************************\n// removeUnprintable\n//\n// Remove characters that cannot be printed, specifically control characters\n// and those not normally entered into input fields.\n\ndcl-pr removeUnprintable  varchar( 64000 );\n     *n varchar( 64000 ) const;\nend-pr;\n\n//*******************************************************************************************\n// scanReverse\n// This procedure will take a string and scan the last five characters, looking for the passed in\n// delimiter. If the delimiter is not found then it starts working itself backwards until you are at\n// beginning of the string. This returns the position ( Int value ) of the requested delimiter. or 0\n// the delimiter is not found.\n//*******************************************************************************************\ndcl-pr scanReverse uns( 10 );\n    comment varchar( 3500 ) value;\n    delimiter varchar( 6 ) value;\n    startPoint uns( 10 ) value options(*nopass);\nend-pr;\n\n// splitStringMaxLength\n//\n// Take a long string and break it up into smaller substrings based off of inputted max substring\n// length and optional separators(see below for rules). The subprocedure will try not to split up\n// any words, if the max length does not land on the separator, the process will step back until\n// it can find one. If a separator is not found, it will split the string at the max length mark.\n// When a separator is found, the string will be split at that point and the separator will be\n// deleted.\n//\n// @return\n//   If the split was successfull the indicatior will be *on. Otherwise the indicator is returned\n//   *off, check EVBLOG for more details on the error.\n//\n// @param callback\n//   A subprocedure in the program that is calling this procedure. The callback subprocedure will\n//   be called for each substring it splits off of the source string.\n//   We will send three parameters to your callback procedure:\n//      splitString  - the substring that has been split from the source string\n//      splitIndex   - the sequence number of the splitString.\n//      callbackData - will send what was sent to this subprocedure in the callbackData parameter.\n//                     It is also subject to change in your callback subprocedure.\n//\n// @param source\n//   The full string you wish to be split\n//\n// @param maxResultLength\n//   The maximum substring size you want returned. Must be greater that one.\n//\n// @param separator (optional)\n//   The separator will default to a space when not specified. If, however,\n//   you pass it an empty string ('') the procedure will not use a separator, instead split the\n//   string at the max length regardless of where that lands. It is also possible to pass the\n//   procedure multiple separators. For example if you pass the separator something like this '_- '\n//   the procedure will use underscore, dash, or space as a separator; whichever it finds first.\n//\n// @param callbackData (optional)\n//   This can be any variable type or data structure you like from your calling program. If you\n//   choose to pass something in nthe callbackData, it will be sent to your callback subprocedure.\n//   Example: subprocedure splitStringMaxLengthCallback05 in TEXTUTIL_T used as an int callbackData\n//   to increment each time the subprocedure was called in order to validate the splitIndex.\n//\ndcl-pr splitStringMaxLength ind;\n   callback        pointer( *proc )    const;\n   source          varchar( 3000000 )  const;\n   maxLength       int(          10 )  const;\n   separators      varchar(      20 )  const options( *noPass : *omit );\n   callbackData    pointer             const options( *noPass : *omit );\nend-pr;\n\n// startsWith\n//\n// Return *ON if the source string starts with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #endsWith\n//\ndcl-pr startsWith ind;\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\n// convert the string to lowercase.\ndcl-pr toLowerCase varchar(64000);\n     *n varchar(64000) value;\nend-pr;\n\n//******************************************************************************\n// toQuotedYN\n//\n// Return the value from toYN and put single quotes around it so it can\n// easily be added to an SQL string.\n//\n// see also toYN\n\ndcl-pr toQuotedYN char( 3 );\n     source varchar( 10 ) const;\nend-pr;\n\n//******************************************************************************\n// toStringJsonArray\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation.\n//\n// Examples:\n//\n// Input:\n//     (null)\n// Output:\n//     (empty string)\n//\n// Input:\n//     (array list without any elements)\n// Output:\n//     []\n//\n// Input:\n//     ABC\n// Output:\n//     [\"ABC\"]\n//\n// Input:\n//     ABC, 123\n// Output:\n//     [\"ABC\",\"123\"]\n//\n// Input:\n//     \"Quoted\" Text\n// Output:\n//     [\"\\\"Quoted\\\" Text\"]\n\ndcl-pr toStringJsonArray varchar( 65535 );\n     arrayList pointer const;\nend-pr;\n\n//******************************************************************************\n// toStringJsonArrayLarger\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation. This can handle larger results\n// than toStringJsonArray.\n//\n// Examples:\n//\n// Input:\n//     (null)\n// Output:\n//     (empty string)\n//\n// Input:\n//     (array list without any elements)\n// Output:\n//     []\n//\n// Input:\n//     ABC\n// Output:\n//     [\"ABC\"]\n//\n// Input:\n//     ABC, 123\n// Output:\n//     [\"ABC\",\"123\"]\n//\n// Input:\n//     \"Quoted\" Text\n// Output:\n//     [\"\\\"Quoted\\\" Text\"]\n\ndcl-pr toStringJsonArrayLarger varchar( 2000000 );\n     arrayList pointer const;\nend-pr;\n\n// convert the string to uppercase.\ndcl-pr toUpperCase varchar(64000);\n    *n varchar(64000) value;\nend-pr;\n\n//******************************************************************************\n// toYN\n//\n// Take an input value, probably received from a browser or JSON request,\n// and return a Y or N character value appropriate for storing in 'boolean'\n// database column. Anything like Y, yes, true, 1, ... will result in a\n// Y response while anything else will return an N.\n//\n// see also toQuotedYN\n\ndcl-pr toYN char( 1 );\n     source varchar( 10 ) const;\nend-pr;\n\n// trim and convert the string to lowercase.\ndcl-pr trimAndLowerCase varchar(64000);\n     *n varchar(64000) value;\nend-pr;\n\n// trim and convert the string to uppercase.\ndcl-pr trimAndUpperCase varchar(64000);\n    *n varchar(64000) value;\nend-pr;","output":"**free\n**free\nctl-opt bndDir( 'TEXTUTILS' : 'IBMIUNIT/IBMIUNIT' : 'OSSILE/OSSILE' );\n\n /copy TextUtil_H\n /copy IBMiUnit/QRPGLESRC,IBMiUnit_H\n /copy ArrayLst_H\n\n dcl-s arrayList pointer;\n\n IBMiUnit_setupSuite( 'TextUtil Tests'\n                    : %pAddr( beforeTest ) : %pAddr( afterTest ) );\n\n\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_emptySearchEmptySource )\n                    :        'countOccurrencesOf_emptySearchEmptySource' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_blankSearchEmptySource )\n                    :        'countOccurrencesOf_blankSearchEmptySource' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_emptySearchBlankSource )\n                    :        'countOccurrencesOf_emptySearchBlankSource' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_blankSearchBlankSource )\n                    :        'countOccurrencesOf_blankSearchBlankSource' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_characterMatchAtBeginning )\n                    :        'countOccurrencesOf_characterMatchAtBeginning' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_characterMatchAtEnd )\n                    :        'countOccurrencesOf_characterMatchAtEnd' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_characterMatchInMiddle )\n                    :        'countOccurrencesOf_characterMatchInMiddle' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_stringMatchAtBeginning )\n                    :        'countOccurrencesOf_stringMatchAtBeginning' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_stringMatchAtEnd )\n                    :        'countOccurrencesOf_stringMatchAtEnd' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_stringMatchInMiddle )\n                    :        'countOccurrencesOf_stringMatchInMiddle' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_caseDifference )\n                    :        'countOccurrencesOf_caseDifference' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_longerSearch )\n                    :        'countOccurrencesOf_longerSearch' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_allCharacterMatches )\n                    :        'countOccurrencesOf_allCharacterMatches' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_allStringMatches )\n                    :        'countOccurrencesOf_allStringMatches' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_nonRepeatingMatch )\n                    :        'countOccurrencesOf_nonRepeatingMatch' );\n\nIBMiUnit_teardownSuite();\nreturn;\n\n\n // support methods\n\n dcl-proc beforeTest;\n\n    arrayList = *null;\n\n end-proc;\n\n dcl-proc afterTest;\n\n    if ( arrayList <> *null );\n       arraylist_dispose( arrayList );\n    endIf;\n\n end-proc;\n\n// countOccurrencesOf tests\n\ndcl-proc countOccurrencesOf_emptySearchEmptySource;\n\n   assertNumericEquals( 0 : countOccurrencesOf( '' : '' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_blankSearchEmptySource;\n\n   assertNumericEquals( 0 : countOccurrencesOf( ' ' : '' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_emptySearchBlankSource;\n\n   assertNumericEquals( 0 : countOccurrencesOf( '' : ' ' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_blankSearchBlankSource;\n\n   assertNumericEquals( 1 : countOccurrencesOf( ' ' : ' ' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_characterMatchAtBeginning;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'A' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_characterMatchAtEnd;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'E' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_characterMatchInMiddle;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'C' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_stringMatchAtBeginning;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'AB' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_stringMatchAtEnd;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'DE' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_stringMatchInMiddle;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'BCD' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_caseDifference;\n\n   assertNumericEquals( 0 : countOccurrencesOf( 'bcd' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_longerSearch;\n\n   assertNumericEquals( 0 : countOccurrencesOf( 'ABCDE' : 'BCD' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_allCharacterMatches;\n\n   assertNumericEquals( 3 : countOccurrencesOf( 'a' : 'aaa' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_allStringMatches;\n\n   assertNumericEquals( 3 : countOccurrencesOf( 'aB' : 'aBaBaB' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_nonRepeatingMatch;\n\n   assertNumericEquals( 2 : countOccurrencesOf( 'ABA' : 'ABABABA' ) );\n\nend-proc;","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data","task":"unittest","difficulty":2,"language":"rpg4ff"}}
{"id":"CountOccuranceOf_rpgunit","input_data":"dcl-proc countOccurrencesOf export;\n\n    dcl-pi *n int( 10 );\n       search  varchar( 64000 ) const;\n       source  varchar( 64000 ) const;\n    end-pi;\n\n    dcl-s position      int( 10 );\n    dcl-s result        int( 10 );\n    dcl-s searchLength  int( 10 );\n    dcl-s sourceLength  int( 10 );\n\n    result = 0;\n    position = 1;\n\n    searchLength = %len( search );\n    sourceLength = %len( source );\n\n    if ( searchLength > 0 );\n\n       doW ( position <= ( sourceLength - searchLength + 1 ));\n\n          if ( %subst( source : position : searchLength ) = search );\n             result += 1;\n             position += searchLength;\n          else;\n             position += 1;\n          endIf;\n\n       endDo;\n\n    endIf;\n\n    return result;\n\nend-proc;","context":"Rules.mk\nTEXTUTILS.SRVPGM: TEXTUTILS.BND TEXTUTILS.MODULE\nTEXTUTILS.BNDDIR: TEXTUTILS.BNDDIR TEXTUTILS.SRVPGM\n\nTEXTUTIL.BNDSRC\n/* Have to delete the BNDDIR, or it will always be older than the source */\n/* because the CRTBNDDIR will fail the second time and only the ADDBNDDIRE is executed */     \n!DLTOBJ OBJ(&O/&N) OBJTYPE(*BNDDIR)\nCRTBNDDIR BNDDIR(&O/&N)\nADDBNDDIRE BNDDIR(&O/&N) +\n   OBJ((*LIBL/TEXTUTIL *SRVPGM))\n\nTEXTUTILS.BND\n\n             strPgmExp  pgmLvl( *current ) signature( 'TEXTUTILS V1.00' )\n\n                export     symbol( trimAndUpperCase )\n                export     symbol( trimAndLowerCase )\n                export     symbol( toUpperCase )\n                export     symbol( toLowerCase )\n                export     symbol( parseDate )\n                export     symbol( getEnvironmentVariable )\n                export     symbol( toStringJsonArray )\n                export     symbol( scanReverse )\n                export     symbol( toYN )\n                export     symbol( toQuotedYN )\n                export     symbol( convertTimeStampToStringDate )\n                export     symbol( removeUnprintable )\n                export     symbol( isLetter )\n                export     symbol( isDigit )\n                export     symbol( toStringJsonArrayLarger )\n                export     symbol( splitStringMaxLength )\n                export     symbol( removeBlanks )\n                export     symbol( startsWith )\n                export     symbol( endsWith )\n                export     symbol( countOccurrencesOf )\n\n             endPgmExp\n\nTEXTUTIL_H.RPGLEINC\n**free\n// External procedure definitions for TextUtils\n//\n// Why:  Convert trim and to uppercase or trim and lowercase depending on the\n//       the procedure that is called trimAndToUpperCase or trimAndTolowerCase\n//       you can also call toLowerCase and toUpperCase if you want just to uppercase or lowercase\n//        the value and ignore the triming.\n\n\ndcl-c EMPTY_ISO_DATE  '0001-01-01';\ndcl-c EMPTY_DATE     d'0001-01-01';\n\ndcl-c CARRIAGE_RETURN           x'0D';\ndcl-c LINE_FEED                 x'25';\ndcl-c CARRIAGE_RETURN_LINE_FEED x'0D25';\ndcl-c LINE_FEED_CARRIAGE_RETURN x'250D';\n\ndcl-c SINGLE_QUOTE              '''';\ndcl-c DOUBLE_QUOTE              '\"'; \n\nDcl-s myvar varchar( 22 ) template; \n\nDcl-ds mods qualified dim( 1 ) template; \n     Myvarchar  varchar( 10 ); \n     Medate     date; \nEnd-ds; \n\n// convert the string time stamp to the string date.\ndcl-pr convertTimeStampToStringDate varchar( 10 );\n    stringTimeStamp varchar( 10 ) value;\nend-pr;\n\n// countOccurrencesOf\n//\n// Return the number of times a source string contains a\n// search string.\n//\n// A specific location in the source string won't match\n// the search string multiple times. For example, if you\n// search for:\n//\n//     ABA\n//\n// in:\n//\n//     ABABABA\n//\n// you will get a result of 2 (matches start at positions 1\n// and 5), not 3 (the match starting at 3 doesn't count).\n//\ndcl-pr countOccurrencesOf int( 10 );\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\n// endsWith\n//\n// Return *ON if the source string ends with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #startsWith\n//\ndcl-pr endsWith ind;\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\ndcl-pr getEnvironmentVariable varchar(150);\n      environmentVariableName char(64) value;\nend-pr;\n\n//******************************************************************************\n// isDigit\n//\n// Return *ON if the character is a numeric digit.\n//\n// @see isLetter\n\ndcl-pr isDigit ind;\n     characterToTest char( 1 ) const;\nend-pr;\n\n//******************************************************************************\n// isLetter\n//\n// Return *ON if the character is an upper-case or lower-case letter.\n//\n// @see isDigit\n\ndcl-pr isLetter ind;\n     characterToTest char( 1 ) const;\nend-pr;\n\ndcl-pr parseDate date;\n     *n varchar(50) value;\nend-pr;\n\n//-------------------------------------------------------------------------------------------------\n//  remove the blanks from the string that has been passed. This can be anywhere in the string.\n//-------------------------------------------------------------------------------------------------\ndcl-pr removeBlanks varchar( 64000 );\n    inputString     varchar( 64000 ) const;\nend-pr;\n\n//******************************************************************************\n// removeUnprintable\n//\n// Remove characters that cannot be printed, specifically control characters\n// and those not normally entered into input fields.\n\ndcl-pr removeUnprintable  varchar( 64000 );\n     *n varchar( 64000 ) const;\nend-pr;\n\n//*******************************************************************************************\n// scanReverse\n// This procedure will take a string and scan the last five characters, looking for the passed in\n// delimiter. If the delimiter is not found then it starts working itself backwards until you are at\n// beginning of the string. This returns the position ( Int value ) of the requested delimiter. or 0\n// the delimiter is not found.\n//*******************************************************************************************\ndcl-pr scanReverse uns( 10 );\n    comment varchar( 3500 ) value;\n    delimiter varchar( 6 ) value;\n    startPoint uns( 10 ) value options(*nopass);\nend-pr;\n\n// splitStringMaxLength\n//\n// Take a long string and break it up into smaller substrings based off of inputted max substring\n// length and optional separators(see below for rules). The subprocedure will try not to split up\n// any words, if the max length does not land on the separator, the process will step back until\n// it can find one. If a separator is not found, it will split the string at the max length mark.\n// When a separator is found, the string will be split at that point and the separator will be\n// deleted.\n//\n// @return\n//   If the split was successfull the indicatior will be *on. Otherwise the indicator is returned\n//   *off, check EVBLOG for more details on the error.\n//\n// @param callback\n//   A subprocedure in the program that is calling this procedure. The callback subprocedure will\n//   be called for each substring it splits off of the source string.\n//   We will send three parameters to your callback procedure:\n//      splitString  - the substring that has been split from the source string\n//      splitIndex   - the sequence number of the splitString.\n//      callbackData - will send what was sent to this subprocedure in the callbackData parameter.\n//                     It is also subject to change in your callback subprocedure.\n//\n// @param source\n//   The full string you wish to be split\n//\n// @param maxResultLength\n//   The maximum substring size you want returned. Must be greater that one.\n//\n// @param separator (optional)\n//   The separator will default to a space when not specified. If, however,\n//   you pass it an empty string ('') the procedure will not use a separator, instead split the\n//   string at the max length regardless of where that lands. It is also possible to pass the\n//   procedure multiple separators. For example if you pass the separator something like this '_- '\n//   the procedure will use underscore, dash, or space as a separator; whichever it finds first.\n//\n// @param callbackData (optional)\n//   This can be any variable type or data structure you like from your calling program. If you\n//   choose to pass something in nthe callbackData, it will be sent to your callback subprocedure.\n//   Example: subprocedure splitStringMaxLengthCallback05 in TEXTUTIL_T used as an int callbackData\n//   to increment each time the subprocedure was called in order to validate the splitIndex.\n//\ndcl-pr splitStringMaxLength ind;\n   callback        pointer( *proc )    const;\n   source          varchar( 3000000 )  const;\n   maxLength       int(          10 )  const;\n   separators      varchar(      20 )  const options( *noPass : *omit );\n   callbackData    pointer             const options( *noPass : *omit );\nend-pr;\n\n// startsWith\n//\n// Return *ON if the source string starts with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #endsWith\n//\ndcl-pr startsWith ind;\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\n// convert the string to lowercase.\ndcl-pr toLowerCase varchar(64000);\n     *n varchar(64000) value;\nend-pr;\n\n//******************************************************************************\n// toQuotedYN\n//\n// Return the value from toYN and put single quotes around it so it can\n// easily be added to an SQL string.\n//\n// see also toYN\n\ndcl-pr toQuotedYN char( 3 );\n     source varchar( 10 ) const;\nend-pr;\n\n//******************************************************************************\n// toStringJsonArray\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation.\n//\n// Examples:\n//\n// Input:\n//     (null)\n// Output:\n//     (empty string)\n//\n// Input:\n//     (array list without any elements)\n// Output:\n//     []\n//\n// Input:\n//     ABC\n// Output:\n//     [\"ABC\"]\n//\n// Input:\n//     ABC, 123\n// Output:\n//     [\"ABC\",\"123\"]\n//\n// Input:\n//     \"Quoted\" Text\n// Output:\n//     [\"\\\"Quoted\\\" Text\"]\n\ndcl-pr toStringJsonArray varchar( 65535 );\n     arrayList pointer const;\nend-pr;\n\n//******************************************************************************\n// toStringJsonArrayLarger\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation. This can handle larger results\n// than toStringJsonArray.\n//\n// Examples:\n//\n// Input:\n//     (null)\n// Output:\n//     (empty string)\n//\n// Input:\n//     (array list without any elements)\n// Output:\n//     []\n//\n// Input:\n//     ABC\n// Output:\n//     [\"ABC\"]\n//\n// Input:\n//     ABC, 123\n// Output:\n//     [\"ABC\",\"123\"]\n//\n// Input:\n//     \"Quoted\" Text\n// Output:\n//     [\"\\\"Quoted\\\" Text\"]\n\ndcl-pr toStringJsonArrayLarger varchar( 2000000 );\n     arrayList pointer const;\nend-pr;\n\n// convert the string to uppercase.\ndcl-pr toUpperCase varchar(64000);\n    *n varchar(64000) value;\nend-pr;\n\n//******************************************************************************\n// toYN\n//\n// Take an input value, probably received from a browser or JSON request,\n// and return a Y or N character value appropriate for storing in 'boolean'\n// database column. Anything like Y, yes, true, 1, ... will result in a\n// Y response while anything else will return an N.\n//\n// see also toQuotedYN\n\ndcl-pr toYN char( 1 );\n     source varchar( 10 ) const;\nend-pr;\n\n// trim and convert the string to lowercase.\ndcl-pr trimAndLowerCase varchar(64000);\n     *n varchar(64000) value;\nend-pr;\n\n// trim and convert the string to uppercase.\ndcl-pr trimAndUpperCase varchar(64000);\n    *n varchar(64000) value;\nend-pr;","output":"countOccuranceOf.test.rpgle\n**free\nctl-opt noMain;\n\n/include countOccuranceOf\n/include qinclude,TESTCASE\n\ndcl-proc test_countOccurrencesOf_emptySearchEmptySource export;\n   iEqual( 0 : countOccurrencesOf( '' : '' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_blankSearchEmptySource export;\n   iEqual( 0 : countOccurrencesOf( ' ' : '' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_emptySearchBlankSource export;\n   iEqual( 0 : countOccurrencesOf( '' : ' ' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_blankSearchBlankSource export;\n   iEqual( 1 : countOccurrencesOf( ' ' : ' ' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_characterMatchAtBeginning export;\n   iEqual( 1 : countOccurrencesOf( 'A' : 'ABCDE' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_characterMatchAtEnd export;\n   iEqual( 1 : countOccurrencesOf( 'E' : 'ABCDE' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_characterMatchInMiddle export;\n   iEqual( 1 : countOccurrencesOf( 'C' : 'ABCDE' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_stringMatchAtBeginning export;\n   iEqual( 1 : countOccurrencesOf( 'AB' : 'ABCDE' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_stringMatchAtEnd export;\n   iEqual( 1 : countOccurrencesOf( 'DE' : 'ABCDE' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_stringMatchInMiddle export;\n   iEqual( 1 : countOccurrencesOf( 'BCD' : 'ABCDE' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_caseDifference export;\n   iEqual( 0 : countOccurrencesOf( 'bcd' : 'ABCDE' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_longerSearch export;\n   iEqual( 0 : countOccurrencesOf( 'ABCDE' : 'BCD' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_allCharacterMatches export;\n   iEqual( 3 : countOccurrencesOf( 'a' : 'aaa' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_allStringMatches export;\n   iEqual( 3 : countOccurrencesOf( 'aB' : 'aBaBaB' ) );\nend-proc;\n\ndcl-proc test_countOccurrencesOf_nonRepeatingMatch export;\n   iEqual( 2 : countOccurrencesOf( 'ABA' : 'ABABABA' ) );\nend-proc;\n\ntesting.json\n{\n    \"RUCRTRPG\": {\n        \"module\": \"COO\",\n        \"incDir\": \"context\"\n    }\n}","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data","task":"unittest","difficulty":2,"language":"rpg4ff"}}
{"id":"TEXTUTILS","input_data":"**free\nCTL-OPT noMain;\nCTL-OPT bndDir( 'ECDCPARAM' : 'EVBLOG' : 'HTTPSVR' : 'OSSILE/OSSILE' );\n\n// Program Name  TextUtils\n//\n// Why:  utility file that can be used across all applications.\n//\n// TO USE:\n//   You need to include the header file as a copy member /copy TEXTUTIL_H\n//   and the binddir as a control opt.\n//  ( H SPEC) H BNDDIR('TEXTUTILS') or ctl-opt BNDDIR('TEXTUTILS');\n//  then you are able to call the procedure as myvariable = toUpperCase(Myvariable);\n\n/copy TEXTUTIL_H\n\n/copy ArrayLst_H\n/copy EcDcParm_H\n/copy EVBLOG_H\n/copy UTIL_H\n/copy psds\n\ndcl-c Uppercase const('ABCDEFGHIJKLMNOPQRSTUVWXYZ');\ndcl-c Lowercase const('abcdefghijklmnopqrstuvwxyz');\n\ndcl-c PROGRAM_NAME 'TEXTUTILS';\n\n//---------------------------------------------------------------------------\n// convert a string timestamp to a string date by passing a timestamp as a string,\n// finding the T and substringing the date out. This can return the date as string or blank.\n// this will uppercase the timestamp coming in so you dont have to.\n//--------------------------------------------------------------------------\ndcl-proc convertTimeStampToStringDate export;\n\n    dcl-pi convertTimeStampToStringDate varchar( 10 );\n         stringTimeStamp varchar( 10 ) value;\n    end-Pi;\n\n   dcl-s stringDate varchar( 10 );\n   dcl-s position uns( 5 );\n\n   stringTimeStamp = trimAndUpperCase( stringTimeStamp );\n\n   monitor;\n\n    Dcl-ds mymodes likeds( mods ) dim( 1 ); \n\n\n   Myvar = \"hello\";\n\n  if ( stringTimeStamp <> '' );\n     position = %scan( 'T' : stringTimeStamp : 1 );\n\n     if ( position > 0 );\n\n         // scan gives us the exact position.\n         // We need to get the position before the T in the timestamp.\n\n          position = position - 1;\n          stringDate = %subst(stringTimeStamp: position - %len( stringTimeStamp )  );\n\n     endif;\n\n  endIf;\n\n  on-error;\n     evblog_log(UTIL_APPLICATION_NAME:\n               'TEXTUTILS':\n               'convertTimeStampToStringDate':\n                EVBLOG_ERROR:\n               'substring error':\n                'value passed: ' + %char(position) + ' timestamp ' + stringTimeStamp );\n  endMon;\n\n return stringDate;\nend-Proc;\n\n// countOccurrencesOf\n//\n// Return the number of times a source string contains a\n// search string.\n//\ndcl-proc countOccurrencesOf export;\n\n    dcl-pi *n int( 10 );\n       search  varchar( 64000 ) const;\n       source  varchar( 64000 ) const;\n    end-pi;\n\n    dcl-s position      int( 10 );\n    dcl-s result        int( 10 );\n    dcl-s searchLength  int( 10 );\n    dcl-s sourceLength  int( 10 );\n\n    result = 0;\n    position = 1;\n\n    searchLength = %len( search );\n    sourceLength = %len( source );\n\n    if ( searchLength > 0 );\n\n       doW ( position <= ( sourceLength - searchLength + 1 ));\n\n          if ( %subst( source : position : searchLength ) = search );\n             result += 1;\n             position += searchLength;\n          else;\n             position += 1;\n          endIf;\n\n       endDo;\n\n    endIf;\n\n    return result;\n\nend-proc;\n\n// endsWith\n//\n// Return *ON if the source string ends with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #startsWith\n//\ndcl-proc endsWith export;\n\n    dcl-pi *n ind;\n       search  varchar( 64000 ) const;\n       source  varchar( 64000 ) const;\n    end-pi;\n\n    if ( %len( search ) = 0 );\n       return *on;\n    elseIf ( %len( search ) > %len( source ));\n       return *off;\n    else;\n       return ( search = %subst( source\n                               : %len( source ) - %len( search ) + 1\n                               : %len( search )));\n    endIf;\n\nend-proc;\n\n// getEnvironmentVariable\n//\ndcl-proc getEnvironmentVariable export;\n\n    dcl-pi getEnvironmentVariable varchar(150);\n        environmentVariableName char(64) value;\n    end-Pi;\n\n   dcl-pr retrieveEnvironment ExtProc('QtmhGetEnv');\n       buffer char(2048);\n       bufferLength int(10);\n       responseLength int(10);\n       environmentName char(64);\n       environmentLength int(10);\n       errorBuffer char(16);\n   end-Pr;\n\n   dcl-s buffer char(2048);\n   dcl-s bufferLength int(10) inz(%size(buffer));\n   dcl-s responseLength int(10);\n   dcl-s environmentLength int(10);\n   dcl-s errorBuffer char(16);\n\n   environmentLength = %len(%trim(environmentVariableName));\n\n   retrieveEnvironment( buffer\n                       :bufferLength\n                       :responseLength\n                       :environmentVariableName\n                       :environmentLength\n                       :errorBuffer );\n\n   %subst( buffer: responseLength +1 ) = ' ';\n\n   return  %trim(buffer);\n\nend-proc;\n\n//---------------------------------------------------------------------------\n// isDigit\n//\n// Return *ON if the character is a numeric digit.\n//\n// @see isLetter\n\ndcl-proc isDigit export;\n\n   dcl-pi *n ind;\n      characterToTest char( 1 ) const;\n   end-pi;\n\n   dcl-s result ind;\n\n   result = ( characterToTest >= '0' ) and ( characterToTest <= '9' );\n\n   return result;\n\nend-proc;\n\n//---------------------------------------------------------------------------\n// isLetter\n//\n// Return *ON if the character is an upper-case or lower-case letter.\n//\n// @see isDigit\n\ndcl-proc isLetter export;\n\n   dcl-pi *n ind;\n      characterToTest char( 1 ) const;\n   end-pi;\n\n   dcl-s result      ind;\n   dcl-s unaccented  char( 1 );\n\n   if ( %scan( characterToTest : uppercase ) > 0 );\n      result = *on;\n   elseIf ( %scan( characterToTest : lowercase ) > 0 );\n      result = *on;\n   else;\n\n      if ( %scan( unaccented : uppercase ) > 0 );\n         result = *on;\n      elseIf ( %scan( unaccented : lowercase ) > 0 );\n         result = *on;\n      else;\n         result = *off;\n      endIf;\n\n   endIf;\n\n   return result;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n//  parseDate\n//  This procedure takes the character variable, and convert the character value to a date.\n//----------------------------------------------------------------------------------------------\n\ndcl-proc parseDate export;\n\n   dcl-pi parseDate date;\n      incomingDate varchar(50) value;\n   end-pi;\n\n   dcl-c PROCEDURE_NAME 'parseDate';\n\n   dcl-s dateToParse             varchar( 50 );\n   dcl-s dateFormat              varchar( 50 );\n   dcl-s timeSeparator           packed(   5 );\n   dcl-s result                  date;\n   dcl-s separator               char(     1 );\n   dcl-s firstSeparatorPosition  int(      5 );\n   dcl-s lastSeparatorPosition   int(      5 );\n\n   // remove any time portion\n\n   timeSeparator = %scan( 'T' : incomingDate );\n\n   if ( timeSeparator > 0 );\n      dateToParse = %trim( %subst( incomingDate : 1 : timeSeparator - 1 ) );\n   else;\n      dateToParse = %trim( incomingDate );\n   endIf;\n\n   // do we have enough information?\n\n   if ( %len( dateToParse ) = 0 );\n      return EMPTY_DATE;\n   elseIf ( %len( dateToParse ) < 5 );\n\n      evblog_log( UTIL_APPLICATION_NAME : PROGRAM_NAME : PROCEDURE_NAME\n                : EVBLOG_DEBUG\n                : 'invalid date'\n                : incomingDate );\n\n      return EMPTY_DATE;\n\n   endIf;\n\n   // figure out what separator we've got\n\n   firstSeparatorPosition = %scan( '/' : dateToParse );\n   if ( firstSeparatorPosition > 0 );\n      separator = '/';\n   else;\n\n      firstSeparatorPosition = %scan( '-' : dateToParse );\n      if ( firstSeparatorPosition > 0 );\n         separator = '-';\n      else;\n\n         firstSeparatorPosition = %scan( '.' : dateToParse );\n         if ( firstSeparatorPosition > 0 );\n            separator = '.';\n         else;\n\n            evblog_log( UTIL_APPLICATION_NAME : PROGRAM_NAME : PROCEDURE_NAME\n                      : EVBLOG_DEBUG\n                      : 'unrecognized date separator'\n                      : incomingDate );\n\n            return EMPTY_DATE;\n\n         endIf;\n      endIf;\n   endIf;\n\n   result = EMPTY_DATE;\n   lastSeparatorPosition = %scanr( separator : dateToParse );\n\n   if ( lastSeparatorPosition <= firstSeparatorPosition );\n\n      evblog_log( UTIL_APPLICATION_NAME : PROGRAM_NAME : PROCEDURE_NAME\n                : EVBLOG_DEBUG\n                : 'invalid date'\n                : incomingDate );\n\n   else;\n\n      monitor;\n\n         select;\n            when ( separator = '/' );\n\n               // slashes are the most common format; they are all USA and\n               // the only variation is 2-digit or 4-digit year at the end\n\n               if ( %len( dateToParse ) - lastSeparatorPosition = 1 );\n                  dateToParse = %subst( dateToParse : 1 : lastSeparatorPosition ) + '0' +\n                                %subst( dateToParse : lastSeparatorPosition + 1 );\n               endIf;\n\n               if ( lastSeparatorPosition - firstSeparatorPosition = 2 );\n                  dateToParse = %subst( dateToParse : 1 : firstSeparatorPosition ) + '0' +\n                                %subst( dateToParse : firstSeparatorPosition + 1 );\n                  lastSeparatorPosition += 1;\n               endIf;\n\n               if ( firstSeparatorPosition = 2 );\n                  dateToParse = '0' + dateToParse;\n                  firstSeparatorPosition += 1;\n                  lastSeparatorPosition += 1;\n               endIf;\n\n               if ( %len( dateToParse ) - lastSeparatorPosition > 2 );\n\n                  // 4-digit year (ok, it could be a 3-digit year, too)\n\n                  dateFormat = '*USA';\n                  result = %date( dateToParse : *usa );\n\n               else;\n\n                  // 2-digit year (ok, it could be a 1-digit year, too)\n\n                  dateFormat = '*MDY';\n                  result = %date( dateToParse : *mdy );\n\n               endIf;\n\n            when ( separator = '-' );\n\n               // dash separator is either ISO (starts with a 4-digit number)\n               // or USA using an alternate separator (ends with the year)\n\n               if ( firstSeparatorPosition = 5 );\n\n                  dateFormat = '*ISO';\n                  result = %date( dateToParse : *iso );\n\n               else;\n\n                  // variation on the USA format, thus the block is similar to the slash separator\n\n                  if ( %len( dateToParse ) - lastSeparatorPosition = 1 );\n                     dateToParse = %subst( dateToParse : 1 : lastSeparatorPosition ) + '0' +\n                                   %subst( dateToParse : lastSeparatorPosition + 1 );\n                  endIf;\n\n                  if ( lastSeparatorPosition - firstSeparatorPosition = 2 );\n                     dateToParse = %subst( dateToParse : 1 : firstSeparatorPosition ) + '0' +\n                                   %subst( dateToParse : firstSeparatorPosition + 1 );\n                     lastSeparatorPosition += 1;\n                  endIf;\n\n                  if ( firstSeparatorPosition = 2 );\n                     dateToParse = '0' + dateToParse;\n                     firstSeparatorPosition += 1;\n                     lastSeparatorPosition += 1;\n                  endIf;\n\n                  if ( %len( dateToParse ) - lastSeparatorPosition > 2 );\n\n                     // 4-digit year (ok, it could be a 3-digit year, too)\n\n                     // we don't have a *USA- format so we'll replace the\n                     // dash separator with a slash for the %date conversion\n\n                     dateToParse = %subst( dateToParse : 1 : firstSeparatorPosition - 1 ) +\n                                   '/' +\n                                   %subst( dateToParse\n                                         : firstSeparatorPosition + 1\n                                         : lastSeparatorPosition - firstSeparatorPosition - 1 ) +\n                                   '/' +\n                                   %subst( dateToParse : lastSeparatorPosition + 1 );\n\n                     dateFormat = '*USA-';\n                     result = %date( dateToParse : *usa );\n\n                  else;\n\n                     // 2-digit year (ok, it could be a 1-digit year, too)\n\n                     dateFormat = '*MDY-';\n                     result = %date( dateToParse : *mdy- );\n\n                  endIf;\n\n               endIf;\n\n            when ( separator = '.' );\n\n               // only supported format is European (dd.mm.yyyy)\n\n               if ( lastSeparatorPosition - firstSeparatorPosition = 2 );\n                  dateToParse = %subst( dateToParse : 1 : firstSeparatorPosition ) + '0' +\n                                %subst( dateToParse : firstSeparatorPosition + 1 );\n                  lastSeparatorPosition += 1;\n               endIf;\n\n               if ( firstSeparatorPosition = 2 );\n                  dateToParse = '0' + dateToParse;\n                  firstSeparatorPosition += 1;\n                  lastSeparatorPosition += 1;\n               endIf;\n\n               dateFormat = '*EUR';\n               result = %date( dateToParse : *eur );\n\n         endSl;\n\n      on-error;\n\n         evblog_log( UTIL_APPLICATION_NAME : PROGRAM_NAME : PROCEDURE_NAME\n                   : EVBLOG_DEBUG\n                   : 'invalid ' + dateFormat + ' date'\n                   : incomingDate );\n\n         return EMPTY_DATE;\n\n      endMon;\n\n   endIf;\n\n   return result;\n\nend-proc;\n\n//-------------------------------------------------------------------------------------------------\n//  remove the blanks from the string that has been passed. This can be anywhere in the string.\n//-------------------------------------------------------------------------------------------------\ndcl-proc removeBlanks export;\n\n    dcl-pi removeBlanks varchar( 64000 );\n        inputString     varchar( 64000 ) const;\n    end-pi;\n\n    dcl-s useableInputString    varchar( 64000 );\n\n    useableInputString = inputString;\n\n    dow %scan( ' ' : useableInputString  ) > *zeros;\n\n       useableInputString = %replace( '' : useableInputString :\n                            %scan( ' ' : useableInputString ) : 1 );\n\n    endDo;\n\n    return useableInputString;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n// removeUnprintable\n//\n// Remove characters that cannot be printed, specifically control characters\n// and those not normally entered into input fields.\n//----------------------------------------------------------------------------------------------\ndcl-proc removeUnprintable export;\n\n    dcl-pi *n varchar( 64000 );\n        source varchar( 64000 ) const;\n    end-pi;\n\n    // there are 158 printable EBCDIC characters and 98 unprintable ones;\n    // we'll look for unprintable ones and keep everything else\n\n    dcl-c UNPRINTABLE x'000102030405060708090A0B0C0D0E0F+\n                        101112131415161718191A1B1C1D1E1F+\n                        2122232425262728292A2B2C2D2E2F+\n                        303132333435363738393A3B3C3D3E3F+\n                        414A+\n                        6A+\n                        8A8B8C8E8F+\n                        909A9B9D9F+\n                        A0AAABACAEAF+\n                        B3B4B5B6B7B8B9BCBDBEBF+\n                        CA+\n                        DA+\n                        E1EA+\n                        FA';\n\n    dcl-s char   char(        1 );\n    dcl-s i      int(         5 );\n    dcl-s result varchar( 64000 );\n\n    result = '';\n\n    for i = 1 to %len( source );\n       char = %subst( source : i : 1 );\n       if ( %scan( char : UNPRINTABLE ) = 0 );\n          result += char;\n       endIf;\n    endFor;\n\n    return result;\n\nend-proc;\n\n//*******************************************************************************************\n// scanReverse\n// This procedure will take a string and scan the last five characters, looking for the passed in\n// delimiter. If the delimiter is not found then it starts working itself backwards until you are at\n// beginning of the string. This returns the position ( Int value ) of the requested delimiter. or 0\n// the delimiter is not found.\n//*******************************************************************************************\ndcl-proc scanReverse export;\n    dcl-Pi scanReverse uns( 10 );\n        comment varchar( 3500 ) value;\n        delimiter varchar( 6 ) value;\n        startPoint uns( 10 ) value options(*nopass);\n    end-Pi;\n\n     dcl-s length uns( 10 ) inz(1);\n     dcl-s position uns( 10 );\n     dcl-s startPosition uns( 10 );\n\n     if ( %parms = 3);\n         startPosition = startPoint;\n     else;\n         startPosition = %len( comment );\n     endIf;\n\n\n\n      // keep going backwards until you have reached the beginning of the String.\n     dou ( startPosition < 1 );\n\n       if ( startPosition <= 5 );\n         position = %scan( delimiter: comment : startPosition );\n       else;\n        position = %scan( delimiter: comment : startPosition - 5 );\n       endIf;\n\n        if ( position > 0 );\n            return position;\n        endIf;\n\n        // if we did not find it then remove five from the length and try again.\n        if ( startPosition >= 5 );\n         startPosition = startPosition -5;\n        else;\n         startPosition = 0;\n\n        endIf;\n\n     endDo;\n\n    return position;\nend-Proc;\n\n//--------------------------------------------------------------------------------------------------\n// splitStringMaxLength\n//\n// // Take a long string and break it up into smaller substrings based off of inputted max substring\n// length and optional separators(see below for rules). The subprocedure will try not to split up\n// any words, if the max length does not land on the separator, the process will step back until\n// it can find one. If a separator is not found, it will split the string at the max length mark.\n// When a separator is found, the string will be split at that point and the separator will be\n// deleted.\n//\n// @return\n//   If the split was successfull the indicatior will be *on. Otherwise the indicator is returned\n//   *off, check EVBLOG for more details on the error.\n//\n// @param callback\n//   A subprocedure in the program that is calling this procedure. The callback subprocedure will\n//   be called for each substring it splits off of the source string. Your callback procedure should\n//   return a success/failure indicator. We will send three parameters to your callback procedure:\n//      splitString  - the substring that has been split from the source string\n//      splitIndex   - the sequence number of the splitString.\n//      callbackData - will send what was sent to this subprocedure in the callbackData parameter.\n//                     It is also subject to change in your callback subprocedure.\n//\n// @param source\n//   The full string you wish to be split\n//\n// @param maxResultLength\n//   The maximum substring size you want returned. Must be greater that one.\n//\n// @param separator (optional)\n//   The separator will default to a space when not specified. If, however,\n//   you pass it an empty string ('') the procedure will not use a separator, instead split the\n//   string at the max length regardless of where that lands. It is also possible to pass the\n//   procedure multiple separators. For example if you pass the separator something like this '_- '\n//   the procedure will use underscore, dash, or space as a separator; whichever it finds first.\n//\n// @param callbackData (optional)\n//   This can be any variable type or data structure you like from your calling program. If you\n//   choose to pass something in nthe callbackData, it will be sent to your callback subprocedure.\n//   Example: subprocedure splitStringMaxLengthCallback05 in TEXTUTIL_T used as an int callbackData\n//   to increment each time the subprocedure was called in order to validate the splitIndex.\n//--------------------------------------------------------------------------------------------------\n\ndcl-proc splitStringMaxLength export;\n\n   dcl-pi *n ind;\n      callback        pointer( *proc )    const;\n      source          varchar( 3000000 )  const;\n      maxLength       int(          10 )  const;\n      separators      varchar(      20 )  const options( *noPass : *omit );\n      callbackData    pointer             const options( *noPass : *omit );\n   end-pi;\n\n   dcl-pr splitStringMaxLengthCallback ind extproc( callback );\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n      callbackData    pointer             const;\n   end-pr;\n\n   dcl-c PROCEDURE_NAME 'splitStringMaxLength';\n\n   dcl-s localCallbackData   pointer;\n   dcl-s result              ind;\n   dcl-s workSource          varchar( 3000000 );\n   dcl-s workSeparators      varchar(      20 );\n   dcl-s separatorsArray     char(          1 ) dim( 20 );\n   dcl-s separatorIndex      int(          10 );\n   dcl-s splitPositionArray  int(          10 ) dim( 20 );\n   dcl-s splitPosition       int(          10 );\n   dcl-s sourcePositionIndex int(          10 );\n   dcl-s splitString         varchar( 3000000 );\n   dcl-s splitIndex          int(          10 ) inz( 1 );\n\n   // Parameter validation and initialization\n\n   result = *on;\n\n   workSource = %trimr( source );\n   if %len( workSource ) < 1;\n      result = *off;\n      evblog_log( UTIL_APPLICATION_NAME\n                : PROGRAM_NAME\n                : PROCEDURE_NAME\n                : EVBLOG_WARNING\n                : 'Error in workSource'\n                : 'Source string must be at least 1 character. source lenght = ' +\n                  %char( %len( workSource ) ) + '.'\n                );\n   endIf;\n\n   if maxLength < 2;\n      result = *off;\n      evblog_log( UTIL_APPLICATION_NAME\n                : PROGRAM_NAME\n                : PROCEDURE_NAME\n                : EVBLOG_WARNING\n                : 'Error on maxLength'\n                : 'Max Length must be greater than 1. maxLength = ' + %char( maxLength ) + '.'\n                );\n   endIf;\n\n   if callback = *null;\n      result = *off;\n      evblog_log( UTIL_APPLICATION_NAME\n                : PROGRAM_NAME\n                : PROCEDURE_NAME\n                : EVBLOG_WARNING\n                : 'Error on callback'\n                : 'Callback procedure must sent to this procedure. callback = NULL'\n                );\n   endIf;\n\n   //Set optional parameters\n\n   if %parms = 3;\n     workSeparators = ' ';\n     localCallbackData = *null;\n   endIf;\n   if %parms > 3;\n      if %addr( separators ) = *null;\n         workSeparators = ' ';\n      else;\n         workSeparators = separators;\n      endIf;\n   endIf;\n   if %parms > 4;\n      if %addr( callbackData ) = *null;\n         localCallbackData = *null;\n      else;\n         localCallbackData = callbackData;\n      endIf;\n   endIf;\n\n   if ( result );\n\n      if %len( workSeparators ) > 0;\n\n         // Split at frist separator found then remove separator.\n\n         // Build separator array\n\n         for separatorIndex = 1 to %len( workSeparators );\n\n            separatorsArray( separatorIndex ) = %subst( workSeparators : separatorIndex : 1 );\n            splitPositionArray ( separatorIndex ) = 0;\n\n         endFor;\n\n         //Split string\n\n         dow ( %len( workSource ) > maxLength ) and result;\n\n            // Find the position of each separator within max lenght\n\n            splitPositionArray = %scanr( separatorsArray : workSource : 1 : maxLength );\n\n            // Find the separator with the largest position.\n\n            splitPosition = 0;\n            for sourcePositionIndex = 1 to %len( workSeparators );\n\n               if splitPosition < splitPositionArray( sourcePositionIndex );\n                  splitPosition = splitPositionArray( sourcePositionIndex );\n               endIf;\n\n            endFor;\n\n            if splitPosition = 0;\n\n               // no separator found, split at max length (no data removed).\n\n               splitString = %subst( workSource : 1 : maxLength );\n               workSource = %subst( workSource : maxlength + 1 : %len( workSource ) - maxLength );\n\n            else;\n\n               // Split at separator and remove separator\n\n               splitString = %subst( workSource : 1 : splitPosition - 1 );\n               workSource = %subst( workSource : splitPosition + 1\n                                  : %len( workSource ) - splitPosition );\n\n            endIf;\n\n            result = splitStringMaxLengthCallback( splitString\n                                                 : splitIndex\n                                                 : localCallbackData );\n\n            // If no indicator was returned by the callback procedure, assume it was successful\n\n            if result <> *off and result <> *on;\n               result = *on;\n            endIf;\n\n            splitIndex += 1;\n\n         endDo;\n\n         if ( %len( workSource ) > 0 ) and result;\n            result = splitStringMaxLengthCallback( workSource\n                                                 : splitIndex\n                                                 : localCallbackData );\n\n            // If no indicator was returned by the callback procedure, assume it was successful\n\n            if result <> *off and result <> *on;\n               result = *on;\n            endIf;\n\n         endIf;\n\n      else;\n\n         // No separator, split at max lenght without removing anything\n\n         splitIndex = 1;\n         dow ( %len(workSource) > maxLength ) and result;\n\n            splitString = %subst( workSource : 1 : maxLength );\n            workSource = %subst( workSource : maxlength + 1 : %len( workSource ) - maxLength );\n            result = splitStringMaxLengthCallback( splitString\n                                                 : splitIndex\n                                                 : localCallbackData );\n\n            // If no indicator was returned by the callback procedure, assume it was successful\n\n            if result <> *off and result <> *on;\n               result = *on;\n            endIf;\n\n            splitIndex += 1;\n\n         endDo;\n\n         if ( %len( workSource ) > 0 ) and result;\n            result = splitStringMaxLengthCallback( workSource\n                                                 : splitIndex\n                                                 : localCallbackData );\n\n            // If no indicator was returned by the callback procedure, assume it was successful\n\n            if result <> *off and result <> *on;\n               result = *on;\n            endIf;\n\n         endIf;\n      endIf;\n   endIf;\n\n   return result;\n\nend-proc;\n\n// startsWith\n//\n// Return *ON if the source string starts with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #endsWith\n//\ndcl-proc startsWith export;\n\n    dcl-pi *n ind;\n       search  varchar( 64000 ) const;\n       source  varchar( 64000 ) const;\n    end-pi;\n\n    if ( %len( search ) = 0 );\n       return *on;\n    elseIf ( %len( search ) > %len( source ));\n       return *off;\n    else;\n       return ( search = %subst( source : 1 : %len( search ) ));\n    endIf;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n//  toLowerCase\n//  This procedure takes the variable, and convert the character value to lower case.\n//----------------------------------------------------------------------------------------------\n\ndcl-proc toLowerCase export;\n\n   dcl-pi *n varchar(64000);\n      data varchar(64000) value;\n   end-pi;\n\n   dcl-s  newData varchar(64000);\n\n   newData = %xlate(Uppercase:Lowercase:data);\n\n   return newData;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n// toQuotedYN\n//\n// Return the value from toYN and put single quotes around it so it can\n// easily be added to an SQL string.\n//\n// see also toYN\n//----------------------------------------------------------------------------------------------\ndcl-proc toQuotedYN export;\n\n    dcl-pi *n char( 3 );\n        source varchar( 10 ) const;\n    end-pi;\n\n    return SINGLE_QUOTE + toYN( source ) + SINGLE_QUOTE;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n// toStringJsonArray\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation.\n//\n// see toStringJsonArrayLarger\n//----------------------------------------------------------------------------------------------\ndcl-proc toStringJsonArray export;\n\n    dcl-pi *n varchar( 65535 );\n        arrayList pointer const;\n    end-pi;\n\n    return toStringJsonArrayLarger( arrayList );\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n// toStringJsonArrayLarger\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation. This can handle larger results\n// than toStringJsonArray.\n//\n// see toStringJsonArray\n// since 3/16/21\n//----------------------------------------------------------------------------------------------\ndcl-proc toStringJsonArrayLarger export;\n\n    dcl-pi *n varchar( 2000000 );\n        arrayList pointer const;\n    end-pi;\n\n    dcl-s i      int( 20 );\n    dcl-s result varchar( 2000000 );\n\n    result = '';\n\n    if ( arrayList <> *null );\n\n        if not( arraylist_isEmpty( arrayList ));\n            for i = 0 to arraylist_getSize( arrayList ) - 1;\n\n                if ( i > 0 );\n                    result += ',';\n                endIf;\n\n                result += DOUBLE_QUOTE\n                        + encodeJsonSmaller( arraylist_getString( arrayList : i ) )\n                        + DOUBLE_QUOTE;\n\n            endFor;\n        endIf;\n\n        result = '[' + result + ']';\n\n    endIf;\n\n    return result;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n//  toUpperCase\n//  This procedure takes the variable, and convert the character value to upper case.\n//----------------------------------------------------------------------------------------------\n\ndcl-proc toUpperCase export;\n\n    dcl-pi *n varchar(64000);\n       data varchar(64000) value;\n    end-pi;\n\n    dcl-s  newData varchar(64000);\n\n    newData = %xlate(Lowercase:Uppercase:data);\n\n    return newData;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n// toYN\n//\n// Take an input value, probably received from a browser or JSON request,\n// and return a Y or N character value appropriate for storing in 'boolean'\n// database column. Anything like Y, yes, true, 1, ... will result in a\n// Y response while anything else will return an N.\n//\n// see also toQuotedYN\n//----------------------------------------------------------------------------------------------\ndcl-proc toYN export;\n\n    dcl-pi *n char( 1 );\n        source varchar( 10 ) const;\n    end-pi;\n\n    dcl-s ch        char(     1 );\n    dcl-s len       int(      3 );\n    dcl-s result    char(     1 );\n    dcl-s testValue varchar( 10 );\n\n    // standardize the input value\n\n    testValue = trimAndUpperCase( source );\n\n    len = %len( testValue );\n    if ( len > 1 );\n       ch = %subst( testValue : 1 : 1 );\n       if ( ch = SINGLE_QUOTE ) or ( ch = DOUBLE_QUOTE );\n          testValue = %subst( testValue : 2 );\n       endIf;\n    endIf;\n\n    len = %len( testValue );\n    if ( len > 1 );\n       ch = %subst( testValue : len );\n       if ( ch = SINGLE_QUOTE ) or ( ch = DOUBLE_QUOTE );\n          testValue = %subst( testValue : 1 : len - 1 );\n       endIf;\n    endIf;\n\n    // now translate to the output value\n\n    if ( testValue = 'Y' ) or\n       ( testValue = 'YES' ) or\n       ( testValue = 'TRUE' ) or\n       ( testValue = 'ON' ) or\n       ( testValue = '1' );\n       result = 'Y';\n    else;\n       result = 'N';\n    endIf;\n\n    return result;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n//  TrimAndlowerCase\n//  This procedure takes the variable, trims the length and calls toLowerCase to\n//  convert the character value to lower case.\n//----------------------------------------------------------------------------------------------\n\ndcl-proc trimAndLowerCase export;\n\n    dcl-pi *n varchar(64000);\n       data varchar(64000) value;\n    end-pi;\n\n    dcl-s  newData varchar(64000);\n\n    newData = %trim(toLowerCase(data));\n\n    return newData;\n\nend-proc;\n\n//----------------------------------------------------------------------------------------------\n//  TrimAndUpperCase\n//  This procedure takes the variable, trims the length and calls toUppercase to\n//  convert the character value to uppercase.\n//----------------------------------------------------------------------------------------------\ndcl-proc trimAndUpperCase export;\n\n    dcl-pi *n varchar(64000);\n      data varchar(64000) value;\n    end-pi;\n\n    dcl-s  newData varchar(64000);\n\n    newData = %trim(toUpperCase(data));\n\n    return newData;\n\nend-proc;","context":"Rules.mk\nTEXTUTILS.SRVPGM: TEXTUTILS.BND TEXTUTILS.MODULE\nTEXTUTILS.BNDDIR: TEXTUTILS.BNDDIR TEXTUTILS.SRVPGM\n\nTEXTUTIL.BNDSRC\n/* Have to delete the BNDDIR, or it will always be older than the source */\n/* because the CRTBNDDIR will fail the second time and only the ADDBNDDIRE is executed */     \n!DLTOBJ OBJ(&O/&N) OBJTYPE(*BNDDIR)\nCRTBNDDIR BNDDIR(&O/&N)\nADDBNDDIRE BNDDIR(&O/&N) +\n   OBJ((*LIBL/TEXTUTIL *SRVPGM))\n\nTEXTUTILS.BND\n\n             strPgmExp  pgmLvl( *current ) signature( 'TEXTUTILS V1.00' )\n\n                export     symbol( trimAndUpperCase )\n                export     symbol( trimAndLowerCase )\n                export     symbol( toUpperCase )\n                export     symbol( toLowerCase )\n                export     symbol( parseDate )\n                export     symbol( getEnvironmentVariable )\n                export     symbol( toStringJsonArray )\n                export     symbol( scanReverse )\n                export     symbol( toYN )\n                export     symbol( toQuotedYN )\n                export     symbol( convertTimeStampToStringDate )\n                export     symbol( removeUnprintable )\n                export     symbol( isLetter )\n                export     symbol( isDigit )\n                export     symbol( toStringJsonArrayLarger )\n                export     symbol( splitStringMaxLength )\n                export     symbol( removeBlanks )\n                export     symbol( startsWith )\n                export     symbol( endsWith )\n                export     symbol( countOccurrencesOf )\n\n             endPgmExp\n\nTEXTUTIL_H.RPGLEINC\n**free\n// External procedure definitions for TextUtils\n//\n// Why:  Convert trim and to uppercase or trim and lowercase depending on the\n//       the procedure that is called trimAndToUpperCase or trimAndTolowerCase\n//       you can also call toLowerCase and toUpperCase if you want just to uppercase or lowercase\n//        the value and ignore the triming.\n\n\ndcl-c EMPTY_ISO_DATE  '0001-01-01';\ndcl-c EMPTY_DATE     d'0001-01-01';\n\ndcl-c CARRIAGE_RETURN           x'0D';\ndcl-c LINE_FEED                 x'25';\ndcl-c CARRIAGE_RETURN_LINE_FEED x'0D25';\ndcl-c LINE_FEED_CARRIAGE_RETURN x'250D';\n\ndcl-c SINGLE_QUOTE              '''';\ndcl-c DOUBLE_QUOTE              '\"'; \n\nDcl-s myvar varchar( 22 ) template; \n\nDcl-ds mods qualified dim( 1 ) template; \n     Myvarchar  varchar( 10 ); \n     Medate     date; \nEnd-ds; \n\n// convert the string time stamp to the string date.\ndcl-pr convertTimeStampToStringDate varchar( 10 );\n    stringTimeStamp varchar( 10 ) value;\nend-pr;\n\n// countOccurrencesOf\n//\n// Return the number of times a source string contains a\n// search string.\n//\n// A specific location in the source string won't match\n// the search string multiple times. For example, if you\n// search for:\n//\n//     ABA\n//\n// in:\n//\n//     ABABABA\n//\n// you will get a result of 2 (matches start at positions 1\n// and 5), not 3 (the match starting at 3 doesn't count).\n//\ndcl-pr countOccurrencesOf int( 10 );\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\n// endsWith\n//\n// Return *ON if the source string ends with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #startsWith\n//\ndcl-pr endsWith ind;\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\ndcl-pr getEnvironmentVariable varchar(150);\n      environmentVariableName char(64) value;\nend-pr;\n\n//******************************************************************************\n// isDigit\n//\n// Return *ON if the character is a numeric digit.\n//\n// @see isLetter\n\ndcl-pr isDigit ind;\n     characterToTest char( 1 ) const;\nend-pr;\n\n//******************************************************************************\n// isLetter\n//\n// Return *ON if the character is an upper-case or lower-case letter.\n//\n// @see isDigit\n\ndcl-pr isLetter ind;\n     characterToTest char( 1 ) const;\nend-pr;\n\ndcl-pr parseDate date;\n     *n varchar(50) value;\nend-pr;\n\n//-------------------------------------------------------------------------------------------------\n//  remove the blanks from the string that has been passed. This can be anywhere in the string.\n//-------------------------------------------------------------------------------------------------\ndcl-pr removeBlanks varchar( 64000 );\n    inputString     varchar( 64000 ) const;\nend-pr;\n\n//******************************************************************************\n// removeUnprintable\n//\n// Remove characters that cannot be printed, specifically control characters\n// and those not normally entered into input fields.\n\ndcl-pr removeUnprintable  varchar( 64000 );\n     *n varchar( 64000 ) const;\nend-pr;\n\n//*******************************************************************************************\n// scanReverse\n// This procedure will take a string and scan the last five characters, looking for the passed in\n// delimiter. If the delimiter is not found then it starts working itself backwards until you are at\n// beginning of the string. This returns the position ( Int value ) of the requested delimiter. or 0\n// the delimiter is not found.\n//*******************************************************************************************\ndcl-pr scanReverse uns( 10 );\n    comment varchar( 3500 ) value;\n    delimiter varchar( 6 ) value;\n    startPoint uns( 10 ) value options(*nopass);\nend-pr;\n\n// splitStringMaxLength\n//\n// Take a long string and break it up into smaller substrings based off of inputted max substring\n// length and optional separators(see below for rules). The subprocedure will try not to split up\n// any words, if the max length does not land on the separator, the process will step back until\n// it can find one. If a separator is not found, it will split the string at the max length mark.\n// When a separator is found, the string will be split at that point and the separator will be\n// deleted.\n//\n// @return\n//   If the split was successfull the indicatior will be *on. Otherwise the indicator is returned\n//   *off, check EVBLOG for more details on the error.\n//\n// @param callback\n//   A subprocedure in the program that is calling this procedure. The callback subprocedure will\n//   be called for each substring it splits off of the source string.\n//   We will send three parameters to your callback procedure:\n//      splitString  - the substring that has been split from the source string\n//      splitIndex   - the sequence number of the splitString.\n//      callbackData - will send what was sent to this subprocedure in the callbackData parameter.\n//                     It is also subject to change in your callback subprocedure.\n//\n// @param source\n//   The full string you wish to be split\n//\n// @param maxResultLength\n//   The maximum substring size you want returned. Must be greater that one.\n//\n// @param separator (optional)\n//   The separator will default to a space when not specified. If, however,\n//   you pass it an empty string ('') the procedure will not use a separator, instead split the\n//   string at the max length regardless of where that lands. It is also possible to pass the\n//   procedure multiple separators. For example if you pass the separator something like this '_- '\n//   the procedure will use underscore, dash, or space as a separator; whichever it finds first.\n//\n// @param callbackData (optional)\n//   This can be any variable type or data structure you like from your calling program. If you\n//   choose to pass something in nthe callbackData, it will be sent to your callback subprocedure.\n//   Example: subprocedure splitStringMaxLengthCallback05 in TEXTUTIL_T used as an int callbackData\n//   to increment each time the subprocedure was called in order to validate the splitIndex.\n//\ndcl-pr splitStringMaxLength ind;\n   callback        pointer( *proc )    const;\n   source          varchar( 3000000 )  const;\n   maxLength       int(          10 )  const;\n   separators      varchar(      20 )  const options( *noPass : *omit );\n   callbackData    pointer             const options( *noPass : *omit );\nend-pr;\n\n// startsWith\n//\n// Return *ON if the source string starts with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #endsWith\n//\ndcl-pr startsWith ind;\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\n// convert the string to lowercase.\ndcl-pr toLowerCase varchar(64000);\n     *n varchar(64000) value;\nend-pr;\n\n//******************************************************************************\n// toQuotedYN\n//\n// Return the value from toYN and put single quotes around it so it can\n// easily be added to an SQL string.\n//\n// see also toYN\n\ndcl-pr toQuotedYN char( 3 );\n     source varchar( 10 ) const;\nend-pr;\n\n//******************************************************************************\n// toStringJsonArray\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation.\n//\n// Examples:\n//\n// Input:\n//     (null)\n// Output:\n//     (empty string)\n//\n// Input:\n//     (array list without any elements)\n// Output:\n//     []\n//\n// Input:\n//     ABC\n// Output:\n//     [\"ABC\"]\n//\n// Input:\n//     ABC, 123\n// Output:\n//     [\"ABC\",\"123\"]\n//\n// Input:\n//     \"Quoted\" Text\n// Output:\n//     [\"\\\"Quoted\\\" Text\"]\n\ndcl-pr toStringJsonArray varchar( 65535 );\n     arrayList pointer const;\nend-pr;\n\n//******************************************************************************\n// toStringJsonArrayLarger\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation. This can handle larger results\n// than toStringJsonArray.\n//\n// Examples:\n//\n// Input:\n//     (null)\n// Output:\n//     (empty string)\n//\n// Input:\n//     (array list without any elements)\n// Output:\n//     []\n//\n// Input:\n//     ABC\n// Output:\n//     [\"ABC\"]\n//\n// Input:\n//     ABC, 123\n// Output:\n//     [\"ABC\",\"123\"]\n//\n// Input:\n//     \"Quoted\" Text\n// Output:\n//     [\"\\\"Quoted\\\" Text\"]\n\ndcl-pr toStringJsonArrayLarger varchar( 2000000 );\n     arrayList pointer const;\nend-pr;\n\n// convert the string to uppercase.\ndcl-pr toUpperCase varchar(64000);\n    *n varchar(64000) value;\nend-pr;\n\n//******************************************************************************\n// toYN\n//\n// Take an input value, probably received from a browser or JSON request,\n// and return a Y or N character value appropriate for storing in 'boolean'\n// database column. Anything like Y, yes, true, 1, ... will result in a\n// Y response while anything else will return an N.\n//\n// see also toQuotedYN\n\ndcl-pr toYN char( 1 );\n     source varchar( 10 ) const;\nend-pr;\n\n// trim and convert the string to lowercase.\ndcl-pr trimAndLowerCase varchar(64000);\n     *n varchar(64000) value;\nend-pr;\n\n// trim and convert the string to uppercase.\ndcl-pr trimAndUpperCase varchar(64000);\n    *n varchar(64000) value;\nend-pr;","output":"**free\n**free\nctl-opt bndDir( 'TEXTUTILS' : 'IBMIUNIT/IBMIUNIT' : 'OSSILE/OSSILE' );\n\n// Test TEXTUTILS\n\n /copy TextUtil_H\n /copy IBMiUnit/QRPGLESRC,IBMiUnit_H\n /copy ArrayLst_H\n\n dcl-s arrayList pointer;\n\n IBMiUnit_setupSuite( 'TextUtil Tests'\n                    : %pAddr( beforeTest ) : %pAddr( afterTest ) );\n\n IBMiUnit_addTestCase( %pAddr( toUpperCase_fromLower          ) : 'toUpperCase_fromLower' );\n IBMiUnit_addTestCase( %pAddr( toUpperCase_fromMixed          ) : 'toUpperCase_fromMixed' );\n IBMiUnit_addTestCase( %pAddr( toUpperCase_withBlanks         ) : 'toUpperCase_withBlanks' );\n IBMiUnit_addTestCase( %pAddr( toLowerCase_fromUpper          ) : 'toLowerCase_fromUpper' );\n IBMiUnit_addTestCase( %pAddr( toLowerCase_fromMixed          ) : 'toLowerCase_fromMixed' );\n IBMiUnit_addTestCase( %pAddr( toLowerCase_withBlanks         ) : 'toLowerCase_withBlanks' );\n\n IBMiUnit_addTestCase( %pAddr( trimAndUpperCase_fromLower     ) : 'trimAndUpperCase_fromLower' );\n IBMiUnit_addTestCase( %pAddr( trimAndUpperCase_leadingSpaces )\n                             : 'trimAndUpperCase_leadingSpaces' );\n IBMiUnit_addTestCase( %pAddr( trimAndUpperCase_bothSpaces    ) : 'trimAndUpperCase_bothSpaces' );\n IBMiUnit_addTestCase( %pAddr( trimAndLowerCase_fromMixed     ) : 'trimAndLowerCase_fromMixed' );\n IBMiUnit_addTestCase( %pAddr( trimAndLowerCase_leadingSpaces )\n                             : 'trimAndLowerCase_leadingSpaces' );\n IBMiUnit_addTestCase( %pAddr( trimAndLowerCase_bothSpaces    ) : 'trimAndLowerCase_bothSpaces' );\n\n IBMiUnit_addTestCase( %pAddr( toStringJsonArray_null         ) : 'toStringJsonArray_null' );\n IBMiUnit_addTestCase( %pAddr( toStringJsonArray_zeroElements )\n                             : 'toStringJsonArray_zeroElements' );\n IBMiUnit_addTestCase( %pAddr( toStringJsonArray_oneElement   ) : 'toStringJsonArray_oneElement' );\n IBMiUnit_addTestCase( %pAddr( toStringJsonArray_twoElements  ) : 'toStringJsonArray_twoElements' );\n IBMiUnit_addTestCase( %pAddr( toStringJsonArray_doubleQuotes )\n                              : 'toStringJsonArray_doubleQuotes' );\n IBMiUnit_addTestCase( %pAddr( toStringJsonArray_singleQuotes )\n                              : 'toStringJsonArray_singleQuotes' );\n IBMiUnit_addTestCase( %pAddr( toStringJsonArray_paddedValues )\n                              : 'toStringJsonArray_paddedValues' );\n\n IBMiUnit_addTestCase( %pAddr( scanReverse_from25             ) : 'scanReverse_from25' );\n IBMiUnit_addTestCase( %pAddr( scanReverse_from30             ) : 'scanReverse_from30' );\n // TODO: Shelly: copy remaining _textutil_ tests from UTILS_TEST\n IBMiUnit_addTestCase( %pAddr( scanReverse_from25to0          ) : 'scanReverse_from25to0' );\n IBMiUnit_addTestCase( %pAddr( scanReverse_fromEndToStart     ) : 'scanReverse_fromEndToStart' );\n IBMiUnit_addTestCase( %pAddr( scanReverse_fromEndTo56        ) : 'scanReverse_fromEndTo56' );\n IBMiUnit_addTestCase( %pAddr( scanReverse_fromEndToComma     ) : 'scanReverse_fromEndToComma' );\n\n// IBMiUnit_addTestCase( %pAddr( toYN_singleCap                 ) : 'toYN_singleCap' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordMixed                 ) : 'toYN_wordMixed' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordLower                 ) : 'toYN_wordLower' );\n// IBMiUnit_addTestCase( %pAddr( toYN_singleSpcCap              ) : 'toYN_singleSpcCap' );\n// IBMiUnit_addTestCase( %pAddr( toYN_numSpaces                 ) : 'toYN_numSpaces' );\n// IBMiUnit_addTestCase( %pAddr( toYN_word2Mixed                ) : 'toYN_word2Mixed' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordSglQte                ) : 'toYN_wordSglQte' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordDblQte                ) : 'toYN_wordDblQte' );\n// IBMiUnit_addTestCase( %pAddr( toYN_singleCap2                ) : 'toYN_singleCap2' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordMixed2                ) : 'toYN_wordMixed2' );\n// IBMiUnit_addTestCase( %pAddr( toYN_singleSpcCap2             ) : 'toYN_singleSpcCap2' );\n// IBMiUnit_addTestCase( %pAddr( toYN_numSpaces2                ) : 'toYN_numSpaces' );\n// IBMiUnit_addTestCase( %pAddr( toYN_numSpaces2                ) : 'toYN_numSpaces' );\n// IBMiUnit_addTestCase( %pAddr( toYN_word3Mixed                ) : 'toYN_word3Mixed' );\n// IBMiUnit_addTestCase( %pAddr( toYN_word3Mixed                ) : 'toYN_word3Mixed' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordSglQte2               ) : 'toYN_wordSglQte2' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordDblQte2               ) : 'toYN_wordDblQte2' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordLower2                ) : 'toYN_wordLower2' );\n// IBMiUnit_addTestCase( %pAddr( toYN_blank                     ) : 'toYN_blank' );\n// IBMiUnit_addTestCase( %pAddr( toYN_blankSpaces               ) : 'toYN_blankSpaces' );\n// IBMiUnit_addTestCase( %pAddr( toYN_wordSglQte3               ) : 'toYN_wordSglQte3' );\n// IBMiUnit_addTestCase( %pAddr( toYN_singleLower               ) : 'toYN_singleLower' );\n// Shelly - end\n\n IBMiUnit_addTestCase( %pAddr( removeBlanks_nothing           ) : 'removeBlanks_nothing' );\n IBMiUnit_addTestCase( %pAddr( removeBlanks_before            ) : 'removeBlanks_before' );\n IBMiUnit_addTestCase( %pAddr( removeBlanks_middle            ) : 'removeBlanks_middle' );\n IBMiUnit_addTestCase( %pAddr( removeBlanks_after             ) : 'removeBlanks_after' );\n IBMiUnit_addTestCase( %pAddr( removeBlanks_multipleSpaces    ) : 'removeBlanks_multipleSpaces' );\n\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_nothing      ) : 'removeUnprintable_nothing' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex0         ) : 'removeUnprintable_hex0' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex1         ) : 'removeUnprintable_hex1' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex2         ) : 'removeUnprintable_hex2' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex3         ) : 'removeUnprintable_hex3' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex4         ) : 'removeUnprintable_hex4' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex5         ) : 'removeUnprintable_hex5' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex6         ) : 'removeUnprintable_hex6' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex7         ) : 'removeUnprintable_hex7' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex8         ) : 'removeUnprintable_hex8' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hex9         ) : 'removeUnprintable_hex9' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hexA         ) : 'removeUnprintable_hexA' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hexB         ) : 'removeUnprintable_hexB' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hexC         ) : 'removeUnprintable_hexC' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hexD         ) : 'removeUnprintable_hexD' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hexE         ) : 'removeUnprintable_hexE' );\n IBMiUnit_addTestCase( %pAddr( removeUnprintable_hexF         ) : 'removeUnprintable_hexF' );\n\n IBMiUnit_addTestCase( %pAddr( parseDate_slashMdcy            ) : 'parseDate_slashMdcy' );\n IBMiUnit_addTestCase( %pAddr( parseDate_slashMdy             ) : 'parseDate_slashMdy' );\n IBMiUnit_addTestCase( %pAddr( parseDate_slashMd99            ) : 'parseDate_slashMd99' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dashMdcy             ) : 'parseDate_dashMdcy' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dashMdy              ) : 'parseDate_dashMdy' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dashMd99             ) : 'parseDate_dashMd99' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dotDmcy              ) : 'parseDate_dotDmcy' );\n\n IBMiUnit_addTestCase( %pAddr( parseDate_slashMdcyTime        ) : 'parseDate_slashMdcyTime' );\n IBMiUnit_addTestCase( %pAddr( parseDate_slashMdyTime         ) : 'parseDate_slashMdyTime' );\n IBMiUnit_addTestCase( %pAddr( parseDate_slashMd99Time        ) : 'parseDate_slashMd99Time' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dashMdcyTime         ) : 'parseDate_dashMdcyTime' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dashMdyTime          ) : 'parseDate_dashMdyTime' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dashMd99Time         ) : 'parseDate_dashMd99Time' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dotDmcyTime          ) : 'parseDate_dotDmcyTime' );\n\n IBMiUnit_addTestCase( %pAddr( parseDate_slash0Mdcy           ) : 'parseDate_slash0Mdcy' );\n IBMiUnit_addTestCase( %pAddr( parseDate_slash0Mdy            ) : 'parseDate_slash0Mdy' );\n IBMiUnit_addTestCase( %pAddr( parseDate_slash0Md99           ) : 'parseDate_slash0Md99' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dash0Mdcy            ) : 'parseDate_dash0Mdcy' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dash0Mdy             ) : 'parseDate_dash0Mdy' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dash0Md99            ) : 'parseDate_dash0Md99' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dot0Dmcy             ) : 'parseDate_dot0Dmcy' );\n\n IBMiUnit_addTestCase( %pAddr( parseDate_slash0MdcyTime       ) : 'parseDate_slash0MdcyTime' );\n IBMiUnit_addTestCase( %pAddr( parseDate_slash0MdyTime        ) : 'parseDate_slash0MdyTime' );\n IBMiUnit_addTestCase( %pAddr( parseDate_slash0Md99Time       ) : 'parseDate_slash0Md99Time' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dash0MdcyTime        ) : 'parseDate_dash0MdcyTime' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dash0MdyTime         ) : 'parseDate_dash0MdyTime' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dash0Md99Time        ) : 'parseDate_dash0Md99Time' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dot0DmcyTime         ) : 'parseDate_dot0DmcyTime' );\n\n IBMiUnit_addTestCase( %pAddr( parseDate_dashIso              ) : 'parseDate_dashIso' );\n IBMiUnit_addTestCase( %pAddr( parseDate_dashIsoTime          ) : 'parseDate_dashIsoTime' );\n\nIBMiUnit_addTestCase( %pAddr( isDigit_0 )       : 'isDigit_0' );\nIBMiUnit_addTestCase( %pAddr( isDigit_1 )       : 'isDigit_1' );\nIBMiUnit_addTestCase( %pAddr( isDigit_2 )       : 'isDigit_2' );\nIBMiUnit_addTestCase( %pAddr( isDigit_3 )       : 'isDigit_3' );\nIBMiUnit_addTestCase( %pAddr( isDigit_4 )       : 'isDigit_4' );\nIBMiUnit_addTestCase( %pAddr( isDigit_5 )       : 'isDigit_5' );\nIBMiUnit_addTestCase( %pAddr( isDigit_6 )       : 'isDigit_6' );\nIBMiUnit_addTestCase( %pAddr( isDigit_7 )       : 'isDigit_7' );\nIBMiUnit_addTestCase( %pAddr( isDigit_8 )       : 'isDigit_8' );\nIBMiUnit_addTestCase( %pAddr( isDigit_9 )       : 'isDigit_9' );\nIBMiUnit_addTestCase( %pAddr( isDigit_lowerA )  : 'isDigit_lowerA' );\nIBMiUnit_addTestCase( %pAddr( isDigit_upperA )  : 'isDigit_upperA' );\nIBMiUnit_addTestCase( %pAddr( isDigit_lowerE )  : 'isDigit_lowerE' );\nIBMiUnit_addTestCase( %pAddr( isDigit_upperE )  : 'isDigit_upperE' );\nIBMiUnit_addTestCase( %pAddr( isDigit_lowerZ )  : 'isDigit_lowerZ' );\nIBMiUnit_addTestCase( %pAddr( isDigit_upperZ )  : 'isDigit_upperZ' );\nIBMiUnit_addTestCase( %pAddr( isDigit_space )   : 'isDigit_space' );\nIBMiUnit_addTestCase( %pAddr( isDigit_plus )    : 'isDigit_plus' );\nIBMiUnit_addTestCase( %pAddr( isDigit_minus )   : 'isDigit_minus' );\nIBMiUnit_addTestCase( %pAddr( isDigit_decimal ) : 'isDigit_decimal' );\nIBMiUnit_addTestCase( %pAddr( isDigit_comma )   : 'isDigit_comma' );\n\nIBMiUnit_addTestCase( %pAddr( isLetter_0 )       : 'isLetter_0' );\nIBMiUnit_addTestCase( %pAddr( isLetter_1 )       : 'isLetter_1' );\nIBMiUnit_addTestCase( %pAddr( isLetter_2 )       : 'isLetter_2' );\nIBMiUnit_addTestCase( %pAddr( isLetter_3 )       : 'isLetter_3' );\nIBMiUnit_addTestCase( %pAddr( isLetter_4 )       : 'isLetter_4' );\nIBMiUnit_addTestCase( %pAddr( isLetter_5 )       : 'isLetter_5' );\nIBMiUnit_addTestCase( %pAddr( isLetter_6 )       : 'isLetter_6' );\nIBMiUnit_addTestCase( %pAddr( isLetter_7 )       : 'isLetter_7' );\nIBMiUnit_addTestCase( %pAddr( isLetter_8 )       : 'isLetter_8' );\nIBMiUnit_addTestCase( %pAddr( isLetter_9 )       : 'isLetter_9' );\nIBMiUnit_addTestCase( %pAddr( isLetter_lowerA )  : 'isLetter_lowerA' );\nIBMiUnit_addTestCase( %pAddr( isLetter_upperA )  : 'isLetter_upperA' );\nIBMiUnit_addTestCase( %pAddr( isLetter_lowerE )  : 'isLetter_lowerE' );\nIBMiUnit_addTestCase( %pAddr( isLetter_upperE )  : 'isLetter_upperE' );\nIBMiUnit_addTestCase( %pAddr( isLetter_lowerZ )  : 'isLetter_lowerZ' );\nIBMiUnit_addTestCase( %pAddr( isLetter_upperZ )  : 'isLetter_upperZ' );\nIBMiUnit_addTestCase( %pAddr( isLetter_lowerTildeA ) : 'isLetter_lowerTildeA' );\nIBMiUnit_addTestCase( %pAddr( isLetter_upperCaretA ) : 'isLetter_upperCaretA' );\nIBMiUnit_addTestCase( %pAddr( isLetter_space )   : 'isLetter_space' );\nIBMiUnit_addTestCase( %pAddr( isLetter_plus )    : 'isLetter_plus' );\nIBMiUnit_addTestCase( %pAddr( isLetter_minus )   : 'isLetter_minus' );\nIBMiUnit_addTestCase( %pAddr( isLetter_decimal ) : 'isLetter_decimal' );\nIBMiUnit_addTestCase( %pAddr( isLetter_comma )   : 'isLetter_comma' );\n\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_zeroLength )\n                    :        'splitStringMaxLength_zeroLength' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_negativeLength )\n                    :        'splitStringMaxLength_negativeLength' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_noCallback )\n                    :        'splitStringMaxLength_noCallback' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_emptyString )\n                    :        'splitStringMaxLength_emptyString' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_callbackStringParameter )\n                    :        'splitStringMaxLength_callbackStringParameter' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_callbackStringAndIndexParameters )\n                    :        'splitStringMaxLength_callbackStringAndIndexParameters' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_twoSplits )\n                    :        'splitStringMaxLength_twoSplits' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_onlyTwoSplits )\n                    :        'splitStringMaxLength_onlyTwoSplits' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_multipleSplits )\n                    :        'splitStringMaxLength_multipleSplits' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_noSeparatorFound )\n                    :        'splitStringMaxLength_noSeparatorFound' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_emptySeparator )\n                    :        'splitStringMaxLength_emptySeparator' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_multipleSeparators )\n                    :        'splitStringMaxLength_multipleSeparators' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_longString )\n                    :        'splitStringMaxLength_longString' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_callbackFailure )\n                    :        'splitStringMaxLength_callbackFailure' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_callbackFailureSeparator )\n                    :        'splitStringMaxLength_callbackFailureSeparator' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_callbackFailureLength )\n                    :        'splitStringMaxLength_callbackFailureLength' );\nIBMiUnit_addTestCase( %pAddr( splitStringMaxLength_noSpaceSeparator )\n                    :        'splitStringMaxLength_noSpaceSeparator' );\n\nIBMiUnit_addTestCase( %pAddr( startsWith_emptySearchAndSource )\n                    :        'startsWith_emptySearchAndSource' );\nIBMiUnit_addTestCase( %pAddr( startsWith_emptySearch )\n                    :        'startsWith_emptySearch' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchBlank )\n                    :        'startsWith_searchBlank' );\nIBMiUnit_addTestCase( %pAddr( startsWith_longerSearch )\n                    :        'startsWith_longerSearch' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchA )\n                    :        'startsWith_searchA' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchAb )\n                    :        'startsWith_searchAb' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchAbc )\n                    :        'startsWith_searchAbc' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchX )\n                    :        'startsWith_searchX' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchXy )\n                    :        'startsWith_searchXy' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchXyz )\n                    :        'startsWith_searchXyz' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchLowerA )\n                    :        'startsWith_searchLowerA' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchLowerAb )\n                    :        'startsWith_searchLowerAb' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchLowerAbc )\n                    :        'startsWith_searchLowerAbc' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchLowerX )\n                    :        'startsWith_searchLowerX' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchLowerXy )\n                    :        'startsWith_searchLowerXy' );\nIBMiUnit_addTestCase( %pAddr( startsWith_searchLowerXyz )\n                    :        'startsWith_searchLowerXyz' );\n\nIBMiUnit_addTestCase( %pAddr( endsWith_emptySearchAndSource )\n                    :        'endsWith_emptySearchAndSource' );\nIBMiUnit_addTestCase( %pAddr( endsWith_emptySearch )\n                    :        'endsWith_emptySearch' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchBlank )\n                    :        'endsWith_searchBlank' );\nIBMiUnit_addTestCase( %pAddr( endsWith_longerSearch )\n                    :        'endsWith_longerSearch' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchA )\n                    :        'endsWith_searchA' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchAb )\n                    :        'endsWith_searchAb' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchAbc )\n                    :        'endsWith_searchAbc' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchX )\n                    :        'endsWith_searchX' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchXy )\n                    :        'endsWith_searchXy' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchXyz )\n                    :        'endsWith_searchXyz' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchYz )\n                    :        'endsWith_searchYz' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchZ )\n                    :        'endsWith_searchZ' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchLowerA )\n                    :        'endsWith_searchLowerA' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchLowerAb )\n                    :        'endsWith_searchLowerAb' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchLowerAbc )\n                    :        'endsWith_searchLowerAbc' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchLowerX )\n                    :        'endsWith_searchLowerX' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchLowerXy )\n                    :        'endsWith_searchLowerXy' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchLowerXyz )\n                    :        'endsWith_searchLowerXyz' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchLowerYz )\n                    :        'endsWith_searchLowerYz' );\nIBMiUnit_addTestCase( %pAddr( endsWith_searchLowerZ )\n                    :        'endsWith_searchLowerZ' );\n\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_emptySearchEmptySource )\n                    :        'countOccurrencesOf_emptySearchEmptySource' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_blankSearchEmptySource )\n                    :        'countOccurrencesOf_blankSearchEmptySource' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_emptySearchBlankSource )\n                    :        'countOccurrencesOf_emptySearchBlankSource' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_blankSearchBlankSource )\n                    :        'countOccurrencesOf_blankSearchBlankSource' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_characterMatchAtBeginning )\n                    :        'countOccurrencesOf_characterMatchAtBeginning' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_characterMatchAtEnd )\n                    :        'countOccurrencesOf_characterMatchAtEnd' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_characterMatchInMiddle )\n                    :        'countOccurrencesOf_characterMatchInMiddle' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_stringMatchAtBeginning )\n                    :        'countOccurrencesOf_stringMatchAtBeginning' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_stringMatchAtEnd )\n                    :        'countOccurrencesOf_stringMatchAtEnd' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_stringMatchInMiddle )\n                    :        'countOccurrencesOf_stringMatchInMiddle' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_caseDifference )\n                    :        'countOccurrencesOf_caseDifference' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_longerSearch )\n                    :        'countOccurrencesOf_longerSearch' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_allCharacterMatches )\n                    :        'countOccurrencesOf_allCharacterMatches' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_allStringMatches )\n                    :        'countOccurrencesOf_allStringMatches' );\nIBMiUnit_addTestCase( %pAddr( countOccurrencesOf_nonRepeatingMatch )\n                    :        'countOccurrencesOf_nonRepeatingMatch' );\n\nIBMiUnit_teardownSuite();\nreturn;\n\n\n // support methods\n\n dcl-proc beforeTest;\n\n    arrayList = *null;\n\n end-proc;\n\n dcl-proc afterTest;\n\n    if ( arrayList <> *null );\n       arraylist_dispose( arrayList );\n    endIf;\n\n end-proc;\n\n\n // test cases\n\n dcl-proc toUpperCase_fromLower;\n\n    assertCharEquals( 'GAME OF THRONES'\n                    : toUpperCase( 'game of thrones' )\n                    );\n\n end-proc;\n\n dcl-proc toUpperCase_fromMixed;\n\n    assertCharEquals( 'WINTERS COMING'\n                    : toUpperCase( 'Winters coming' )\n                    );\n\n end-proc;\n\n dcl-proc toUpperCase_withBlanks;\n\n    assertCharEquals( ' HA! '\n                    : toUpperCase( ' Ha! ' )\n                    );\n\n end-proc;\n\n dcl-proc toLowerCase_fromUpper;\n\n    assertCharEquals( 'its dark outside'\n                    : toLowerCase( 'ITS DARK OUTSIDE' )\n                    );\n\n end-proc;\n\n dcl-proc toLowerCase_fromMixed;\n\n    assertCharEquals( 'its warm outside'\n                    : toLowerCase( 'ITS warm OUTSIDE' )\n                    );\n\n end-proc;\n\n dcl-proc toLowerCase_withBlanks;\n\n    assertCharEquals( '  (hello?)  '\n                    : toLowerCase( '  (Hello?)  ' )\n                    );\n\n end-proc;\n\n dcl-proc trimAndUpperCase_fromLower;\n\n    assertCharEquals( 'WE HAVE ALOT TO DO'\n                    : trimAndUpperCase( 'we have alot to do     ' )\n                    );\n\n end-proc;\n\n dcl-proc trimAndUpperCase_leadingSpaces;\n\n    assertCharEquals( 'SPACES AT THE BEGINNING'\n                    : trimAndUpperCase( '   spaces at the beginning' )\n                    );\n\n end-proc;\n\n dcl-proc trimAndUpperCase_bothSpaces;\n\n    assertCharEquals( 'BOTH'\n                    : trimAndUpperCase( '   both  ' )\n                    );\n\n end-proc;\n\n dcl-proc trimAndLowerCase_fromMixed;\n\n    assertCharEquals( 'its storming outside'\n                    : trimAndLowerCase( 'ITs Storming Outside   ' )\n                    );\n\n end-proc;\n\n dcl-proc trimAndLowerCase_leadingSpaces;\n\n    assertCharEquals( 'more starting spaces'\n                    : trimAndLowerCase( '   MoRe Starting sPaCeS' )\n                    );\n\n end-proc;\n\n dcl-proc trimAndLowerCase_bothSpaces;\n\n    assertCharEquals( 'spaces everywhere!'\n                    : trimAndLowerCase( '       SPACES EVERYWHERE!   ' )\n                    );\n\n end-proc;\n\n dcl-proc toStringJsonArray_null;\n\n    assertCharEquals( ''\n                    : toStringJsonArray( *null )\n                    );\n\n end-proc;\n\n dcl-proc toStringJsonArray_zeroElements;\n\n    arrayList = arraylist_create();\n\n    assertCharEquals( '[]'\n                    : toStringJsonArray( arrayList )\n                    );\n\n end-proc;\n\n dcl-proc toStringJsonArray_oneElement;\n\n    arrayList = arraylist_create();\n    arraylist_addString( arrayList : 'ABC' );\n\n    assertCharEquals( '[\"ABC\"]'\n                    : toStringJsonArray( arrayList )\n                    );\n\n end-proc;\n\n dcl-proc toStringJsonArray_twoElements;\n\n    arrayList = arraylist_create();\n    arraylist_addString( arrayList : 'ABC' );\n    arraylist_addString( arrayList : '123' );\n\n    assertCharEquals( '[\"ABC\",\"123\"]'\n                    : toStringJsonArray( arrayList )\n                    );\n\n end-proc;\n\n dcl-proc toStringJsonArray_doubleQuotes;\n\n    arrayList = arraylist_create();\n    arraylist_addString( arrayList : '\"Quoted\" Text' );\n\n    assertCharEquals( '[\"\\\"Quoted\\\" Text\"]'\n                    : toStringJsonArray( arrayList )\n                    );\n\n end-proc;\n\n dcl-proc toStringJsonArray_singleQuotes;\n\n    arrayList = arraylist_create();\n    arraylist_addString( arrayList : 'Everbrite''s' );\n\n    assertCharEquals( '[\"Everbrite\\''s\"]'\n                    : toStringJsonArray( arrayList )\n                    );\n\n end-proc;\n\n dcl-proc toStringJsonArray_paddedValues;\n\n    arrayList = arraylist_create();\n    arraylist_addString( arrayList : '0' );\n    arraylist_addString( arrayList : ' 1 ' );\n    arraylist_addString( arrayList : '  2  ' );\n\n    assertCharEquals( '[\"0\",\" 1 \",\"  2  \"]'\n                    : toStringJsonArray( arrayList )\n                    );\n\n end-proc;\n\n dcl-proc scanReverse_from25;\n\n    assertNumericEquals( 22\n                       : scanReverse( 'Gollumn does not like nasty hobbit bread, ' +\n                                      'he wants fish and only fish'\n                                    : ' ' : 25 )\n                       );\n\n end-proc;\n\n dcl-proc scanReverse_from30;\n\n    assertNumericEquals( 28\n                       : scanReverse( 'Gollumn does not like nasty hobbit bread, ' +\n                                      'he wants fishbecausefishisreallygood'\n                                    : ' ' : 30 )\n                       );\n\n end-proc;\n\n dcl-proc scanReverse_from25to0;\n\n    assertNumericEquals( 0\n                       : scanReverse( 'Gollumndoesnotlikebreadhewantsfishandonlyfish'\n                                    : ' ' : 25 )\n                       );\n\n end-proc;\n\n dcl-proc scanReverse_fromEndToStart;\n\n    assertNumericEquals( 0\n                       : scanReverse( 'Gollumndoesnotlikebreadhewantsfishandonlyfish'\n                                    : ' ' )\n                       );\n\n end-proc;\n\n dcl-proc scanReverse_fromEndTo56;\n\n    assertNumericEquals( 56\n                       : scanReverse( 'Why do Java programmers wear glasses, because they cant C#'\n                                    : ' ' )\n                       );\n\n end-proc;\n\n dcl-proc scanReverse_fromEndToComma;\n\n    assertNumericEquals( 13\n                       : scanReverse( 'Programming , is fun!'\n                                    : ',' )\n                       );\n\n end-proc;\n\n // TODO: Shelly: copy remaining _textutil_ tests from UTILS_TEST\n\n dcl-proc toYN_singleCap;\n\n    assertCharEquals( 'Y'\n                    : toYN( 'Y' )  );\n\n end-proc;\n\n dcl-proc removeBlanks_nothing;\n\n    assertCharEquals( 'noBlanks!'\n                    : removeBlanks( 'noBlanks!' )\n                    );\n\n end-proc;\n\n dcl-proc removeBlanks_before;\n\n    assertCharEquals( 'ahhhBlanksBefore!'\n                    : removeBlanks( ' ahhhBlanksBefore!' )\n                    );\n\n end-proc;\n\n dcl-proc removeBlanks_middle;\n\n    assertCharEquals( 'ahhhBlanksMiddle!'\n                    : removeBlanks( 'ahhhBla nksMiddle!' )\n                    );\n\n end-proc;\n\n dcl-proc removeBlanks_after;\n\n    assertCharEquals( 'ahhhBlanksAfter!'\n                    : removeBlanks( 'ahhhBlanksAfter! ' )\n                    );\n\n end-proc;\n\n dcl-proc removeBlanks_multipleSpaces;\n\n    assertCharEquals( 'gollum'\n                    : removeBlanks( 'g o l l u m' )\n                    );\n\n end-proc;\n\n dcl-proc removeUnprintable_nothing;\n\n    assertCharEquals( ' this String is_FINE! '\n                    : removeUnprintable( ' this String is_FINE! ' )\n                    );\n\n end-proc;\n\n dcl-proc removeUnprintable_hex0;\n\n    assertCharEquals( ''\n                    : removeUnprintable( x'000102030405060708090A0B0C0D0E0F' )\n                    );\n\n end-proc;\n\n dcl-proc removeUnprintable_hex1;\n\n    assertCharEquals( ''\n                    : removeUnprintable( x'101112131415161718191A1B1C1D1E1F' )\n                    );\n\n end-proc;\n\n dcl-proc removeUnprintable_hex2;\n\n    assertCharEquals( x'20'\n                    : removeUnprintable( x'202122232425262728292A2B2C2D2E2F' )\n                    );\n\n end-proc;\n\n dcl-proc removeUnprintable_hex3;\n\n    assertCharEquals( ''\n                    : removeUnprintable( x'303132333435363738393A3B3C3D3E3F' )\n                    );\n\n end-proc;\n\n dcl-proc parseDate_slashMdcy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '1/2/2003' ) );\n\n end-proc;\n\n dcl-proc parseDate_slashMdy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '1/2/03' ) );\n\n end-proc;\n\n dcl-proc parseDate_slashMd99;\n\n    assertDateEquals( d'1999-01-02' : parseDate( '1/2/99' ) );\n\n end-proc;\n\n dcl-proc parseDate_dashMdcy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '1-2-2003' ) );\n\n end-proc;\n\n dcl-proc parseDate_dashMdy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '1-2-03' ) );\n\n end-proc;\n\n dcl-proc parseDate_dashMd99;\n\n    assertDateEquals( d'1999-01-02' : parseDate( '1-2-99' ) );\n\n end-proc;\n\n dcl-proc parseDate_dotDmcy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '2.1.2003' ) );\n\n end-proc;\n\n dcl-proc parseDate_slashMdcyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '1/2/2003T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_slashMdyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '1/2/3T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_slashMd99Time;\n\n    assertDateEquals( d'1999-01-02' : parseDate( '1/2/99T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dashMdcyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '1-2-2003T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dashMdyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '1-2-3T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dashMd99Time;\n\n    assertDateEquals( d'1999-01-02' : parseDate( '1-2-99T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dotDmcyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '2.1.2003T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_slash0Mdcy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '01/02/2003' ) );\n\n end-proc;\n\n dcl-proc parseDate_slash0Mdy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '01/02/03' ) );\n\n end-proc;\n\n dcl-proc parseDate_slash0Md99;\n\n    assertDateEquals( d'1999-01-02' : parseDate( '01/02/99' ) );\n\n end-proc;\n\n dcl-proc parseDate_dash0Mdcy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '01-02-2003' ) );\n\n end-proc;\n\n dcl-proc parseDate_dash0Mdy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '01-02-03' ) );\n\n end-proc;\n\n dcl-proc parseDate_dash0Md99;\n\n    assertDateEquals( d'1999-01-02' : parseDate( '01-02-99' ) );\n\n end-proc;\n\n dcl-proc parseDate_dot0Dmcy;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '02.01.2003' ) );\n\n end-proc;\n\n dcl-proc parseDate_slash0MdcyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '01/02/2003T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_slash0MdyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '01/02/03T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_slash0Md99Time;\n\n    assertDateEquals( d'1999-01-02' : parseDate( '01/02/99T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dash0MdcyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '01-02-2003T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dash0MdyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '01-02-03T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dash0Md99Time;\n\n    assertDateEquals( d'1999-01-02' : parseDate( '01-02-99T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dot0DmcyTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '02.01.2003T04:05:06' ) );\n\n end-proc;\n\n dcl-proc parseDate_dashIso;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '2003-01-02' ) );\n\n end-proc;\n\n dcl-proc parseDate_dashIsoTime;\n\n    assertDateEquals( d'2003-01-02' : parseDate( '2003-01-02T04:05:06' ) );\n\n end-proc;\n\ndcl-proc isDigit_0;\n\n   assertOn( isDigit( '0' ) );\n\nend-proc;\n\ndcl-proc isDigit_1;\n\n   assertOn( isDigit( '1' ) );\n\nend-proc;\n\ndcl-proc isDigit_2;\n\n   assertOn( isDigit( '2' ) );\n\nend-proc;\n\ndcl-proc isDigit_3;\n\n   assertOn( isDigit( '3' ) );\n\nend-proc;\n\ndcl-proc isDigit_4;\n\n   assertOn( isDigit( '4' ) );\n\nend-proc;\n\ndcl-proc isDigit_5;\n\n   assertOn( isDigit( '5' ) );\n\nend-proc;\n\ndcl-proc isDigit_6;\n\n   assertOn( isDigit( '6' ) );\n\nend-proc;\n\ndcl-proc isDigit_7;\n\n   assertOn( isDigit( '7' ) );\n\nend-proc;\n\ndcl-proc isDigit_8;\n\n   assertOn( isDigit( '8' ) );\n\nend-proc;\n\ndcl-proc isDigit_9;\n\n   assertOn( isDigit( '9' ) );\n\nend-proc;\n\ndcl-proc isDigit_lowerA;\n\n   assertOff( isDigit( 'a' ) );\n\nend-proc;\n\ndcl-proc isDigit_upperA;\n\n   assertOff( isDigit( 'A' ) );\n\nend-proc;\n\ndcl-proc isDigit_lowerE;\n\n   assertOff( isDigit( 'e' ) );\n\nend-proc;\n\ndcl-proc isDigit_upperE;\n\n   assertOff( isDigit( 'E' ) );\n\nend-proc;\n\ndcl-proc isDigit_lowerZ;\n\n   assertOff( isDigit( 'z' ) );\n\nend-proc;\n\ndcl-proc isDigit_upperZ;\n\n   assertOff( isDigit( 'Z' ) );\n\nend-proc;\n\ndcl-proc isDigit_space;\n\n   assertOff( isDigit( ' ' ) );\n\nend-proc;\n\ndcl-proc isDigit_comma;\n\n   assertOff( isDigit( ',' ) );\n\nend-proc;\n\ndcl-proc isDigit_decimal;\n\n   assertOff( isDigit( '.' ) );\n\nend-proc;\n\ndcl-proc isDigit_plus;\n\n   assertOff( isDigit( '+' ) );\n\nend-proc;\n\ndcl-proc isDigit_minus;\n\n   assertOff( isDigit( '-' ) );\n\nend-proc;\n\ndcl-proc isLetter_0;\n\n   assertOff( isLetter( '0' ) );\n\nend-proc;\n\ndcl-proc isLetter_1;\n\n   assertOff( isLetter( '1' ) );\n\nend-proc;\n\ndcl-proc isLetter_2;\n\n   assertOff( isLetter( '2' ) );\n\nend-proc;\n\ndcl-proc isLetter_3;\n\n   assertOff( isLetter( '3' ) );\n\nend-proc;\n\ndcl-proc isLetter_4;\n\n   assertOff( isLetter( '4' ) );\n\nend-proc;\n\ndcl-proc isLetter_5;\n\n   assertOff( isLetter( '5' ) );\n\nend-proc;\n\ndcl-proc isLetter_6;\n\n   assertOff( isLetter( '6' ) );\n\nend-proc;\n\ndcl-proc isLetter_7;\n\n   assertOff( isLetter( '7' ) );\n\nend-proc;\n\ndcl-proc isLetter_8;\n\n   assertOff( isLetter( '8' ) );\n\nend-proc;\n\ndcl-proc isLetter_9;\n\n   assertOff( isLetter( '9' ) );\n\nend-proc;\n\ndcl-proc isLetter_lowerA;\n\n   assertOn( isLetter( 'a' ) );\n\nend-proc;\n\ndcl-proc isLetter_upperA;\n\n   assertOn( isLetter( 'A' ) );\n\nend-proc;\n\ndcl-proc isLetter_lowerE;\n\n   assertOn( isLetter( 'e' ) );\n\nend-proc;\n\ndcl-proc isLetter_upperE;\n\n   assertOn( isLetter( 'E' ) );\n\nend-proc;\n\ndcl-proc isLetter_lowerZ;\n\n   assertOn( isLetter( 'z' ) );\n\nend-proc;\n\ndcl-proc isLetter_upperZ;\n\n   assertOn( isLetter( 'Z' ) );\n\nend-proc;\n\ndcl-proc isLetter_space;\n\n   assertOff( isLetter( ' ' ) );\n\nend-proc;\n\ndcl-proc isLetter_comma;\n\n   assertOff( isLetter( ',' ) );\n\nend-proc;\n\ndcl-proc isLetter_decimal;\n\n   assertOff( isLetter( '.' ) );\n\nend-proc;\n\ndcl-proc isLetter_plus;\n\n   assertOff( isLetter( '+' ) );\n\nend-proc;\n\ndcl-proc isLetter_minus;\n\n   assertOff( isLetter( '-' ) );\n\nend-proc;\n\n// Split string tests\n\ndcl-proc splitStringMaxLength_noCallback;\n\n   assertOff( splitStringMaxLength( *null\n                                 : 'Short String.'\n                                 : 25 )\n                                 : 'call to splitStringMaxLength failed' );\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback01;\n\n   fail( 'the callback failed' );\n\nend-proc;\n\ndcl-proc splitStringMaxLength_zeroLength;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback01 )\n                                  : 'Short String.'\n                                  : 0 )\n                                  : 'call to splitStringMaxLength worked' );\n\nend-proc;\n\ndcl-proc splitStringMaxLength_negativeLength;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback01 )\n                                  : 'Short String.'\n                                  : -1  )\n                                  : 'call to splitStringMaxLength worked' );\n\nend-proc;\n\ndcl-proc splitStringMaxLength_emptyString;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback01 )\n                                  : ''\n                                  : 10 )\n            : 'call to splitStringMaxLength worked' );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback02;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n   end-pi;\n\n   assertCharEquals( 'Short String.'\n                   : splitSource\n                   : 'splitSource parameter' );\n\nend-proc;\n\ndcl-proc splitStringMaxLength_callbackStringParameter;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback02 )\n                       : 'Short String.'\n                       : 25 );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback03;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   assertCharEquals( 'Longer String.'\n                   : splitSource\n                   : 'splitSource parameter' );\n\n   assertNumericEquals( 1\n                      : splitIndex\n                      : 'splitIndex parameter' );\n\nend-proc;\n\ndcl-proc splitStringMaxLength_callbackStringAndIndexParameters;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback03 )\n                       : 'Longer String.'\n                       : 25 );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback04;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         assertCharEquals( 'string with'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         assertCharEquals( 'multiple words'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_twoSplits;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback04 )\n                       : 'string with multiple words'\n                       : 15 );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback05;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n      callbackData    pointer             const;\n   end-pi;\n\n   dcl-s callbacks          int(          10 )  based( callbackData );\n   dcl-s trimmedSplitSource varchar( 3000000 );\n\n   callbacks += 1;\n   trimmedSplitSource = %trim( splitSource );\n\n   assertNumericEquals( callbacks\n                      : splitIndex\n                      : 'splitIndex' );\n\n   select;\n      when ( splitIndex = 1 );\n         assertCharEquals( 'string with'\n                         : trimmedSplitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         assertCharEquals( 'multiple words'\n                         : trimmedSplitSource\n                         : 'second splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_onlyTwoSplits;\n\n   dcl-s callbacks   int( 10 );\n\n   callbacks = 0;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback05 )\n                       : 'string with multiple words'\n                       : 15\n                       : *omit\n                       : %addr( callbacks ) );\n\n   assertNumericEquals( 2 : callbacks : 'callbacks' );\n\nend-proc;\n\ndcl-proc splitStringMaxLength_noSpaceSeparator;\n\n   dcl-s callbacks   int( 10 );\n\n   callbacks = 0;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback05 )\n                       : 'string with/ multiple words'\n                       : 15\n                       : '/'\n                       : %addr( callbacks ) );\n\n   assertNumericEquals( 2 : callbacks : 'callbacks' );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback06;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n      callbackData    pointer             const;\n   end-pi;\n\n   dcl-s callbacks  int( 10 )  based( callbackData );\n\n   callbacks += 1;\n\n   assertNumericEquals( callbacks\n                      : splitIndex\n                      : 'splitIndex' );\n\n   select;\n      when ( splitIndex = 1 );\n         assertCharEquals( 'Long string that'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         assertCharEquals( 'needs to be split'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      when ( splitIndex = 3 );\n         assertCharEquals( 'multiple times,'\n                         : splitSource\n                         : 'third splitSource parameter' );\n\n      when ( splitIndex = 4 );\n         assertCharEquals( 'lets say four.'\n                         : splitSource\n                         : 'third splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_multipleSplits;\n\n   dcl-s callbacks   int( 10 );\n\n   callbacks = 0;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback06 )\n                       : 'Long string that needs to be split multiple times, lets say four.'\n                       : 20\n                       : *omit\n                       : %addr( callbacks ) );\n\n   assertNumericEquals( 4 : callbacks : 'callbacks' );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback07;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         assertCharEquals( 'supercalifragilistic'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         assertCharEquals( 'expialidocious'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_noSeparatorFound;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback07 )\n                       : 'supercalifragilisticexpialidocious'\n                       : 20\n                       : *omit\n                       : *omit  );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback08;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         assertCharEquals( 'Separator? I dont ne'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         assertCharEquals( 'ed no stinkin separa'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      when ( splitIndex = 3 );\n         assertCharEquals( 'tor!'\n                         : splitSource\n                         : 'third splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_emptySeparator;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback08 )\n                       : 'Separator? I dont need no stinkin separator!'\n                       : 20\n                       : ''\n                       : *omit );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback09;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         assertCharEquals( 'Separating in'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         assertCharEquals( 'many locations'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      when ( splitIndex = 3 );\n         assertCharEquals( 'with different'\n                         : splitSource\n                         : 'third splitSource parameter' );\n\n      when ( splitIndex = 4 );\n         assertCharEquals( 'separators.'\n                         : splitSource\n                         : 'fourth splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_multipleSeparators;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback09 )\n                       : 'Separating in-many locations with different_separators.'\n                       : 15\n                       : '_- '\n                       : *omit );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback10;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         assertCharEquals( 'Before you criticize someone, you should walk a mile in their shoes.' +\n                           ' That way'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         assertCharEquals( 'when you criticize them, you are a mile away from them and you have ' +\n                           'their shoes.'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_longString;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback10 )\n                       :'Before you criticize someone, you should walk a mile in their shoes. ' +\n                       'That way when you criticize them, you are a mile away from them and you '+\n                       'have their shoes.'\n                       : 80\n                       : *omit\n                       );\n\nend-proc;\n\ndcl-proc splitStringMaxLengthCallback11 export ;\n\n   dcl-pi *n ind;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   dcl-s result ind;\n\n   assertCharEquals( 'Short String.'\n                   : splitSource\n                   : 'splitSource parameter' );\n\n   result = *off;\n\n   return result;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_callbackFailure;\n\n   assertOff(splitStringMaxLength( %paddr( splitStringMaxLengthCallback11 )\n                       : 'Short String.'\n                       : 25 )\n             );\nend-proc;\n\n\ndcl-proc splitStringMaxLengthCallback12;\n\n   dcl-pi *n ind;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   if ( splitIndex = 1 );\n      return *off;\n   else;\n      return *on;\n   endIf;\n\nend-proc;\n\ndcl-proc splitStringMaxLength_callbackFailureSeparator;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback12 )\n                                  : 'Short String.'\n                                  : 10 )\n            );\n\nend-proc;\n\ndcl-proc splitStringMaxLength_callbackFailureLength;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback12 )\n                                  : 'Short String.'\n                                  : 10\n                                  : '' )\n            );\n\nend-proc;\n\n// startsWith tests\n\ndcl-proc startsWith_emptySearchAndSource;\n\n   assertOn( startsWith( '' : '' ) );\n\nend-proc;\n\ndcl-proc startsWith_emptySearch;\n\n   assertOn( startsWith( '' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchBlank;\n\n   assertOff( startsWith( ' ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_longerSearch;\n\n   assertOff( startsWith( 'LONG' : 'S' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchA;\n\n   assertOn( startsWith( 'A' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchAb;\n\n   assertOn( startsWith( 'AB' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchAbc;\n\n   assertOn( startsWith( 'ABC' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchX;\n\n   assertOff( startsWith( 'X' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchXy;\n\n   assertOff( startsWith( 'XY' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchXyz;\n\n   assertOff( startsWith( 'XYZ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchLowerA;\n\n   assertOff( startsWith( 'a' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchLowerAb;\n\n   assertOff( startsWith( 'ab' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchLowerAbc;\n\n   assertOff( startsWith( 'abc' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchLowerX;\n\n   assertOff( startsWith( 'x' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchLowerXy;\n\n   assertOff( startsWith( 'xy' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc startsWith_searchLowerXyz;\n\n   assertOff( startsWith( 'xyz' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\n// endsWith tests\n\ndcl-proc endsWith_emptySearchAndSource;\n\n   assertOn( endsWith( '' : '' ) );\n\nend-proc;\n\ndcl-proc endsWith_emptySearch;\n\n   assertOn( endsWith( '' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchBlank;\n\n   assertOff( endsWith( ' ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_longerSearch;\n\n   assertOff( endsWith( 'LONG' : 'S' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchA;\n\n   assertOff( endsWith( 'A' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchAb;\n\n   assertOff( endsWith( 'AB' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchAbc;\n\n   assertOff( endsWith( 'ABC' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchX;\n\n   assertOff( endsWith( 'X' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchXy;\n\n   assertOff( endsWith( 'XY' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchXyz;\n\n   assertOn( endsWith( 'XYZ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchYz;\n\n   assertOn( endsWith( 'YZ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchZ;\n\n   assertOn( endsWith( 'Z' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchLowerA;\n\n   assertOff( endsWith( 'a' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchLowerAb;\n\n   assertOff( endsWith( 'ab' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchLowerAbc;\n\n   assertOff( endsWith( 'abc' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchLowerX;\n\n   assertOff( endsWith( 'x' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchLowerXy;\n\n   assertOff( endsWith( 'xy' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchLowerXyz;\n\n   assertOff( endsWith( 'xyz' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchLowerYz;\n\n   assertOff( endsWith( 'yz' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc endsWith_searchLowerZ;\n\n   assertOff( endsWith( 'z' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\n// countOccurrencesOf tests\n\ndcl-proc countOccurrencesOf_emptySearchEmptySource;\n\n   assertNumericEquals( 0 : countOccurrencesOf( '' : '' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_blankSearchEmptySource;\n\n   assertNumericEquals( 0 : countOccurrencesOf( ' ' : '' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_emptySearchBlankSource;\n\n   assertNumericEquals( 0 : countOccurrencesOf( '' : ' ' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_blankSearchBlankSource;\n\n   assertNumericEquals( 1 : countOccurrencesOf( ' ' : ' ' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_characterMatchAtBeginning;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'A' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_characterMatchAtEnd;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'E' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_characterMatchInMiddle;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'C' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_stringMatchAtBeginning;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'AB' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_stringMatchAtEnd;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'DE' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_stringMatchInMiddle;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'BCD' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_caseDifference;\n\n   assertNumericEquals( 0 : countOccurrencesOf( 'bcd' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_longerSearch;\n\n   assertNumericEquals( 0 : countOccurrencesOf( 'ABCDE' : 'BCD' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_allCharacterMatches;\n\n   assertNumericEquals( 3 : countOccurrencesOf( 'a' : 'aaa' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_allStringMatches;\n\n   assertNumericEquals( 3 : countOccurrencesOf( 'aB' : 'aBaBaB' ) );\n\nend-proc;\n\ndcl-proc countOccurrencesOf_nonRepeatingMatch;\n\n   assertNumericEquals( 2 : countOccurrencesOf( 'ABA' : 'ABABABA' ) );\n\nend-proc;","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data","task":"unittest","difficulty":2,"language":"rpg4ff"}}
{"id":"TEXTUTILS_rpgunit","input_data":"end-proc;","context":"Rules.mk\nTEXTUTILS.SRVPGM: TEXTUTILS.BND TEXTUTILS.MODULE\nTEXTUTILS.BNDDIR: TEXTUTILS.BNDDIR TEXTUTILS.SRVPGM\n\nTEXTUTIL.BNDSRC\n/* Have to delete the BNDDIR, or it will always be older than the source */\n/* because the CRTBNDDIR will fail the second time and only the ADDBNDDIRE is executed */     \n!DLTOBJ OBJ(&O/&N) OBJTYPE(*BNDDIR)\nCRTBNDDIR BNDDIR(&O/&N)\nADDBNDDIRE BNDDIR(&O/&N) +\n   OBJ((*LIBL/TEXTUTIL *SRVPGM))\n\nTEXTUTILS.BND\n\n             strPgmExp  pgmLvl( *current ) signature( 'TEXTUTILS V1.00' )\n\n                export     symbol( trimAndUpperCase )\n                export     symbol( trimAndLowerCase )\n                export     symbol( toUpperCase )\n                export     symbol( toLowerCase )\n                export     symbol( parseDate )\n                export     symbol( getEnvironmentVariable )\n                export     symbol( toStringJsonArray )\n                export     symbol( scanReverse )\n                export     symbol( toYN )\n                export     symbol( toQuotedYN )\n                export     symbol( convertTimeStampToStringDate )\n                export     symbol( removeUnprintable )\n                export     symbol( isLetter )\n                export     symbol( isDigit )\n                export     symbol( toStringJsonArrayLarger )\n                export     symbol( splitStringMaxLength )\n                export     symbol( removeBlanks )\n                export     symbol( startsWith )\n                export     symbol( endsWith )\n                export     symbol( countOccurrencesOf )\n\n             endPgmExp\n\nTEXTUTIL_H.RPGLEINC\n**free\n// External procedure definitions for TextUtils\n//\n// Why:  Convert trim and to uppercase or trim and lowercase depending on the\n//       the procedure that is called trimAndToUpperCase or trimAndTolowerCase\n//       you can also call toLowerCase and toUpperCase if you want just to uppercase or lowercase\n//        the value and ignore the triming.\n\n\ndcl-c EMPTY_ISO_DATE  '0001-01-01';\ndcl-c EMPTY_DATE     d'0001-01-01';\n\ndcl-c CARRIAGE_RETURN           x'0D';\ndcl-c LINE_FEED                 x'25';\ndcl-c CARRIAGE_RETURN_LINE_FEED x'0D25';\ndcl-c LINE_FEED_CARRIAGE_RETURN x'250D';\n\ndcl-c SINGLE_QUOTE              '''';\ndcl-c DOUBLE_QUOTE              '\"'; \n\nDcl-s myvar varchar( 22 ) template; \n\nDcl-ds mods qualified dim( 1 ) template; \n     Myvarchar  varchar( 10 ); \n     Medate     date; \nEnd-ds; \n\n// convert the string time stamp to the string date.\ndcl-pr convertTimeStampToStringDate varchar( 10 );\n    stringTimeStamp varchar( 10 ) value;\nend-pr;\n\n// countOccurrencesOf\n//\n// Return the number of times a source string contains a\n// search string.\n//\n// A specific location in the source string won't match\n// the search string multiple times. For example, if you\n// search for:\n//\n//     ABA\n//\n// in:\n//\n//     ABABABA\n//\n// you will get a result of 2 (matches start at positions 1\n// and 5), not 3 (the match starting at 3 doesn't count).\n//\ndcl-pr countOccurrencesOf int( 10 );\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\n// endsWith\n//\n// Return *ON if the source string ends with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #startsWith\n//\ndcl-pr endsWith ind;\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\ndcl-pr getEnvironmentVariable varchar(150);\n      environmentVariableName char(64) value;\nend-pr;\n\n//******************************************************************************\n// isDigit\n//\n// Return *ON if the character is a numeric digit.\n//\n// @see isLetter\n\ndcl-pr isDigit ind;\n     characterToTest char( 1 ) const;\nend-pr;\n\n//******************************************************************************\n// isLetter\n//\n// Return *ON if the character is an upper-case or lower-case letter.\n//\n// @see isDigit\n\ndcl-pr isLetter ind;\n     characterToTest char( 1 ) const;\nend-pr;\n\ndcl-pr parseDate date;\n     *n varchar(50) value;\nend-pr;\n\n//-------------------------------------------------------------------------------------------------\n//  remove the blanks from the string that has been passed. This can be anywhere in the string.\n//-------------------------------------------------------------------------------------------------\ndcl-pr removeBlanks varchar( 64000 );\n    inputString     varchar( 64000 ) const;\nend-pr;\n\n//******************************************************************************\n// removeUnprintable\n//\n// Remove characters that cannot be printed, specifically control characters\n// and those not normally entered into input fields.\n\ndcl-pr removeUnprintable  varchar( 64000 );\n     *n varchar( 64000 ) const;\nend-pr;\n\n//*******************************************************************************************\n// scanReverse\n// This procedure will take a string and scan the last five characters, looking for the passed in\n// delimiter. If the delimiter is not found then it starts working itself backwards until you are at\n// beginning of the string. This returns the position ( Int value ) of the requested delimiter. or 0\n// the delimiter is not found.\n//*******************************************************************************************\ndcl-pr scanReverse uns( 10 );\n    comment varchar( 3500 ) value;\n    delimiter varchar( 6 ) value;\n    startPoint uns( 10 ) value options(*nopass);\nend-pr;\n\n// splitStringMaxLength\n//\n// Take a long string and break it up into smaller substrings based off of inputted max substring\n// length and optional separators(see below for rules). The subprocedure will try not to split up\n// any words, if the max length does not land on the separator, the process will step back until\n// it can find one. If a separator is not found, it will split the string at the max length mark.\n// When a separator is found, the string will be split at that point and the separator will be\n// deleted.\n//\n// @return\n//   If the split was successfull the indicatior will be *on. Otherwise the indicator is returned\n//   *off, check EVBLOG for more details on the error.\n//\n// @param callback\n//   A subprocedure in the program that is calling this procedure. The callback subprocedure will\n//   be called for each substring it splits off of the source string.\n//   We will send three parameters to your callback procedure:\n//      splitString  - the substring that has been split from the source string\n//      splitIndex   - the sequence number of the splitString.\n//      callbackData - will send what was sent to this subprocedure in the callbackData parameter.\n//                     It is also subject to change in your callback subprocedure.\n//\n// @param source\n//   The full string you wish to be split\n//\n// @param maxResultLength\n//   The maximum substring size you want returned. Must be greater that one.\n//\n// @param separator (optional)\n//   The separator will default to a space when not specified. If, however,\n//   you pass it an empty string ('') the procedure will not use a separator, instead split the\n//   string at the max length regardless of where that lands. It is also possible to pass the\n//   procedure multiple separators. For example if you pass the separator something like this '_- '\n//   the procedure will use underscore, dash, or space as a separator; whichever it finds first.\n//\n// @param callbackData (optional)\n//   This can be any variable type or data structure you like from your calling program. If you\n//   choose to pass something in nthe callbackData, it will be sent to your callback subprocedure.\n//   Example: subprocedure splitStringMaxLengthCallback05 in TEXTUTIL_T used as an int callbackData\n//   to increment each time the subprocedure was called in order to validate the splitIndex.\n//\ndcl-pr splitStringMaxLength ind;\n   callback        pointer( *proc )    const;\n   source          varchar( 3000000 )  const;\n   maxLength       int(          10 )  const;\n   separators      varchar(      20 )  const options( *noPass : *omit );\n   callbackData    pointer             const options( *noPass : *omit );\nend-pr;\n\n// startsWith\n//\n// Return *ON if the source string starts with the search string.\n// This is a case-sensitive comparison.\n//\n// @see #endsWith\n//\ndcl-pr startsWith ind;\n   search  varchar( 64000 ) const;\n   source  varchar( 64000 ) const;\nend-pr;\n\n// convert the string to lowercase.\ndcl-pr toLowerCase varchar(64000);\n     *n varchar(64000) value;\nend-pr;\n\n//******************************************************************************\n// toQuotedYN\n//\n// Return the value from toYN and put single quotes around it so it can\n// easily be added to an SQL string.\n//\n// see also toYN\n\ndcl-pr toQuotedYN char( 3 );\n     source varchar( 10 ) const;\nend-pr;\n\n//******************************************************************************\n// toStringJsonArray\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation.\n//\n// Examples:\n//\n// Input:\n//     (null)\n// Output:\n//     (empty string)\n//\n// Input:\n//     (array list without any elements)\n// Output:\n//     []\n//\n// Input:\n//     ABC\n// Output:\n//     [\"ABC\"]\n//\n// Input:\n//     ABC, 123\n// Output:\n//     [\"ABC\",\"123\"]\n//\n// Input:\n//     \"Quoted\" Text\n// Output:\n//     [\"\\\"Quoted\\\" Text\"]\n\ndcl-pr toStringJsonArray varchar( 65535 );\n     arrayList pointer const;\nend-pr;\n\n//******************************************************************************\n// toStringJsonArrayLarger\n//\n// Take a dynamic string array list and return a properly\n// encoded JSON representation. This can handle larger results\n// than toStringJsonArray.\n//\n// Examples:\n//\n// Input:\n//     (null)\n// Output:\n//     (empty string)\n//\n// Input:\n//     (array list without any elements)\n// Output:\n//     []\n//\n// Input:\n//     ABC\n// Output:\n//     [\"ABC\"]\n//\n// Input:\n//     ABC, 123\n// Output:\n//     [\"ABC\",\"123\"]\n//\n// Input:\n//     \"Quoted\" Text\n// Output:\n//     [\"\\\"Quoted\\\" Text\"]\n\ndcl-pr toStringJsonArrayLarger varchar( 2000000 );\n     arrayList pointer const;\nend-pr;\n\n// convert the string to uppercase.\ndcl-pr toUpperCase varchar(64000);\n    *n varchar(64000) value;\nend-pr;\n\n//******************************************************************************\n// toYN\n//\n// Take an input value, probably received from a browser or JSON request,\n// and return a Y or N character value appropriate for storing in 'boolean'\n// database column. Anything like Y, yes, true, 1, ... will result in a\n// Y response while anything else will return an N.\n//\n// see also toQuotedYN\n\ndcl-pr toYN char( 1 );\n     source varchar( 10 ) const;\nend-pr;\n\n// trim and convert the string to lowercase.\ndcl-pr trimAndLowerCase varchar(64000);\n     *n varchar(64000) value;\nend-pr;\n\n// trim and convert the string to uppercase.\ndcl-pr trimAndUpperCase varchar(64000);\n    *n varchar(64000) value;\nend-pr;","output":"Rules.mk\nTEXTUTIL_T.MODULE: TEXTUTIL_T.RPGLE\n\nTEXTUTIL_T.RPGLE\n**free\nctl-opt bndDir( 'TEXTUTILS' : 'IBMIUNIT/IBMIUNIT' : 'OSSILE/OSSILE' );\n\n// Test TEXTUTILS\n\n/copy TextUtil_H\n/include qinclude,testcase\n\n// test cases\n\ndcl-proc test_toUpperCase_fromLower export;\n\n   aEquals( 'GAME OF THRONES'\n                  : toUpperCase( 'game of thrones' )\n                  );\n\nend-proc;\n\ndcl-proc test_toUpperCase_fromMixed export;\n\n   aEquals( 'WINTERS COMING'\n                  : toUpperCase( 'Winters coming' )\n                  );\n\nend-proc;\n\ndcl-proc test_toUpperCase_withBlanks export;\n\n   aEquals( ' HA! '\n                  : toUpperCase( ' Ha! ' )\n                  );\n\nend-proc;\n\ndcl-proc test_toLowerCase_fromUpper export;\n\n   aEquals( 'its dark outside'\n                  : toLowerCase( 'ITS DARK OUTSIDE' )\n                  );\n\nend-proc;\n\ndcl-proc test_toLowerCase_fromMixed export;\n\n   aEquals( 'its warm outside'\n                  : toLowerCase( 'ITS warm OUTSIDE' )\n                  );\n\nend-proc;\n\ndcl-proc test_toLowerCase_withBlanks export;\n\n   aEquals( '  (hello?)  '\n                  : toLowerCase( '  (Hello?)  ' )\n                  );\n\nend-proc;\n\ndcl-proc test_trimAndUpperCase_fromLower export;\n\n   aEquals( 'WE HAVE ALOT TO DO'\n                  : trimAndUpperCase( 'we have alot to do     ' )\n                  );\n\nend-proc;\n\ndcl-proc test_trimAndUpperCase_leadingSpaces export;\n\n   aEquals( 'SPACES AT THE BEGINNING'\n                  : trimAndUpperCase( '   spaces at the beginning' )\n                  );\n\nend-proc;\n\ndcl-proc test_trimAndUpperCase_bothSpaces export;\n\n   aEquals( 'BOTH'\n                  : trimAndUpperCase( '   both  ' )\n                  );\n\nend-proc;\n\ndcl-proc test_trimAndLowerCase_fromMixed export;\n\n   aEquals( 'its storming outside'\n                  : trimAndLowerCase( 'ITs Storming Outside   ' )\n                  );\n\nend-proc;\n\ndcl-proc test_trimAndLowerCase_leadingSpaces export;\n\n   aEquals( 'more starting spaces'\n                  : trimAndLowerCase( '   MoRe Starting sPaCeS' )\n                  );\n\nend-proc;\n\ndcl-proc test_trimAndLowerCase_bothSpaces export;\n\n   aEquals( 'spaces everywhere!'\n                  : trimAndLowerCase( '       SPACES EVERYWHERE!   ' )\n                  );\n\nend-proc;\n\ndcl-proc test_toStringJsonArray_null export;\n\n   aEquals( ''\n                  : toStringJsonArray( *null )\n                  );\n\nend-proc;\n\ndcl-proc test_toStringJsonArray_zeroElements export;\n\n   arrayList = arraylist_create();\n\n   aEquals( '[]'\n                  : toStringJsonArray( arrayList )\n                  );\n\nend-proc;\n\ndcl-proc test_toStringJsonArray_oneElement export;\n\n   arrayList = arraylist_create();\n   arraylist_addString( arrayList : 'ABC' );\n\n   aEquals( '[\"ABC\"]'\n                  : toStringJsonArray( arrayList )\n                  );\n\nend-proc;\n\ndcl-proc test_toStringJsonArray_twoElements export;\n\n   arrayList = arraylist_create();\n   arraylist_addString( arrayList : 'ABC' );\n   arraylist_addString( arrayList : '123' );\n\n   aEquals( '[\"ABC\",\"123\"]'\n                  : toStringJsonArray( arrayList )\n                  );\n\nend-proc;\n\ndcl-proc test_toStringJsonArray_doubleQuotes export;\n\n   arrayList = arraylist_create();\n   arraylist_addString( arrayList : '\"Quoted\" Text' );\n\n   aEquals( '[\"\\\"Quoted\\\" Text\"]'\n                  : toStringJsonArray( arrayList )\n                  );\n\nend-proc;\n\ndcl-proc test_toStringJsonArray_singleQuotes export;\n\n   arrayList = arraylist_create();\n   arraylist_addString( arrayList : 'Everbrite''s' );\n\n   aEquals( '[\"Everbrite\\''s\"]'\n                  : toStringJsonArray( arrayList )\n                  );\n\nend-proc;\n\ndcl-proc test_toStringJsonArray_paddedValues export;\n\n   arrayList = arraylist_create();\n   arraylist_addString( arrayList : '0' );\n   arraylist_addString( arrayList : ' 1 ' );\n   arraylist_addString( arrayList : '  2  ' );\n\n   aEquals( '[\"0\",\" 1 \",\"  2  \"]'\n                  : toStringJsonArray( arrayList )\n                  );\n\nend-proc;\n\ndcl-proc test_scanReverse_from25 export;\n\n   assertNumericEquals( 22\n                     : scanReverse( 'Gollumn does not like nasty hobbit bread, ' +\n                                    'he wants fish and only fish'\n                                 : ' ' : 25 )\n                     );\n\nend-proc;\n\ndcl-proc test_scanReverse_from30 export;\n\n   assertNumericEquals( 28\n                     : scanReverse( 'Gollumn does not like nasty hobbit bread, ' +\n                                    'he wants fishbecausefishisreallygood'\n                                 : ' ' : 30 )\n                     );\n\nend-proc;\n\ndcl-proc test_scanReverse_from25to0 export;\n\n   assertNumericEquals( 0\n                     : scanReverse( 'Gollumndoesnotlikebreadhewantsfishandonlyfish'\n                                 : ' ' : 25 )\n                     );\n\nend-proc;\n\ndcl-proc test_scanReverse_fromEndToStart export;\n\n   assertNumericEquals( 0\n                     : scanReverse( 'Gollumndoesnotlikebreadhewantsfishandonlyfish'\n                                 : ' ' )\n                     );\n\nend-proc;\n\ndcl-proc test_scanReverse_fromEndTo56 export;\n\n   assertNumericEquals( 56\n                     : scanReverse( 'Why do Java programmers wear glasses, because they cant C#'\n                                 : ' ' )\n                     );\n\nend-proc;\n\ndcl-proc test_scanReverse_fromEndToComma export;\n\n   assertNumericEquals( 13\n                     : scanReverse( 'Programming , is fun!'\n                                 : ',' )\n                     );\n\nend-proc;\n\n// TODO: Shelly: copy remaining _textutil_ tests from UTILS_TEST\n\ndcl-proc test_toYN_singleCap export;\n\n   aEquals( 'Y'\n                  : toYN( 'Y' )  );\n\nend-proc;\n\ndcl-proc test_removeBlanks_nothing export;\n\n   aEquals( 'noBlanks!'\n                  : removeBlanks( 'noBlanks!' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeBlanks_before export;\n\n   aEquals( 'ahhhBlanksBefore!'\n                  : removeBlanks( ' ahhhBlanksBefore!' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeBlanks_middle export;\n\n   aEquals( 'ahhhBlanksMiddle!'\n                  : removeBlanks( 'ahhhBla nksMiddle!' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeBlanks_after export;\n\n   aEquals( 'ahhhBlanksAfter!'\n                  : removeBlanks( 'ahhhBlanksAfter! ' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeBlanks_multipleSpaces export;\n\n   aEquals( 'gollum'\n                  : removeBlanks( 'g o l l u m' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeUnprintable_nothing export;\n\n   aEquals( ' this String is_FINE! '\n                  : removeUnprintable( ' this String is_FINE! ' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeUnprintable_hex0 export;\n\n   aEquals( ''\n                  : removeUnprintable( x'000102030405060708090A0B0C0D0E0F' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeUnprintable_hex1 export;\n\n   aEquals( ''\n                  : removeUnprintable( x'101112131415161718191A1B1C1D1E1F' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeUnprintable_hex2 export;\n\n   aEquals( x'20'\n                  : removeUnprintable( x'202122232425262728292A2B2C2D2E2F' )\n                  );\n\nend-proc;\n\ndcl-proc test_removeUnprintable_hex3 export;\n\n   aEquals( ''\n                  : removeUnprintable( x'303132333435363738393A3B3C3D3E3F' )\n                  );\n\nend-proc;\n\ndcl-proc test_parseDate_slashMdcy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '1/2/2003' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slashMdy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '1/2/03' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slashMd99 export;\n\n   assertDateEquals( d'1999-01-02' : parseDate( '1/2/99' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dashMdcy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '1-2-2003' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dashMdy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '1-2-03' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dashMd99 export;\n\n   assertDateEquals( d'1999-01-02' : parseDate( '1-2-99' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dotDmcy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '2.1.2003' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slashMdcyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '1/2/2003T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slashMdyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '1/2/3T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slashMd99Time export;\n\n   assertDateEquals( d'1999-01-02' : parseDate( '1/2/99T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dashMdcyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '1-2-2003T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dashMdyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '1-2-3T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dashMd99Time export;\n\n   assertDateEquals( d'1999-01-02' : parseDate( '1-2-99T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dotDmcyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '2.1.2003T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slash0Mdcy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '01/02/2003' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slash0Mdy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '01/02/03' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slash0Md99 export;\n\n   assertDateEquals( d'1999-01-02' : parseDate( '01/02/99' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dash0Mdcy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '01-02-2003' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dash0Mdy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '01-02-03' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dash0Md99 export;\n\n   assertDateEquals( d'1999-01-02' : parseDate( '01-02-99' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dot0Dmcy export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '02.01.2003' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slash0MdcyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '01/02/2003T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slash0MdyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '01/02/03T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_slash0Md99Time export;\n\n   assertDateEquals( d'1999-01-02' : parseDate( '01/02/99T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dash0MdcyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '01-02-2003T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dash0MdyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '01-02-03T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dash0Md99Time export;\n\n   assertDateEquals( d'1999-01-02' : parseDate( '01-02-99T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dot0DmcyTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '02.01.2003T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dashIso export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '2003-01-02' ) );\n\nend-proc;\n\ndcl-proc test_parseDate_dashIsoTime export;\n\n   assertDateEquals( d'2003-01-02' : parseDate( '2003-01-02T04:05:06' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_0 export;\n\n   assertOn( isDigit( '0' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_1 export;\n\n   assertOn( isDigit( '1' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_2 export;\n\n   assertOn( isDigit( '2' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_3 export;\n\n   assertOn( isDigit( '3' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_4 export;\n\n   assertOn( isDigit( '4' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_5 export;\n\n   assertOn( isDigit( '5' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_6 export;\n\n   assertOn( isDigit( '6' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_7 export;\n\n   assertOn( isDigit( '7' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_8 export;\n\n   assertOn( isDigit( '8' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_9 export;\n\n   assertOn( isDigit( '9' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_lowerA export;\n\n   assertOff( isDigit( 'a' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_upperA export;\n\n   assertOff( isDigit( 'A' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_lowerE export;\n\n   assertOff( isDigit( 'e' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_upperE export;\n\n   assertOff( isDigit( 'E' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_lowerZ export;\n\n   assertOff( isDigit( 'z' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_upperZ export;\n\n   assertOff( isDigit( 'Z' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_space export;\n\n   assertOff( isDigit( ' ' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_comma export;\n\n   assertOff( isDigit( ',' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_decimal export;\n\n   assertOff( isDigit( '.' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_plus export;\n\n   assertOff( isDigit( '+' ) );\n\nend-proc;\n\ndcl-proc test_isDigit_minus export;\n\n   assertOff( isDigit( '-' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_0 export;\n\n   assertOff( isLetter( '0' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_1 export;\n\n   assertOff( isLetter( '1' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_2 export;\n\n   assertOff( isLetter( '2' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_3 export;\n\n   assertOff( isLetter( '3' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_4 export;\n\n   assertOff( isLetter( '4' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_5 export;\n\n   assertOff( isLetter( '5' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_6 export;\n\n   assertOff( isLetter( '6' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_7 export;\n\n   assertOff( isLetter( '7' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_8 export;\n\n   assertOff( isLetter( '8' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_9 export;\n\n   assertOff( isLetter( '9' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_lowerA export;\n\n   assertOn( isLetter( 'a' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_upperA export;\n\n   assertOn( isLetter( 'A' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_lowerE export;\n\n   assertOn( isLetter( 'e' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_upperE export;\n\n   assertOn( isLetter( 'E' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_lowerZ export;\n\n   assertOn( isLetter( 'z' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_upperZ export;\n\n   assertOn( isLetter( 'Z' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_space export;\n\n   assertOff( isLetter( ' ' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_comma export;\n\n   assertOff( isLetter( ',' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_decimal export;\n\n   assertOff( isLetter( '.' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_plus export;\n\n   assertOff( isLetter( '+' ) );\n\nend-proc;\n\ndcl-proc test_isLetter_minus export;\n\n   assertOff( isLetter( '-' ) );\n\nend-proc;\n\n// Split string tests\n\ndcl-proc test_splitStringMaxLength_noCallback export;\n\n   assertOff( splitStringMaxLength( *null\n                                 : 'Short String.'\n                                 : 25 )\n                                 : 'call to splitStringMaxLength failed' );\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback01 export;\n\n   fail( 'the callback failed' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_zeroLength export;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback01 )\n                                  : 'Short String.'\n                                  : 0 )\n                                  : 'call to splitStringMaxLength worked' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_negativeLength export;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback01 )\n                                  : 'Short String.'\n                                  : -1  )\n                                  : 'call to splitStringMaxLength worked' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_emptyString export;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback01 )\n                                  : ''\n                                  : 10 )\n            : 'call to splitStringMaxLength worked' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback02 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n   end-pi;\n\n   aEquals( 'Short String.'\n                   : splitSource\n                   : 'splitSource parameter' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_callbackStringParameter export;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback02 )\n                       : 'Short String.'\n                       : 25 );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback03 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   aEquals( 'Longer String.'\n                   : splitSource\n                   : 'splitSource parameter' );\n\n   assertNumericEquals( 1\n                      : splitIndex\n                      : 'splitIndex parameter' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_callbackStringAndIndexParameters export;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback03 )\n                       : 'Longer String.'\n                       : 25 );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback04 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         aEquals( 'string with'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         aEquals( 'multiple words'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_twoSplits export;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback04 )\n                       : 'string with multiple words'\n                       : 15 );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback05 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n      callbackData    pointer             const;\n   end-pi;\n\n   dcl-s callbacks          int(          10 )  based( callbackData );\n   dcl-s trimmedSplitSource varchar( 3000000 );\n\n   callbacks += 1;\n   trimmedSplitSource = %trim( splitSource );\n\n   assertNumericEquals( callbacks\n                      : splitIndex\n                      : 'splitIndex' );\n\n   select;\n      when ( splitIndex = 1 );\n         aEquals( 'string with'\n                         : trimmedSplitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         aEquals( 'multiple words'\n                         : trimmedSplitSource\n                         : 'second splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_onlyTwoSplits export;\n\n   dcl-s callbacks   int( 10 );\n\n   callbacks = 0;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback05 )\n                       : 'string with multiple words'\n                       : 15\n                       : *omit\n                       : %addr( callbacks ) );\n\n   assertNumericEquals( 2 : callbacks : 'callbacks' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_noSpaceSeparator export;\n\n   dcl-s callbacks   int( 10 );\n\n   callbacks = 0;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback05 )\n                       : 'string with/ multiple words'\n                       : 15\n                       : '/'\n                       : %addr( callbacks ) );\n\n   assertNumericEquals( 2 : callbacks : 'callbacks' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback06 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n      callbackData    pointer             const;\n   end-pi;\n\n   dcl-s callbacks  int( 10 )  based( callbackData );\n\n   callbacks += 1;\n\n   assertNumericEquals( callbacks\n                      : splitIndex\n                      : 'splitIndex' );\n\n   select;\n      when ( splitIndex = 1 );\n         aEquals( 'Long string that'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         aEquals( 'needs to be split'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      when ( splitIndex = 3 );\n         aEquals( 'multiple times,'\n                         : splitSource\n                         : 'third splitSource parameter' );\n\n      when ( splitIndex = 4 );\n         aEquals( 'lets say four.'\n                         : splitSource\n                         : 'third splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_multipleSplits export;\n\n   dcl-s callbacks   int( 10 );\n\n   callbacks = 0;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback06 )\n                       : 'Long string that needs to be split multiple times, lets say four.'\n                       : 20\n                       : *omit\n                       : %addr( callbacks ) );\n\n   assertNumericEquals( 4 : callbacks : 'callbacks' );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback07 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         aEquals( 'supercalifragilistic'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         aEquals( 'expialidocious'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_noSeparatorFound export;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback07 )\n                       : 'supercalifragilisticexpialidocious'\n                       : 20\n                       : *omit\n                       : *omit  );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback08 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         aEquals( 'Separator? I dont ne'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         aEquals( 'ed no stinkin separa'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      when ( splitIndex = 3 );\n         aEquals( 'tor!'\n                         : splitSource\n                         : 'third splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_emptySeparator export;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback08 )\n                       : 'Separator? I dont need no stinkin separator!'\n                       : 20\n                       : ''\n                       : *omit );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback09 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         aEquals( 'Separating in'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         aEquals( 'many locations'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      when ( splitIndex = 3 );\n         aEquals( 'with different'\n                         : splitSource\n                         : 'third splitSource parameter' );\n\n      when ( splitIndex = 4 );\n         aEquals( 'separators.'\n                         : splitSource\n                         : 'fourth splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_multipleSeparators export;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback09 )\n                       : 'Separating in-many locations with different_separators.'\n                       : 15\n                       : '_- '\n                       : *omit );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback10 export;\n\n   dcl-pi *n;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   select;\n      when ( splitIndex = 1 );\n         aEquals( 'Before you criticize someone, you should walk a mile in their shoes.' +\n                           ' That way'\n                         : splitSource\n                         : 'first splitSource parameter' );\n\n      when ( splitIndex = 2 );\n         aEquals( 'when you criticize them, you are a mile away from them and you have ' +\n                           'their shoes.'\n                         : splitSource\n                         : 'second splitSource parameter' );\n\n      other;\n         fail( 'unexpected splitIndex: ' + %char( splitIndex ) );\n\n   endSl;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_longString export;\n\n   splitStringMaxLength( %paddr( splitStringMaxLengthCallback10 )\n                       :'Before you criticize someone, you should walk a mile in their shoes. ' +\n                       'That way when you criticize them, you are a mile away from them and you '+\n                       'have their shoes.'\n                       : 80\n                       : *omit\n                       );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLengthCallback11 export export ;\n\n   dcl-pi *n ind;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   dcl-s result ind;\n\n   aEquals( 'Short String.'\n                   : splitSource\n                   : 'splitSource parameter' );\n\n   result = *off;\n\n   return result;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_callbackFailure export;\n\n   assertOff(splitStringMaxLength( %paddr( splitStringMaxLengthCallback11 )\n                       : 'Short String.'\n                       : 25 )\n             );\nend-proc;\n\n\ndcl-proc test_splitStringMaxLengthCallback12 export;\n\n   dcl-pi *n ind;\n      splitSource     varchar( 3000000 )  const;\n      splitIndex      int(          10 )  const;\n   end-pi;\n\n   if ( splitIndex = 1 );\n      return *off;\n   else;\n      return *on;\n   endIf;\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_callbackFailureSeparator export;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback12 )\n                                  : 'Short String.'\n                                  : 10 )\n            );\n\nend-proc;\n\ndcl-proc test_splitStringMaxLength_callbackFailureLength export;\n\n   assertOff( splitStringMaxLength( %paddr( splitStringMaxLengthCallback12 )\n                                  : 'Short String.'\n                                  : 10\n                                  : '' )\n            );\n\nend-proc;\n\n// startsWith tests\n\ndcl-proc test_startsWith_emptySearchAndSource export;\n\n   assertOn( startsWith( '' : '' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_emptySearch export;\n\n   assertOn( startsWith( '' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchBlank export;\n\n   assertOff( startsWith( ' ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_longerSearch export;\n\n   assertOff( startsWith( 'LONG' : 'S' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchA export;\n\n   assertOn( startsWith( 'A' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchAb export;\n\n   assertOn( startsWith( 'AB' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchAbc export;\n\n   assertOn( startsWith( 'ABC' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchX export;\n\n   assertOff( startsWith( 'X' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchXy export;\n\n   assertOff( startsWith( 'XY' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchXyz export;\n\n   assertOff( startsWith( 'XYZ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchLowerA export;\n\n   assertOff( startsWith( 'a' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchLowerAb export;\n\n   assertOff( startsWith( 'ab' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchLowerAbc export;\n\n   assertOff( startsWith( 'abc' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchLowerX export;\n\n   assertOff( startsWith( 'x' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchLowerXy export;\n\n   assertOff( startsWith( 'xy' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_startsWith_searchLowerXyz export;\n\n   assertOff( startsWith( 'xyz' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\n// endsWith tests\n\ndcl-proc test_endsWith_emptySearchAndSource export;\n\n   assertOn( endsWith( '' : '' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_emptySearch export;\n\n   assertOn( endsWith( '' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchBlank export;\n\n   assertOff( endsWith( ' ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_longerSearch export;\n\n   assertOff( endsWith( 'LONG' : 'S' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchA export;\n\n   assertOff( endsWith( 'A' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchAb export;\n\n   assertOff( endsWith( 'AB' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchAbc export;\n\n   assertOff( endsWith( 'ABC' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchX export;\n\n   assertOff( endsWith( 'X' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchXy export;\n\n   assertOff( endsWith( 'XY' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchXyz export;\n\n   assertOn( endsWith( 'XYZ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchYz export;\n\n   assertOn( endsWith( 'YZ' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchZ export;\n\n   assertOn( endsWith( 'Z' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchLowerA export;\n\n   assertOff( endsWith( 'a' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchLowerAb export;\n\n   assertOff( endsWith( 'ab' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchLowerAbc export;\n\n   assertOff( endsWith( 'abc' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchLowerX export;\n\n   assertOff( endsWith( 'x' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchLowerXy export;\n\n   assertOff( endsWith( 'xy' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchLowerXyz export;\n\n   assertOff( endsWith( 'xyz' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchLowerYz export;\n\n   assertOff( endsWith( 'yz' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\ndcl-proc test_endsWith_searchLowerZ export;\n\n   assertOff( endsWith( 'z' : 'ABCDEF XYZ' ) );\n\nend-proc;\n\n// countOccurrencesOf tests\n\ndcl-proc test_countOccurrencesOf_emptySearchEmptySource export;\n\n   assertNumericEquals( 0 : countOccurrencesOf( '' : '' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_blankSearchEmptySource export;\n\n   assertNumericEquals( 0 : countOccurrencesOf( ' ' : '' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_emptySearchBlankSource export;\n\n   assertNumericEquals( 0 : countOccurrencesOf( '' : ' ' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_blankSearchBlankSource export;\n\n   assertNumericEquals( 1 : countOccurrencesOf( ' ' : ' ' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_characterMatchAtBeginning export;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'A' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_characterMatchAtEnd export;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'E' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_characterMatchInMiddle export;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'C' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_stringMatchAtBeginning export;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'AB' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_stringMatchAtEnd export;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'DE' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_stringMatchInMiddle export;\n\n   assertNumericEquals( 1 : countOccurrencesOf( 'BCD' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_caseDifference export;\n\n   assertNumericEquals( 0 : countOccurrencesOf( 'bcd' : 'ABCDE' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_longerSearch export;\n\n   assertNumericEquals( 0 : countOccurrencesOf( 'ABCDE' : 'BCD' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_allCharacterMatches export;\n\n   assertNumericEquals( 3 : countOccurrencesOf( 'a' : 'aaa' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_allStringMatches export;\n\n   assertNumericEquals( 3 : countOccurrencesOf( 'aB' : 'aBaBaB' ) );\n\nend-proc;\n\ndcl-proc test_countOccurrencesOf_nonRepeatingMatch export;\n\n   assertNumericEquals( 2 : countOccurrencesOf( 'ABA' : 'ABABABA' ) );\n\nend-proc;","metadata":{"provenance":"https://github.com/AIforIBMi/rpg-genai-data/tree/main/data","task":"unittest","difficulty":2,"language":"rpg4ff"}}